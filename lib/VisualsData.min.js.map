{"version":3,"sources":["VisualsData.js","../ts/visualsData/semanticQuery/sqExprVisitor.ts","../ts/visualsData/types/enumType.ts","../ts/visualsData/types/fill.ts","../ts/visualsData/types/image.ts","../ts/visualsData/types/structuralType.ts","../ts/visualsData/types/valueType.ts","../ts/visualsData/contracts/dataShapeBinding.ts","../ts/visualsData/contracts/dataShapeBindingDataReduction.ts","../ts/visualsData/contracts/federatedConceptualSchema.ts","../ts/visualsData/contracts/selector.ts","../ts/visualsData/contracts/query.ts","../ts/visualsData/contracts/queryProjection.ts","../ts/visualsData/contracts/visualData.ts","../ts/visualsData/formatting/dateTimeSequence.ts","../ts/visualsData/formatting/displayUnitSystem.ts","../ts/visualsData/formatting/numericSequence.ts","../ts/visualsData/formatting/numericSequenceRange.ts","../ts/visualsData/formatting/valueFormatter.ts","../ts/visualsData/dataView/dataRoleHelper.ts","../ts/visualsData/dataView/dataViewCategoricalReader.ts","../ts/visualsData/dataView/dataViewConcatenateCategoricalColumns.ts","../ts/visualsData/dataView/dataViewMappingVisitor.ts","../ts/visualsData/dataView/dataViewNormalizeValues.ts","../ts/visualsData/dataView/dataViewObject.ts","../ts/visualsData/dataView/dataViewObjectDefinition.ts","../ts/visualsData/dataView/dataViewObjectDescriptor.ts","../ts/visualsData/dataView/dataViewObjectEvaluationUtils.ts","../ts/visualsData/dataView/dataViewObjectEvaluator.ts","../ts/visualsData/dataView/dataViewPivotCategorical.ts","../ts/visualsData/dataView/dataViewPivotMatrix.ts","../ts/visualsData/dataView/dataViewSelfCrossJoin.ts","../ts/visualsData/dataView/dataViewPivotCategoricalToPrimaryGroups.ts","../ts/visualsData/dataView/dataViewTransform.ts","../ts/visualsData/displayNameGetter.ts","../ts/visualsData/iFormattingService.ts","../ts/visualsData/semanticQuery/exprPatterns/fieldExprPattern.ts","../ts/visualsData/dataView/dataViewAnalysis.ts","../ts/visualsData/dataView/dataViewRoleWildcard.ts","../ts/visualsData/dataView/dataViewScopeIdentity.ts","../ts/visualsData/dataView/dataViewScopeWildcard.ts","../ts/visualsData/dataView/rules/colorAllocatorCache.ts","../ts/visualsData/dataView/dataViewRegression.ts","../ts/visualsData/dataView/dataViewSelectTransform.ts","../ts/visualsData/dataView/rules/categoricalEvalContext.ts","../ts/visualsData/dataView/rules/tableEvalContext.ts","../ts/visualsData/dataView/rules/ruleEvaluation.ts","../ts/visualsData/dataView/rules/colorRuleEvaluation.ts","../ts/visualsData/dataView/utils/dataViewMatrixUtils.ts","../ts/visualsData/dataView/utils/dataViewMetadataColumnUtils.ts","../ts/visualsData/contracts/conceptualSchema.ts","../ts/visualsData/dataView/scriptResultUtil.ts","../ts/visualsData/segmentation/dataViewMerger.ts","../ts/visualsData/semanticQuery/sqExprRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/equalsToInRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/filterScopeIdsCollector.ts","../ts/visualsData/semanticQuery/exprPatterns/scopeIdentityExtractor.ts","../ts/visualsData/semanticQuery/primitiveValueEncoding.ts","../ts/visualsData/semanticQuery/sqAggregationOperations.ts","../ts/visualsData/semanticQuery/sqHierarchyExprUtils.ts","../ts/visualsData/semanticQuery/sqExprGroupUtils.ts","../ts/visualsData/semanticQuery/sqExpr.ts","../ts/visualsData/semanticQuery/sqExprUtils.ts","../ts/visualsData/semanticQuery/semanticQueryRewriter.ts","../ts/visualsData/semanticQuery/semanticQuery.ts","../ts/visualsData/dataView/dataViewBuilder.ts","../ts/visualsData/dataView/rules/staticEvalContext.ts","../ts/visualsData/dataView/rules/matrixEvalContext.ts","../ts/visualsData/services/formattingService.ts","../ts/visualsData/services/serialization/sqExprShortSerializer.ts","../ts/visualsData/selection/selectionId.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","powerbi","data","DefaultSQExprVisitorWithArg","visitEntity","expr","arg","visitDefault","visitColumnRef","visitMeasureRef","visitAggr","visitPercentile","visitHierarchy","visitHierarchyLevel","visitPropertyVariationSource","visitSelectRef","visitBetween","visitIn","visitAnd","visitOr","visitCompare","visitContains","visitExists","visitNot","visitStartsWith","visitConstant","visitDateSpan","visitDateAdd","visitNow","visitDefaultValue","visitAnyValue","visitArithmetic","visitFillRule","visitResourcePackageItem","visitScopedEval","visitWithRef","DefaultSQExprVisitor","_super","apply","arguments","DefaultSQExprVisitorWithTraversal","source","accept","lower","upper","args","i","len","length","values","valueTuple","j","jlen","left","right","input","rule","gradient2","linearGradient2","gradient3","linearGradient3","visitLinearGradient2","visitLinearGradient3","visitFillRuleStop","min","max","mid","expression","_i","_a","scope","scopeExpr","stop","color","value","createEnumType","members","EnumType","allMembers","validMembers","membersToReturn","allMembers_1","member","_","contains","push","FillSolidColorTypeDescriptor","nullable","descriptor","advancedDescriptor","ImageDefinition","urlType","misc","imageUrl","StructuralTypeDescriptor","isValid","type","fill","fillRule","filter","image","paragraphs","getPrimitiveType","extendedType","PrimitiveTypeMask","isPrimitiveType","PrimitiveTypeWithFlagsMask","getCategoryFromExtendedType","category","ExtendedType","delimIdx","lastIndexOf","baseCategory","slice","toExtendedType","primitiveType","primitiveString","PrimitiveType","t","Null","categoryType","categoryPrimitiveType","matchesExtendedTypeWithAnyPrimitive","a","PrimitiveTypeFlagsExcludedMask","EnumExtensions","jsCommon","ValueType","enumType","underlyingType","hasFlag","Temporal","temporalType","TemporalType","Geography","geographyType","GeographyType","Miscellaneous","miscType","MiscellaneousType","Formatting","formattingType","FormattingType","Enumeration","Scripting","scriptingType","ScriptType","fromDescriptor","text","fromExtendedType","Text","integer","Integer","numeric","Double","bool","Boolean","dateTime","DateTime","duration","Duration","binary","Binary","none","None","scripting","ScriptSource","enumeration","fromEnum","temporal","year","Year_Integer","month","Month_Integer","geography","address","Address","city","City","continent","Continent","country","Country","county","County","region","Region","postalCode","PostalCode_Text","stateOrProvince","StateOrProvince","place","Place","latitude","Latitude_Double","longitude","Longitude_Double","Image","ImageUrl","webUrl","WebUrl","barcode","Barcode_Text","formatting","Color","formatString","FormatString","alignment","Alignment","labelDisplayUnits","LabelDisplayUnits","fontSize","FontSize","labelDensity","LabelDensity","operations","searchEnabled","SearchEnabled","fromPrimitiveTypeAndCategory","id","toString","typeCache","isCompatibleTo","otherTypes","valueType","otherTypes_1","otherType","otherValueType","isCompatibleFrom","other","otherPrimitiveType","equals","isEqual","defineProperty","get","enumerable","configurable","Numeric","Date","Time","Year","Month","PostalCode","Latitude","Longitude","Barcode","DataShapeBindingLimitType","SubtotalType","DataShapeBindingDataReduction","createFrom","reduction","result","top","Top","count","Count","bottom","Bottom","sample","Sample","window","Window","FederatedConceptualSchema","options","schemas","links","schema","name","data_1","Selector","filterFromSelector","selectors","isNot","isEmpty","exprs","ilen","identity","data_2","exprToAdd","undefined","SQExprBuilder","and","DataViewScopeIdentity","filterFromExprs","matchesData","selector","identities","selectorData","dataItem","selectorDataItem","DataViewScopeWildcard","matches","matchesKeys","keysList","selectorDataLength","selectorDataExprs","ScopeIdentityExtractor","getKeys","SQExprUtils","sequenceEqual","x","y","metadata","equalsDataArray","equalsData","selector1","selector2","roles","DataViewRoleWildcard","getKey","toStringify","data_3","key","JSON","stringify","containsWildcard","dataItems","dataItems_1","wildCard","hasRoleWildcard","dataItems_2","isRoleWildcard","getArithmeticOperatorName","arithmeticOperatorKind","Error","EntitySourceType","TimeUnit","QueryAggregateFunction","QueryComparisonKind","SemanticType","FilterKind","QueryProjectionCollection","items","activeProjectionRefs","showAll","_activeProjectionRefs","_showAll","all","set","queryReferences","queryRefs","map","val","queryRef","queryReferences_1","queryReference","addActiveQueryReference","getLastActiveQueryReference","replaceQueryRef","oldQueryRef","newQueryRef","item","clone","cloneDeep","QueryProjectionsByRole","clonedRoles","roleName","getRole","DisplayUnitSystemType","DateTimeSequence","unit","sequence","add","date","extendToCover","addInterval","interval","splice","moveToCover","delta","getDelta","Math","floor","calculate","dataMin","dataMax","expectedCount","getIntervalUnit","DateTimeUnit","calculateYears","calculateMonths","Week","calculateWeeks","Day","calculateDays","Hour","calculateHours","Minute","calculateMinutes","Second","calculateSeconds","Millisecond","calculateMilliseconds","yearsRange","NumericSequenceRange","calculateDataRange","getFullYear","NumericSequence","newMinYear","fromNumericSequence","minYear","maxYear","minMonth","getMonth","maxMonth","calculateUnits","firstDayOfWeek","minDayOfWeek","getDay","dayOffset","minDay","getDate","ceilWithPrecision","floorWithPrecision","getHours","getMinutes","getSeconds","round","DateUtils","addYears","addMonths","addWeeks","addDays","addHours","addMinutes","addSeconds","addMilliseconds","intervalOffset","getTime","maxCount","totalDays","totalHours","totalMinutes","totalSeconds","totalMilliseconds","getMilliseconds","MIN_COUNT","MAX_COUNT","isLeap","getMonthDays","MonthDaysLeap","MonthDays","yearDelta","day","isLeapDay","setFullYear","monthDelta","weeks","days","hours","minutes","seconds","milliseconds","createDisplayUnits","unitLookup","adjustMinBasedOnPreviousUnit","units","maxExponent","names","addUnitIfNonEmpty","pow10","title","format","labelFormat","previousUnit","applicableRangeMax","DisplayUnit","applicableRangeMin","defaultScientificBigNumbersBoundary","scientificSmallNumbersBoundary","PERCENTAGE_FORMAT","SCIENTIFIC_FORMAT","DEFAULT_SCIENTIFIC_FORMAT","SUPPORTED_SCIENTIFIC_FORMATS","project","removeDecimalNoise","reverseProject","isApplicableTo","abs","precision","getPrecision","greaterOrEqualWithPrecision","lessWithPrecision","isScaling","DisplayUnitSystem","displayUnit","update","unitBaseValue","findApplicableDisplayUnit","decimals","trailingZeros","isFormatSupported","getNumberOfDecimalsForFormatting","hasScientitifcFormat","formatHelper","isScalingUnit","shouldRespectScalingUnit","formattingService","formatValue","UNSUPPORTED_FORMATS","test","isPercentageFormat","indexOf","nonScientificFormat","visuals","valueFormatter","DefaultNumericFormat","NumberFormat","addDecimalsToFormat","isStandardNumberFormat","formatNumberWithCustomOverride","formatSingleValue","shouldUseValuePrecision","isScientific","toUpperCase","supportsScientificFormat","shouldFallbackToScientific","getScientificFormat","numericFormat","getNumericFormat","NoDisplayUnitSystem","call","DefaultDisplayUnitSystem","getUnits","reset","previousUnitValue","Infinity","WholeUnitsDisplayUnitSystem","DataLabelsDisplayUnitSystem","AUTO_DISPLAYUNIT_VALUE","NONE_DISPLAYUNIT_VALUE","concat","range","maxAllowedMargin","minPower","useZeroRefPoint","steps","ensureInRange","MIN_EXP","forcedSingleStop","getSize","canExtendMin","hasFixedMin","canExtendMax","hasFixedMax","size","exp","log10","stepExp","expectedCountExp","power","roundMin","floorToPrecision","roundMax","ceilToPrecision","roundRange","calculateFixedRange","shrinkByStep","dexp","e","stepsCount","stepPower","step","roundToPrecision","trimMinMax","stepCount","maxStepCount","minStepCount","offset","minMargin","maxMargin","marginPrecision","_ensureIncludeZero","includeZero","_ensureNotEmpty","DEFAULT_MAX","_ensureDirection","temp","oldCount","newCount","deltaCount","ceil","fixedMin","fixedMax","hasDataRange","ValueUtil","hasValue","MIN_SUPPORTED_DOUBLE","MAX_SUPPORTED_DOUBLE","beautify","BeautifiedFormat","defaultLocalizedStrings","describeUnit","exponent","exponentLookup","getLocalizedString","stringId","getFormatMetadata","getCustomFormatMetadata","setLocaleOptions","locale","createDefaultFormatter","allowFormatBeautification","formatBeaut","formatCore","shouldUseNumericDisplayUnits","displayUnitSystem_1","createDisplayUnitSystem","displayUnitSystemType","singleValueFormattingMode_1","formatSingleValues","value2","decimals_1","forcePrecision_1","MaxScaledDecimalPlaces","detectAxisPrecision","axisValue","isInteger","formattedValue","getStringFormat","StringExtensions","isNullOrUndefinedOrWhiteSpaceString","MaxValueForDisplayUnitRounding","shouldUseDateUnits","tickCount","unit_1","dateFormatString","formatVariantMeasureValue","column","formatStringProp","nullsAreBlank","valueFormat","getFormatString","DateTimeMetadataColumn","describe","Default","WholeUnits","Verbose","DataLabels","MinIntegerValueForDisplayUnits","isCustomFormat","isStandardFormat","MinPrecisionForDisplayUnits","formatStringProperty","suppressTypeFallback","propertyValue","DataViewObjects","getValue","objects","columnType","DefaultDateFormat","DefaultIntegerFormat","formatListCompound","strings","conjunction","lastIndex","restatementComma","formatListAnd","restatementCompoundAnd","formatListOr","restatementCompoundOr","isNaN","NaN","Number","NEGATIVE_INFINITY","negativeInfinity","POSITIVE_INFINITY","infinity","getDisplayUnits","displayUnitSystem","0.00 %;-0.00 %;0.00 %","0.0 %;-0.0 %;0.0 %","NullValue","BooleanTrue","BooleanFalse","NaNValue","InfinityValue","NegativeInfinityValue","RestatementComma","RestatementCompoundAnd","RestatementCompoundOr","DisplayUnitSystem_EAuto_Title","DisplayUnitSystem_E0_Title","DisplayUnitSystem_E3_LabelFormat","DisplayUnitSystem_E3_Title","DisplayUnitSystem_E6_LabelFormat","DisplayUnitSystem_E6_Title","DisplayUnitSystem_E9_LabelFormat","DisplayUnitSystem_E9_Title","DisplayUnitSystem_E12_LabelFormat","DisplayUnitSystem_E12_Title","Percentage","Percentage1","TableTotalLabel","Tooltip_HighlightedValueDisplayName","Funnel_PercentOfFirst","Funnel_PercentOfPrevious","Funnel_PercentOfFirst_Highlight","Funnel_PercentOfPrevious_Highlight","GeotaggingString_Continent","GeotaggingString_Continents","GeotaggingString_Country","GeotaggingString_Countries","GeotaggingString_State","GeotaggingString_States","GeotaggingString_City","GeotaggingString_Cities","GeotaggingString_Town","GeotaggingString_Towns","GeotaggingString_Province","GeotaggingString_Provinces","GeotaggingString_County","GeotaggingString_Counties","GeotaggingString_Village","GeotaggingString_Villages","GeotaggingString_Post","GeotaggingString_Zip","GeotaggingString_Code","GeotaggingString_Place","GeotaggingString_Places","GeotaggingString_Address","GeotaggingString_Addresses","GeotaggingString_Street","GeotaggingString_Streets","GeotaggingString_Longitude","GeotaggingString_Longitude_Short","GeotaggingString_Latitude","GeotaggingString_Latitude_Short","GeotaggingString_PostalCode","GeotaggingString_PostalCodes","GeotaggingString_ZipCode","GeotaggingString_ZipCodes","GeotaggingString_Territory","GeotaggingString_Territories","null","true","false","displayName","DataRoleHelper","getMeasureIndexOfRole","grouped","firstGroup","hasRole","getCategoryIndexOfRole","categories","hasRoleInDataView","dataView","columns","any","c","hasRoleInValueColumn","valueColumn","createIDataViewCategoricalReader","DataViewCategoricalReader","categorical","hasValidCategories","hasAnyValidValues","valueRoleIndexMapping","firstGroupValues","valueIndex","valueCount","valueRoles","role","dataHasDynamicSeries","hasCategories","getCategoryCount","getCategoryValues","getCategoryFromRole","getCategoryValue","categoryIndex","getCategoryColumn","getCategoryMetadataColumn","getCategoryColumnIdentityFields","identityFields","getCategoryDisplayName","targetColumn","hasCompositeCategories","hasCategoryWithRole","getCategoryObjects","hasValues","hasHighlights","highlights","seriesIndex","getValueInternal","getHighlight","getAllValuesForRole","valuesInRole","roleValueIndex","roleValueCount","getAllHighlightsForRole","groupIndex","valueColumnIndexInRole","valueColumnIndex","groupedValues","getFirstNonNullValueForCategory","seriesCount","getMeasureQueryName","queryName","getValueColumn","getValueMetadataColumn","getAllValueMetadataColumnsForRole","getValueDisplayName","hasDynamicSeries","getSeriesCount","valueRoleName","roleIndexMap","getSeriesObjects","getSeriesValueColumns","getSeriesValueColumnGroup","getSeriesMetadataColumn","getSeriesColumnIdentityFields","getSeriesName","getSeriesDisplayName","DataViewConcatenateCategoricalColumns","inherit","Prototype","inheritSingle","detectAndApply","objectDescriptors","roleMappings","projectionOrdering","selects","projectionActiveItems","dataViewCategorical","concatenationSource","detectCategoricalRoleForHierarchicalGroup","columnsSortedByProjectionOrdering","sortColumnsByProjectionOrdering","activeItemsToIgnoreInConcatenation","chain","activeItemInfo","suppressConcat","applyConcatenation","applyToPlayChartCategorical","categoryRoleName","transformingColumns_1","transformingMetadata","m","transformingDataView","dataViewMappings","roleKinds","DataViewSelectTransform","createRoleKindFromMetadata","projections","projectionsFromSelects","supportedRoleMappings","DataViewAnalysis","chooseDataViewMappings","supportedMappings","isEveryRoleMappingForCategorical","every","roleMapping","targetRoleName_1","getSingleCategoryRoleNameInEveryRoleMapping","isVisualExpectingMaxOneCategoryColumn","categoryColumnsForTargetRole_1","categoryColumn","areValuesCountsEqual","categoricalRoleMappings","uniqueCategoryRoles","categoryRoles","getAllRolesInCategories","uniq","isSameCategoryRoleNameInAllRoleMappings","isUndefined","categoricalRoleName","conditions","condition","categoricalRoleMapping","roleNames","DataViewMapping","visitCategoricalCategories","visitRole","queryRefsToIgnore","formatStringPropId","DataViewObjectDescriptors","findFormatString","concatenatedValues","concatenateValues","columnsSourceSortedByProjectionOrdering","concatenatedColumnMetadata","createConcatenatedColumnMetadata","transformedDataView","addToMetadata","concatenatedCategoryColumn","createConcatenatedCategoryColumn","transformedCategoricalCategories","difference","transformedCategorical","columnsSortedByProjectionOrdering_1","columnsInProjectionOrdering","columnsByIndex_1","columns_1","index","columnIndicesInProjectionOrdering","columnIndex","sourceColumnsSortedByProjectionOrdering","concatenatedDisplayName","sourceColumnsSortedByProjectionOrdering_1","columnSource","newRoles","newColumnMetadata","columnSourceForCurrentDrillLevel","last","isMeasure","newColumn","transformedColumns","transformedMetadata","columnMetadata","newCategoryColumn","firstColumn","visitMapping","mapping","visitor","visitCategorical","table","visitTable","matrix","visitMatrix","tree","visitTree","single","visitSingle","visitCategoricalValues","visitBind","visitFor","visitList","visitReduction","groupedRoleMapping","visitGrouped","group","select","rows","visitMatrixItems","visitTreeNodes","nodes","visitTreeValues","context","bind","to","forValue","select_1","by","reductionAlgorithm","dataReductionAlgorithm","DataViewNormalizeValues","rolesToNormalize","dataRoles","requiredTypes","filterVariantMeasures","dataview","columnFilter","generateMetadataColumnFilter","valueFilter","generateValueFilter","usedMappings","dataViewMappings_1","dataViewMapping","dataViewMappingProp","filterVariantMeasuresCategorical","filterVariantMeasuresTable","filterVariantMeasuresTreeNode","root","filterVariantMeasuresMatrix","filterVariantMeasuresSingle","columnsToNormalize","columns_2","rolesToNormalize_1","columnValueFilters","columns_3","columnValueFilter","generateColumnValueFilter","getColumnRequiredTypes","doesValueMatchTypes","columnRoles","rolesToNormalize_2","_b","typeDescriptor","valuesGrouped","valuesGrouped_1","valueGroup","valuesInGroup","valuesInGroup_1","normalizeVariant","filteredColumns","columns_4","filteredColumns_1","node","children","child","filterVariantMeasuresMatrixRecursive","dataviewMatrix","nodeValue","valueSourceIndex","valueSources","isNumber","rolesToNormalize_3","dataViewMappings_2","firstColumnByRoleName","object","types","types_1","columns_5","propertyId","defaultValue","objectOrMap","objectName","DataViewObject","propertyName","getObject","getUserDefinedObjects","getFillColor","defaultColor","solid","isUserDefined","isArray","getFillColorByPropertyName","DataViewObjectDefinitions","JsonComparer","ensure","defns","defnsForObject","defn","newDefn","properties","deleteProperty","getObjectDefinition","DataViewObjectDefinition","deleteSingleProperty","setValue","getPropertyContainer","propertiesAreEqual","SemanticFilter","isSameFilter","allPropertiesAreEqual","keys","property","encodePropertyValue","valueTypeDescriptor","$","isNumeric","imageValue","imageDefinition","url","scaling","original","cloned","originalDefns","clonedDefns","originalDefns_1","originalDefn","cloneProperties","descriptors","findProperty","propDesc","formattingTypeDesc","findFilterOutput","propType","selfFilter","findSelfFilter","findSelfFilterEnabled","findDefaultValue","propPredicate","objPropDescs","DataViewObjectEvaluationUtils","evaluateDataViewObjects","evalContext","objectDefns","objectDefinition","evaluatedObject","DataViewObjectEvaluator","run","groupObjectsBySelector","objectDefinitions","objectDefnList","objectDefn","ensureDefinitionListForSelector","metadataOnce","groupedObjects","userDefined","groupedObjects_1","item_1","addImplicitObjects","objectsForAllSelectors","selectTransforms","addDefaultFormatString","addDefaultValue","selectIdx","selectLen","selectTransform","applyFormatString","getColumnFormatForIndex","defaultValueProp","selectTransforms_1","applyDefaultValue","columnIdx","columnLen","formatStringValue","applyMetadataProperty","metadataObjects","targetObjectDefn","targetMetadataObject","findWithMatchingSelector","targetObjectDefns","findExistingObject","objectDescriptor","propertyDefinitions","propertyDescriptors","propertyDefinition","propertyDescriptor","evaluateProperty","structuralType","evaluateValue","RuleEvaluation","evaluateFill","evaluateFillRule","evaluateImage","evaluateParagraphs","fillDefn","fillType","fillRuleDefn","evaluateColorStop","colorStop","colorValueType","numericType","definition","textType","evaluateArrayCopyOnChange","evaluateParagraph","evaluated","definitionTextRuns","textRuns","evaluatedTextRuns","evaluateTextRun","definitionValue","evaluatedValue","definitions","evaluator","evaluatedValues","take","SQExpr","ExpressionEvaluator","evaluate","instance","getExprValue","inputValue","colorAllocator","getColorAllocator","DataViewPivotCategorical","categoryIdentities","categoryValues","pivotedColumns","pivotedValues","rowIdx","rowCount","categoryValue","categoryIdentity","colIdx","colCount","pivotedColumn","groupName","pivotedValue","subtotal","pivotedMetadata","DataViewTransform","createValueColumns","DataViewPivotMatrix","dataViewMatrix","columnHierarchyRewritten","rowHierarchyRewritten","levels","pivotedRowNode","level","columnLeafNodes","measureCount","pivotResultMeasureHeaderLevel","index_1","callback","measureHeaderLeaf","columnLeafNode","levelSourceIndex","isSubtotal","hierarchyTreesRewritten","forEachLeaf","cloneTreeExecuteOnLeaf","cloneTree","sources","updatedRowRoot","updatedNode","newChildren","updatedChild","createNullValues","array","Array","inheritArrayWithValue","nullValues","inherited","DataViewSelfCrossJoin","applyCategorical","dataViewMetadata","categoryLength","valuesArray","createCategoricalDataViewBuilder","withCategories","withGroupedValues","createGroupedValues","build","nullValuesArray","valuesArrayLen","seriesData","seriesDataItem","originalValueColumn","originalHighlightValues","seriesDataItemCategory","groupColumn","identityFrom","fields","valueColumns","v","DataViewPivotCategoricalToPrimaryGroups","ArrayExtensions","pivotBinding","binding","allMappings","finalMapping","defaultDataVolume","canPivotCategorical","Primary","Groupings","Secondary","DataReduction","DataVolume","dataVolume","isPivotableAxis","axis","Projections","Subtotal","SuppressedProjections","unpivotResult","oldDataView","inferUnpivotTransform","newDataView","copy","newDataViewMatrix","unpivotMatrix","hasCompositeGroupInSeries","utils","DataViewMatrixUtils","containsCompositeGroup","categoricalFromUnpivotedMatrix","supportedDataViewMappings","categoricalMapping","matrixDataview","categoryGroups","valueGroups","addGroupingRole","groups","roleProjections","roleProjection","VisualDataRoleKind","Grouping","_c","oldMatrix","oldRows","oldRoot","oldChildren","series","seriesIdLevel","seriesIdFields","childIdentityFields","categoryIdLevel","categoryIdFields","findCategory","addCategory","categoryNode","oldChildren_1","seriesNode","matrixValues","_d","newColumns","s","inheritedNode","newColChildren","srcnode","dstnode","newRows","row","rowValues","mvalues","k","l","newMatrix","measureMetadata","createCategoryColumnsFromUnpivotedMatrix","seriesColumn","valueColumnMetadataSrc","valueColumnMetadataDst","groups_1","unpivotedMatrix","categoryIdentityFields","categorySourceColumns","groupLevelValues","levelValues","transforms","activeItems","colorAllocatorFactory","transformEmptyDataView","visualDataViews","transformQueryToVisualDataView","DataViewRegression","transformSelects","transformedDataViews","splits","transformDataView","splits_1","split","transformed","emptyDataView","transformObjects","selectsToInclude","targetKinds","getTargetKinds","ordering","roleMappings_1","targetDataViewKinds","columnRewrites","applyTransformsToColumns","applyRewritesToCategorical","pivotIfNecessary","matrixTransformationContext","applyRewritesToMatrix","shouldPivotMatrix","applyRewritesToTable","prototypeColumns","rewrites","prototypeColumn","getFormatForColumn","kpi","sort","discourageAggregationAcrossGroups","from","override","rewrittenSource","findOverride","rewritten","overrideArray","valuesOverride","rewrittenValuesSource","seriesGroups_1","isDynamicSeries_1","nextSeriesGroupIndex","currentSeriesGroup","currentValueColumn","newToOldPositions","createTableColumnPositionMapping","columnsClone","sourceColumn","newRow","originalOrder","rewrite","newOrder","createOrderMapping","overrideHierarchy","hierarchy","rewrittenHierarchy","newLevels","newLevel","levelSources","ensureRewritten","h","r","firstRoleMappingWithMatrix","find","matrixMapping","columnLevels","newToOldPositions_1","createMatrixValuesPositionMapping","keys_1","numKeys_1","reorderChildNodes","forEachNodeAtLevel","newValues","iterations","keysIndex","reorderMatrixCompositeGroups","numKeys","childrenClone","supportedDataViewMapping","projection","transformedRowsHierarchy_1","reorderMatrixHierarchyCompositeGroups","transformedColumnsHierarchy_1","matrixHierarchy","hierarchyRole","transformedHierarchy","selectIndicesInProjectionOrder","hasMultipleColumnsInProjection","hierarchyLevel","newToOldLevelSourceIndicesMapping","createMatrixHierarchyLevelSourcesPositionMapping","inheritMatrixNodeHierarchy","transformingHierarchyLevel","reorderMatrixHierarchyLevelColumnSources","reorderMatrixHierarchyLevelValues","levelSourceColumns","columnsForHierarchyRoleOrderedByLevelSourceIndex","DataViewMetadataColumnUtils","joinMetadataColumnsAndProjectionOrder","columnsForHierarchyRoleOrderedByProjection","sortBy","columnInfo","projectionOrderIndex","sourceIndex","originalLevelSources","newLevelSourceIndices","newLevelSourceIndex","oldLevelSourceIndex","transformingHierarchyRootNode","transformingHierarchyLevelIndex","oldToNewLevelSourceIndicesMapping","createReversedMapping","transformingMatrixNode","originalLevelValues","newlyOrderedLevelValues","levelValue","transformingLevelValue","newlyOrderedLastLevelValue","newPosition","reversed","keyAsNumber","parseInt","targetLevel","columnRewrite","dataObjects","evaluateMetadataObjects","metadataObject","colorAllocatorCache","populateColorAllocatorCache","evaluateMetadataRepetition","dataObject","evaluateDataRepetition","rules","evaluateUserDefinedObjects","dataViewObjects","objectDefns_1","createStaticEvalContext","objectDesc","propertyDesc","ruleDesc","createRuleEvaluationInstance","ruleType","ruleOutput","output","selectorToCreate","findSelectorForRuleInput","createRuleEvaluationInstanceFillRule","tryCreateColorAllocatorForFillRule","inputRole","ColorRuleEvaluation","fillRuleProperties","identifier","identifierKind","createColorAllocatorLinearGradient2","createColorAllocatorLinearGradient3","propertyValueFillRule","inputRange","findRuleInputColumnNumberRange","splitScales","midValue","cache","createColorAllocatorCache","staticEvalContext","objectDefnProperties","fillProperty","kind","fillRuleExpr","inputExprQueryName","findFirstQueryNameForExpr","fillRulePropertyDescriptor","register","evaluateDataRepetitionCategoricalCategory","evaluateDataRepetitionCategoricalValueGrouping","rewrittenMatrix","evaluateDataRepetitionMatrix","dataViewTable","rewrittenSelector","rewriteTableRoleSelector","rewrittenTable","evaluateDataRepetitionTable","findSelectorForRoleWildcard","resultingSelector","dataSelector","selectorRoles","allColumnsBelongToSelectorRole","allColumnsBelongToRole","fromExprs","isUniqueDataSelector","dataSelectors","newSelector","columns_6","selectorRole","findSelectedCategoricalColumn","foundMatch","createCategoricalEvalContext","setCurrentRowIndex","dataViewCategoricalValues","selectorMetadata","valueSource","valueSourceOverwrite","setGrouped","createMatrixEvalContext","rewrittenRows","evaluateDataRepetitionMatrixHierarchy","rewrittenCols","dataViewMatrixHierarchy","rewrittenRoot","evaluateDataRepetitionMatrixNode","dataViewNode","childNodes","rewrittenNode","shouldSearchChildren","childNode","rewrittenChildNode","inheritNodeAndChildren","getPrototypeOf","createTableEvalContext","evaluateDataRepetitionTableRows","findIndex","col","inheritedRows","colLen","rowLen","inheritedRow","objectsForColumns","metadataId","categoricalColumn","selectedMetadataId","isSelectRef","expressionName","columnExpr","valueColRoles","aggregates","minLocal","maxLocal","valueIdentityFields","groupedResult","groupValues","currentGroup","determineCategoricalTransformation","some","vg","roleMappingCategorical","hasRolesGrouped","categoriesMapping","hasCategoryRole","hasRolesBind","hasRolesFor","rowLevels","rowRoles","roleMappingMatrix","createDisplayNameGetter","displayNameKey","resourceProvider","getDisplayName","displayNameGetter","fieldExpr","sqExpr","FieldExprPattern","visit","FieldExprToSQExprVisitor","fromColumnAggr","columnAggr","aggregate","fromColumn","columnRef","fromEntity","entityPattern","entity","entityVar","fromEntityAggr","entityAggr","fromHierarchyLevelAggr","hierarchyLevelAggr","fromHierarchyLevel","hierarchyLevelPattern","fromHierarchy","hierarchyPattern","visitColumn","visitColumnAggr","visitColumnHierarchyLevelVariation","columnHierarchyLevelVariationPattern","propertyVariationSource","visitEntityAggr","visitHierarchyLevelAggr","visitMeasure","measure","measureRef","percentile","exclusive","visitPercentOfGrandTotal","percentOfGrandTotal","baseSQExpr","baseExpr","arithmetic","scopedEval","selectRef","SQExprConverter","asFieldPattern","FieldExprPatternBuilder","sourceRef","SourceExprPatternBuilder","ref","entityRef","variable","fieldPattern","argAggr","func","sourcePattern","hierarchyRef","hierarchySourceExprPattern","HierarchyExprPatternBuiler","variation","columnHierarchyLevelVariation","variationName","percentOfGrandTotalPattern","entityExpr","SQEntityExpr","variationRef","exprPattern","fieldExprPattern","toColumnRefSQExpr","columnPattern","getAggregate","FieldExprPatternAggregateVisitor","isAggregation","FieldExprPatternIsAggregationVisitor","hasFieldExprName","getPropertyName","FieldExprPropertyNameVisitor","getHierarchyName","getColumnRef","getFieldExprName","toFieldExprEntityPattern","getSchema","toFieldExprEntityItemPattern","FieldExprToEntityExprPatternBuilder","SQExprInfo","toEntityItemExprPattern","pattern","validateAndReshape","dataViewMappings_3","supports","reshapeCategorical","reshapeTree","reshapeSingle","reshapeTable","ScriptResultUtil","findScriptResult","categoryRoleMapping","supported","updated","maxRowCount","originalLength","updatedCategories","updatedColumn","supportsCategorical","singleRoleMapping","treeRoleMapping","validateRange","countGroups","depth","tableRoleMapping","countMeasures","usePreferredDataViewSchema","scriptResult","supportsScriptResult","supportsTree","supportsSingle","supportsTable","preferred","dataViewSingle","scriptResultRoleMapping","imageBase64","roleCondition","ignoreMin","DataViewMappingMatchErrorCode","conditionRangeTooSmall","conditionRangeTooLarge","validateKind","roleKindByQueryRef","expectedKind","roleCollection","roleProjections_1","Measure","conditionKindExpectedMeasure","conditionKindExpectedGrouping","GroupingOrMeasure","conditionKindExpectedGroupingOrMeasure","mappings","errors","mappingIndex","mappingCount","mappingConditions","requiredProperties","allPropertiesValid","areAllPropertiesValid","conditionsMet","conditionIndex","conditionCount","currentConditionErrors","checkForConditionErrors","currentConditionErrors_1","error","supportedMapping","updatedConditions","emptyToNull","mappingErrors","conditionRoles","isDrillable","roleCount","getPropertyCount","rangeError","code","kindError","requiredProperty","objectDescriptorValue","objectDescriptorProperty","objectDefinitionValue","useActiveIfAvailable","projectionsForRole","hasSameCategoryIdentity","dataView1","dataView2","dv1Categories","dv2Categories","dv1Identity","dv2Identity","dv1Length","getLengthOptional","areMetadataColumnsEquivalent","column1","column2","isMetadataEquivalent","metadata1","metadata2","previousColumnsLength","newColumnsLength","Lazy","fromRoles","DataViewRoleWildcardImpl","firstRoleWildcard","secondRoleWildcard","role1","role2","_this","_roles","_key","ignoreCase","filterFromIdentity","identities_1","orExprs","resultExpr","orExprs_1","orExpr","inExpr","getInExpr","or","not","fromSQExpr","createDataViewScopeIdentity","DataViewScopeIdentityImpl","_expr","SQExprShortSerializer","serialize","wildcard","instanceExprs","firstScopeWildcard","secondScopeWildcard","DataViewScopeWildcardImpl","_exprs","serializeArray","ColorAllocatorProvider","entry","allocator","applicableDataViewMappings","regressionDataViewMapping","usage","regression","regressionDataViews","visualDataViews_1","visualDataView","regressionDataView","linearRegressionTransform","sourceDataView","xColumns","getColumnsForCartesianRoleKind","yColumns","xColumnSource","yColumnSource","combineSeries","regressionUsage","combineSeriesPropertyId","dataPointsBySeries","getDataPointsBySeries","lineDefSet","calculateLineDefinitions","highlightsLineDefSet","xMin","xMax","shouldComputeHightlights","hasHighlightValues","highlightDataPointsBySeries","valuesByTrend","lineDefs","trend","computeLineYValues","highlightsByTrend","createRegressionDataView","dataPointsBySeries_1","dataPointSet","unsortedXValues","xValues","unsortedYValues","yValues","xDataType","getDataType","yDataType","sortedDataPointSet","sortValues","minCategoryValue","maxCategoryValue","lineDef","computeRegressionLine","roleKind","getColumnsWithRoleKind","_loop_1","cartesianKind","state_1","firstNonNull","dataType","zippedValues","zip","valuePair","unzip","xBar","sum","yBar","ssXX","pow","ssXY","slope","intercept","x1","x2","getValuesFromColumn","preferHighlights","xValueArray","seriesYValues","multipleXValueColumns","yRole","seriesRole","xRole","categoricalRoles","seriesRoles","valuesBySeries","withCategory","regressionXQueryName","regressionSeriesQueryName","regressionYQueryName","selects_1","qp","activeItem","colorAllocatorProvider","CategoricalEvalContext","findRuleInputColumn","findRuleInputInColumns","columns_7","columnsByRole","getRoleValue","TableEvalContext","getExprValueFromTable","forEachLeafNode","rootNodes","isNodeArray","rootNodes_1","rootNode","forEachLeafNodeRecursive","nodeOrNodeArray","isArrayOrInheritedArray","matrixNode","nextIndex","treePath","children_1","nextChild","pop","deepestLevelToInherit","useInheritSingle","returnNode","isRootNode","shouldInheritCurrentNode","inheritFunc","shouldInheritChildNodes","matrixOrHierarchy","hasCompositeGroup","isMatrix","hierarchyLevels","hierarchyLevels_1","isMeasureHeadersLevel","isForRole","metadataColumn","targetRole","columnSources","jointResult","projectionOrderSelectIndices","selectIndexToProjectionIndexMap","selectIndex","jointColumnInfo","ConceptualSchema","entityName","entities","withName","findHierarchy","hierarchies","findHierarchyByVariation","variationEntityName","variationColumnName","hierarchyName","variationEntity","variationProperty","variationColumn","variations","targetEntity","navigationProperty","findPropertyWithKpi","kpiProperty","prop","status","goal","ConceptualDataCategory","extractScriptResult","script","provider","extractScriptResultFromVisualConfig","scriptSource","getScriptInput","scriptInput","VariableName","Columns","scriptInputColumnNames","scriptInputColumns","scriptInputColumn","QueryName","Name","ScriptInputColumnNameVisitor","ensureUniqueNames","federatedSchema","getNameForProperty","getVariationLevelName","getNameForHierarchy","federatedScheam","variations_1","defaultHierarchy","segmentation","DataViewMerger","mergeDataViews","segment","mergeTables","mergeCategorical","mergeTreeNodes","mergeIndex","lastMergeIndex","merge","segmentCategoriesLength","segmentCategory","sourceCategory","segmentValuesLength","segmentValue","sourceValue","sourceRoot","segmentRoot","allowDifferentStructure","firstAppendIndex","findFirstAppendIndex","lastSourceChild","mergedChildren","childSegment","isMerge","SQExprRewriter","origArg","rewrittenArg","SQColumnRefExpr","SQMeasureRefExpr","SQAggregationExpr","SQPercentileExpr","SQHierarchyExpr","SQHierarchyLevelExpr","SQPropertyVariationSourceExpr","orig","origLeft","rewrittenLeft","origRight","rewrittenRight","SQAndExpr","origLower","rewrittenLower","origUpper","rewrittenUpper","SQBetweenExpr","rewrittenValues","origArgs","rewrittenArgs","rewriteAll","origValues","origValueTuple","rewrittenValueTuple","SQInExpr","origExprs","rewrittenResult","origExpr","rewrittenExpr","SQOrExpr","SQCompareExpr","comparison","SQContainsExpr","SQExistsExpr","SQNotExpr","SQStartsWithExpr","SQDateSpanExpr","SQDateAddExpr","amount","SQArithmeticExpr","operator","origExpression","rewrittenExpression","origScope","rewrittenScope","SQScopedEvalExpr","origInput","rewrittenInput","origRule","origGradient2","rewrittenGradient2","origGradient3","rewrittenGradient3","rewrittenRule","SQFillRuleExpr","origMin","rewrittenMin","origMax","rewrittenMax","origMid","rewrittenMid","origColor","rewrittenColor","origValue","rewrittenValue","rewrittenStop","EqualsToInRewriter","Rewriter","Equal","visitUnsupported","isSupported","leftIsComparand","isComparand","rightIsComparand","operand","current","InBuilder","complete","cancel","SQConstantExpr","cancelled","asScopeIdsContainer","fieldSQExprs","filterItems","filterItem","FilterScopeIdsCollectorVisitor","getResult","getFirstComparandValue","comparandExpr","FindComparandVisitor","isRoot","keyExprsCount","valueExprs","fieldExprs","fieldSQExprs_1","field","removeEntityVariables","scopeIds","startIndex","endIndex","scopeId","getScopeIdentity","isInArray","compoundSQExpr","equalsExpr","equal","unsupportedSQExpr","values_1","valueTuple_1","fixedExpr","extractor","ScopeIdExtractorImpl","malformed","keyValues","PrimitiveValueEncoding","decimal","double","getTimezoneOffset","dateTimeString","toISOString","endsWith","substr","replace","SingleQuoteRegex","nullEncoding","boolean","createSQAggregationOperations","datetimeMinMaxSupported","SQAggregationOperations","getMetadataForUnderlyingType","removeAggregate","getMetadata","Agg","getSupportedAggregates","targetTypes","fieldKind","isPropertyIdentity","idOnEntityKey","aggregates_1","Sum","Avg","Min","Max","CountNonNull","StandardDeviation","Variance","fieldExprItem","currentSchema","capabilities","supportsMedian","Median","distinctCountAggExists","isSupportedAggregate","supportedAggregates","createExprWithAggregate","aggregateNonNumericFields","preferredAggregate","getDefaultAggregate","SQHierarchyExprUtils","getConceptualHierarchyLevelFromExpr","conceptualSchema","getConceptualHierarchyLevel","schemaName","conceptualHierarchy","getConceptualHierarchy","variationExpr","sourceEntityExpr","expandExpr","suppressHierarchyLevelExpansion","SQExprHierarchyToHierarchyLevelConverter","convert","SQExprVariationConverter","expand","SQExprHierarchyLevelConverter","isHierarchyOrVariation","conceptualProperty","getConceptualProperty","getSourceVariationExpr","hierarchyLevelExpr","getSourceHierarchy","getHierarchySourceAsVariationSource","areHierarchyLevelsOrdered","allLevels","firstExpr","secondExpr","firstLevel","secondLevel","firstIndex","indexOfExpr","secondIndex","getInsertionIndex","orderedSubsetOfLevels","insertIndex","hierarchyExpr","hierarchyLevels_2","SQExprGroupUtils","groupExprs","addChildToGroup","selectQueryIndex","shouldAddExpressionToNewGroup","exprSource","lastGroup","expandedExpr","allHierarchyLevels","defaultAggregateForDataType","defaultAggregateToQueryAggregateFunction","_kind","SQExprEqualityVisitor","validate","aggrUtils","validator","SQExprValidationVisitor","isArithmetic","isColumn","isConstant","isEntity","isHierarchy","isHierarchyLevel","isScopedEval","isWithRef","isResourcePackageItem","getMetadataForProperty","getMetadataForHierarchyLevel","getMetadataForVariation","getMetadataForPercentOfGrandTotal","getMetadataForEntity","forceAggregation","getHierarchyLevelConceptualProperty","propertyDefaultAggregate","defaultAggregate","getKeyColumns","columnRefExpr","SQExprColumnRefInfoVisitor","getColumnRefSQExpr","keySQExprs","getPropertyKeys","hasGroupOnKeys","keySqExpr","getTargetEntityForVariation","variations_2","getTargetEntity","SQEntityExprInfoVisitor","getEntityExpr","fieldExprHierachyLevel","fieldExprEntity","sourceProperty","getPropertyMetadata","columnAggregate","SQWithRefExpr","SQPropRefExpr","argMetadata","SQSelectRefExpr","valueEncoded","SQNowExpr","SQDefaultValueExpr","SQAnyValueExpr","SQResourcePackageItemExpr","packageName","packageType","itemName","withRef","between","inExpr_1","tryUseInExprs","leftArgLen","rightArgLen","combinedValues","compare","exists","startsWith","nullConstant","now","anyValue","dateAdd","dateSpan","Decimal","typedConstant","isBoolean","isString","setAggregate","FieldExprChangeAggregateRewriter","FieldExprRemoveAggregateRewriter","setPercentOfGrandTotal","SQExprSetPercentOfGrandTotalRewriter","removePercentOfGrandTotal","SQExprRemovePercentOfGrandTotalRewriter","SQExprRemoveEntityVariablesRewriter","resourcePackageItem","SQExprAggregateInfoVisitor","ignoreCaseInstance","comparand","equalsAll","compareValues","optionalEqual","equalIgnoreCase","leftRule","rightRule","leftLinearGradient2","rightLinearGradient2","leftLinearGradient3","rightLinearGradient3","left2","right2","equalsFillRuleStop","left3","right3","stop1","stop2","SQExprRootRewriter","values_2","validateCompatibleType","compareExpr","validateEntity","isQueryable","aggregateExpr","validateHierarchy","hierarchyLevelFieldExprItem","validateHierarchyLevel","validateOperandsAndTypeForStartOrContains","validateArithmeticTypes","scopeRef","supportsArithmetic","leftMetadata","leftType","rightMetadata","rightType","levelName","hierarchyLevelConceptualProperty","queryable","sourceExpr","targetEntityExpr","schemaHierarchy","hierarchyLevelRef","getEntity","SQExprChangeAggregateRewriter","rewriter","defaultRewrite","SQExprRemoveAggregateRewriter","searchElement","uniqueName","namedItems","exprDefaultName","findUniqueName","defaultName","fallback","SQExprDefaultNameGenerator","IsMeasureVisitor","isAnyValue","IsAnyValueVisitor","isDefaultValue","IsDefaultValueVisitor","discourageAggregation","getSchemaCapabilities","discourageQueryAggregateUsage","getAggregateBehavior","getConceptualColumn","aggregateBehavior","getKpiMetadata","kpiStatusProperty","getKpiStatusProperty","kpiValue","statusMetadata","kpiTrendProperty","getKpiTrendProperty","trendMetadata","getConceptualEntity","conceptualEntity","getDefaultValue","fieldSQExpr","sqField","hierarchyLevelField","getDefaultValues","fieldSQExprs_2","getDataViewScopeIdentityComparisonExpr","fieldsExpr","compareExprs","compareExprs_1","getActiveTablesNames","queryDefn","tables","selectedItems","entityObj","isRelatedToMany","targetExpr","isRelated","isRelatedToOne","sourceMultiplicity","targetMultiplicity","navigationProperties","target","queue","shift","navProperties","navProperties_1","navProperty","isActive","isRelatedOneToOne","sourceNavigations","targetNavigations","hasOneToOneNavigation","navigationProperties_1","concatUnique","leftExprs","rightExprs","concatExprs","rightExprs_1","SemanticQueryRewriter","exprRewriter","rewriteFrom","fromValue","fromContents","originalFrom","originalFromKeys","keyName","originalEntityRef","originalEntityExpr","updatedEntityExpr","SQFrom","rewriteSelect","selectItems","rewriteNamedSQExpressions","rewriteGroupBy","groupByitems","expressions","SQExprRewriterWithSourceRenames","rewriteOrderBy","orderByItems","orderBy","updatedExpr","direction","rewriteWhere","whereItems","where","originalWhere","updatedWhere","SemanticQuery","groupBy","groupByItems","empty","createWithTrimmedFrom","unreferencedKeyFinder","UnreferencedKeyFinder","filterTarget","unreferencedKeys","remove","getSelect","setSelect","createNamedExpressionArray","extendWithName","rewriteExpressionsWithSourceRenames","removeSelect","originalItems","originalExpr","removeOrderBy","sorts","selectNameOf","setSelectAt","originalName","addSelect","exprName","createNamedExpr","currentNames","getGroupBy","setGroupBy","addGroupBy","getOrderBy","setOrderBy","clause","updatedOrderBy","getWhere","setWhere","updatedFilter","updatedTarget","addWhere","incomingWhere","updatedClause","contract","rewrittenContract","getDefaultValueFilter","getDataViewScopeIdentityComparisonFilters","getAnyValueFilter","filters","firstFilter","applyFilter","isDefaultFilter","isAnyFilter","leftFilter","rightFilter","filterWhereItems","filterWhereItem","updatedWhereItem","ensureEntity","desiredVariableName","i_1","candidateName","new","idx","substring","toLowerCase","extend","renames","updatedName","rewriteFilter","updatedTargets","rewriteArray","updatedCondition","updatedExprs","QuerySourceRenameDetector","detector","existingEntity","actualEntity","CategoricalDataViewBuilder","pushIfNotExists","itemToAdd","applySeriesData","staticMeasureColumns","dynamicMeasureColumns","withValues","columns_8","staticSeriesValues","dynamicSeriesMetadata","valueColumns_1","dynamicSeriesValues","fillData","dataViewValues","first","seriesMeasures","measureIndex","measuresLen","hasStaticSeries","staticColumnsStartingIndex","metadataColumns","categoryMetadata","categoryMetadata_1","seriesValues","seriesValue","seriesIdentity","dynamicSeriesGroups_1","appendStaticMeasureColumns","isLegalDataView","isVisualDataView","StaticEvalContext","cols","findSelectIndex","findAggregateValue","aggregateValue","findAggregates","getOptional","value1","powerbi_1","FormattingEncoder","RegExpExtensions","preserveEscaped","specialChars","oldText","newText","String","fromCharCode","replaceAll","restoreEscaped","preserveLiterals","literals","fromIndex","toIndex","literal","token","restoreLiterals","DateTimeFormat","IndexedTokensRegex","ZeroPlaceholder","DigitPlaceholder","ExponentialFormatChar","NumericPlaceholders","NumericPlaceholderRegex","RegExp","join","FormattingService","culture","gculture","getCulture","canFormat","formatWithIndexedTokens","match","argToken","parts","argIndex","argFormat","nonScientificOverrideFormat","formatWithCustomOverride","_dateTimeScaleFormatInfo","initialize","setCurrentCulture","cultureSelector","_currentCultureSelector","_currentCulture","DateTimeScaleFormatInfo","Globalize","findClosestCulture","cultureName","getCurrentCulture","calendarName","getUrlParam","calendars","calendar","urlParam","common","cultureInfo","navigator","userLanguage","param","location","search","isStandard","formatDateStandard","formatDateCustom","patterns","ensurePatterns","findDateFormat","processCustomDateTimeFormat","localize","_currentCachedFormat","_currentCachedProcessedFormat","fixDateTimeFormat","dictionary","timeSeparator","char","charAt","getNonScientificFormatWithPrecision","baseFormat","newFormat","hasFormatComponents","getComponents","positive","negative","zero","getNumericFormatFromComponent","NumericFormatRegex","formats","addDecimalsToFormatComponent","NumberFormatComponentsDelimeter","placeholder","decimalPlaceholders","repeat","DecimalFormatRegex","beforeDecimal","formatDecimal","afterDecimal","decimalChange","DecimalFormatCharacter","LastNumericPlaceholderRegex","signFormat","hasNegative","signSpecificFormats","formatCount","StandardFormatRegex","formatNumberStandard","formatNumberCustom","numberFormatInfo","numberFormat","formatChar","mantissaDecimalDigits","toFixed","toPrecision","toExponential","actualPrecision","isNegative","paddingZerosCount","paddingZeros","isFinite","formatComponents","formatMeta","hasEscapes","hasQuotes","hasE","scientificMatch","ScientificFormatRegex","formatM","formatE","getCustomFormatPrecision","scale","getCustomFormatScale","indexOfE","mantissa","resultM","fuseNumberWithCustomFormat","resultE","valueFormatted","isValueGlobalized","parseFloat","toNonScientific","_lastCustomFormatMeta","precisionZeros","digitsBeforeDecimalPoint","maxPrecision","indexOfDot","powerZeros","calculatePrecision","calculateScale","hasCommas","hasDots","hasPercent","hasPermile","length_1","dotIndex","suppressModifyValue","formatParts","wholeFormat","fractionFormat","NumericalPlaceHolderRegex","globalizedDecimalSeparator","decimalSeparator","valueParts","wholeValue","fractionValue","TrailingZerosRegex","wholeFormattedValue","fuseNumberWithCustomFormatLeft","fractionFormattedValue","fuseNumberWithCustomFormatRight","fmtOnly","groupSymbolIndex","enableGroups","groupDigitCount","groupSizes","groupSize","groupSeparator","sign","firstChar","isZero","leftBuffer","vi","fi","fCount","vCount","lastChar","plus","minus","dot","comma","monthAbbreviations","cultureHasMonthAbbr","yearMonthPattern","monthDayPattern","fullPattern","longTimePattern","shortTimePattern","separator","hasYearSymbol","YearPattern","yearPos","monthPos","MonthPattern","DayPattern","minutePos","pmPos","shortHourPattern","HourPattern","MinutePattern","SecondPattern","MillisecondPattern","SQExprSerializer","str","agg","f","n","comp","const","o","SelectionId","highlight","keyWithoutHighlight","includes","ignoreHighlight","thisSelector","otherSelector","thisData","otherData","thisValue","otherValue","getKeyWithoutHighlight","hasIdentity","getSelector","getSelectorsByColumn","selectorsByColumn","createNull","createWithId","createWithMeasure","measureId","selectionId","createWithIdAndMeasure","createWithIdAndMeasureAndCategory","dataMap","createWithIds","id1","id2","idArray","createWithIdsAndMeasure","createWithSelectorForColumnAndMeasure","createWithHighlight","newId","data_4","SelectionIdBuilder","builder","ensureDataMap","withSeries","withMeasure","createSelectionId"],"mappings":"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","file":"VisualsData.min.js","sourcesContent":["var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n///<reference path=\"../../Typedefs/jquery/jquery.d.ts\"/>\n///<reference path=\"../../Typedefs/globalize/globalize.d.ts\"/>\n///<reference path=\"../../Typedefs/lodash/lodash.d.ts\"/>\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\n        var DefaultSQExprVisitorWithArg = (function () {\n            function DefaultSQExprVisitorWithArg() {\n            }\n            DefaultSQExprVisitorWithArg.prototype.visitEntity = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAggr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPercentile = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchy = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchyLevel = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPropertyVariationSource = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitSelectRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitBetween = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitIn = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitOr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitCompare = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitContains = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitExists = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNot = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitConstant = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNow = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefaultValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnyValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitArithmetic = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitFillRule = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitResourcePackageItem = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitScopedEval = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitWithRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefault = function (expr, arg) {\n                return;\n            };\n            return DefaultSQExprVisitorWithArg;\n        }());\n        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;\n        /** Default ISQExprVisitor implementation that others may derive from. */\n        var DefaultSQExprVisitor = (function (_super) {\n            __extends(DefaultSQExprVisitor, _super);\n            function DefaultSQExprVisitor() {\n                _super.apply(this, arguments);\n            }\n            return DefaultSQExprVisitor;\n        }(DefaultSQExprVisitorWithArg));\n        data.DefaultSQExprVisitor = DefaultSQExprVisitor;\n        /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\n        var DefaultSQExprVisitorWithTraversal = (function () {\n            function DefaultSQExprVisitorWithTraversal() {\n            }\n            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPercentile = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchy = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchyLevel = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPropertyVariationSource = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitSelectRef = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function (expr) {\n                expr.arg.accept(this);\n                expr.lower.accept(this);\n                expr.upper.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function (expr) {\n                var args = expr.args;\n                for (var i = 0, len = args.length; i < len; i++)\n                    args[i].accept(this);\n                var values = expr.values;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueTuple = values[i];\n                    for (var j = 0, jlen = valueTuple.length; j < jlen; j++)\n                        valueTuple[j].accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefaultValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnyValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitArithmetic = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRule = function (expr) {\n                expr.input.accept(this);\n                var rule = expr.rule, gradient2 = rule.linearGradient2, gradient3 = rule.linearGradient3;\n                if (gradient2) {\n                    this.visitLinearGradient2(gradient2);\n                }\n                if (gradient3) {\n                    this.visitLinearGradient3(gradient3);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient2 = function (gradient2) {\n                debug.assertValue(gradient2, 'gradient2');\n                this.visitFillRuleStop(gradient2.min);\n                this.visitFillRuleStop(gradient2.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient3 = function (gradient3) {\n                debug.assertValue(gradient3, 'gradient3');\n                this.visitFillRuleStop(gradient3.min);\n                this.visitFillRuleStop(gradient3.mid);\n                this.visitFillRuleStop(gradient3.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitResourcePackageItem = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitScopedEval = function (expr) {\n                expr.expression.accept(this);\n                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {\n                    var scopeExpr = _a[_i];\n                    scopeExpr.accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitWithRef = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function (expr) {\n                return;\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                stop.color.accept(this);\n                var value = stop.value;\n                if (value)\n                    value.accept(this);\n            };\n            return DefaultSQExprVisitorWithTraversal;\n        }());\n        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    function createEnumType(members) {\n        return new EnumType(members);\n    }\n    powerbi.createEnumType = createEnumType;\n    var EnumType = (function () {\n        function EnumType(allMembers) {\n            debug.assertValue(allMembers, 'allMembers');\n            this.allMembers = allMembers;\n        }\n        EnumType.prototype.members = function (validMembers) {\n            var allMembers = this.allMembers;\n            if (!validMembers)\n                return allMembers;\n            var membersToReturn = [];\n            for (var _i = 0, allMembers_1 = allMembers; _i < allMembers_1.length; _i++) {\n                var member = allMembers_1[_i];\n                if (_.contains(validMembers, member.value))\n                    membersToReturn.push(member);\n            }\n            return membersToReturn;\n        };\n        return EnumType;\n    }());\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var FillSolidColorTypeDescriptor;\n    (function (FillSolidColorTypeDescriptor) {\n        /** Gets a value indicating whether the descriptor is nullable or not. */\n        function nullable(descriptor) {\n            debug.assertValue(descriptor, 'descriptor');\n            if (descriptor === true)\n                return false;\n            var advancedDescriptor = descriptor;\n            return !!advancedDescriptor.nullable;\n        }\n        FillSolidColorTypeDescriptor.nullable = nullable;\n    })(FillSolidColorTypeDescriptor = powerbi.FillSolidColorTypeDescriptor || (powerbi.FillSolidColorTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var ImageDefinition;\n    (function (ImageDefinition) {\n        ImageDefinition.urlType = { misc: { imageUrl: true } };\n    })(ImageDefinition = powerbi.ImageDefinition || (powerbi.ImageDefinition = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StructuralTypeDescriptor;\n    (function (StructuralTypeDescriptor) {\n        function isValid(type) {\n            debug.assertValue(type, 'type');\n            if (type.fill ||\n                type.fillRule ||\n                type.filter ||\n                type.expression ||\n                type.image ||\n                type.paragraphs) {\n                return true;\n            }\n            return false;\n        }\n        StructuralTypeDescriptor.isValid = isValid;\n    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var EnumExtensions = jsCommon.EnumExtensions;\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\n    var ValueType = (function () {\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\n        function ValueType(type, category, enumType) {\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\n            debug.assert(!!category || category === null, 'category');\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\n            this.underlyingType = type;\n            this.category = category;\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\n                this.temporalType = new TemporalType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\n                this.geographyType = new GeographyType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\n                this.miscType = new MiscellaneousType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\n                this.formattingType = new FormattingType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\n                this.enumType = enumType;\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\n                this.scriptingType = new ScriptType(type);\n            }\n        }\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\n        ValueType.fromDescriptor = function (descriptor) {\n            descriptor = descriptor || {};\n            // Simplified primitive types\n            if (descriptor.text)\n                return ValueType.fromExtendedType(ExtendedType.Text);\n            if (descriptor.integer)\n                return ValueType.fromExtendedType(ExtendedType.Integer);\n            if (descriptor.numeric)\n                return ValueType.fromExtendedType(ExtendedType.Double);\n            if (descriptor.bool)\n                return ValueType.fromExtendedType(ExtendedType.Boolean);\n            if (descriptor.dateTime)\n                return ValueType.fromExtendedType(ExtendedType.DateTime);\n            if (descriptor.duration)\n                return ValueType.fromExtendedType(ExtendedType.Duration);\n            if (descriptor.binary)\n                return ValueType.fromExtendedType(ExtendedType.Binary);\n            if (descriptor.none)\n                return ValueType.fromExtendedType(ExtendedType.None);\n            // Extended types\n            if (descriptor.scripting) {\n                if (descriptor.scripting.source)\n                    return ValueType.fromExtendedType(ExtendedType.ScriptSource);\n            }\n            if (descriptor.enumeration)\n                return ValueType.fromEnum(descriptor.enumeration);\n            if (descriptor.temporal) {\n                if (descriptor.temporal.year)\n                    return ValueType.fromExtendedType(ExtendedType.Year_Integer);\n                if (descriptor.temporal.month)\n                    return ValueType.fromExtendedType(ExtendedType.Month_Integer);\n            }\n            if (descriptor.geography) {\n                if (descriptor.geography.address)\n                    return ValueType.fromExtendedType(ExtendedType.Address);\n                if (descriptor.geography.city)\n                    return ValueType.fromExtendedType(ExtendedType.City);\n                if (descriptor.geography.continent)\n                    return ValueType.fromExtendedType(ExtendedType.Continent);\n                if (descriptor.geography.country)\n                    return ValueType.fromExtendedType(ExtendedType.Country);\n                if (descriptor.geography.county)\n                    return ValueType.fromExtendedType(ExtendedType.County);\n                if (descriptor.geography.region)\n                    return ValueType.fromExtendedType(ExtendedType.Region);\n                if (descriptor.geography.postalCode)\n                    return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\n                if (descriptor.geography.stateOrProvince)\n                    return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\n                if (descriptor.geography.place)\n                    return ValueType.fromExtendedType(ExtendedType.Place);\n                if (descriptor.geography.latitude)\n                    return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\n                if (descriptor.geography.longitude)\n                    return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\n            }\n            if (descriptor.misc) {\n                if (descriptor.misc.image)\n                    return ValueType.fromExtendedType(ExtendedType.Image);\n                if (descriptor.misc.imageUrl)\n                    return ValueType.fromExtendedType(ExtendedType.ImageUrl);\n                if (descriptor.misc.webUrl)\n                    return ValueType.fromExtendedType(ExtendedType.WebUrl);\n                if (descriptor.misc.barcode)\n                    return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\n            }\n            if (descriptor.formatting) {\n                if (descriptor.formatting.color)\n                    return ValueType.fromExtendedType(ExtendedType.Color);\n                if (descriptor.formatting.formatString)\n                    return ValueType.fromExtendedType(ExtendedType.FormatString);\n                if (descriptor.formatting.alignment)\n                    return ValueType.fromExtendedType(ExtendedType.Alignment);\n                if (descriptor.formatting.labelDisplayUnits)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\n                if (descriptor.formatting.fontSize)\n                    return ValueType.fromExtendedType(ExtendedType.FontSize);\n                if (descriptor.formatting.labelDensity)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDensity);\n            }\n            if (descriptor.extendedType) {\n                return ValueType.fromExtendedType(descriptor.extendedType);\n            }\n            if (descriptor.operations) {\n                if (descriptor.operations.searchEnabled)\n                    return ValueType.fromExtendedType(ExtendedType.SearchEnabled);\n            }\n            return ValueType.fromExtendedType(ExtendedType.Null);\n        };\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\n        ValueType.fromExtendedType = function (extendedType) {\n            extendedType = extendedType || ExtendedType.Null;\n            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);\n            debug.assert(primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null, 'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\n        };\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\n        ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {\n            primitiveType = primitiveType || PrimitiveType.Null;\n            category = category || null;\n            var id = primitiveType.toString();\n            if (category)\n                id += '|' + category;\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\n        };\n        /** Creates a ValueType to describe the given IEnumType. */\n        ValueType.fromEnum = function (enumType) {\n            debug.assertValue(enumType, 'enumType');\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\n        };\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\n        ValueType.isCompatibleTo = function (type, otherTypes) {\n            debug.assertValue(type, 'type');\n            debug.assertValue(otherTypes, 'otherTypes');\n            var valueType = ValueType.fromDescriptor(type);\n            for (var _i = 0, otherTypes_1 = otherTypes; _i < otherTypes_1.length; _i++) {\n                var otherType = otherTypes_1[_i];\n                var otherValueType = ValueType.fromDescriptor(otherType);\n                if (otherValueType.isCompatibleFrom(valueType))\n                    return true;\n            }\n            return false;\n        };\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\n        ValueType.prototype.isCompatibleFrom = function (other) {\n            debug.assertValue(other, 'other');\n            var otherPrimitiveType = other.primitiveType;\n            if (this === other ||\n                this.primitiveType === otherPrimitiveType ||\n                otherPrimitiveType === PrimitiveType.Null)\n                return true;\n            return false;\n        };\n        /**\n         * Determines if the instance ValueType is equal to the 'other' ValueType\n         * @param {ValueType} other the other ValueType to check equality against\n         * @returns True if the instance ValueType is equal to the 'other' ValueType\n         */\n        ValueType.prototype.equals = function (other) {\n            return _.isEqual(this, other);\n        };\n        Object.defineProperty(ValueType.prototype, \"primitiveType\", {\n            /** Gets the exact primitive type of this ValueType. */\n            get: function () {\n                return getPrimitiveType(this.underlyingType);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"extendedType\", {\n            /** Gets the exact extended type of this ValueType. */\n            get: function () {\n                return this.underlyingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"categoryString\", {\n            /** Gets the data category string (if any) for this ValueType. */\n            get: function () {\n                return this.category;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"text\", {\n            // Simplified primitive types\n            /** Indicates whether the type represents text values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Text;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"numeric\", {\n            /** Indicates whether the type represents any numeric value. */\n            get: function () {\n                return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"integer\", {\n            /** Indicates whether the type represents integer numeric values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Integer;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"bool\", {\n            /** Indicates whether the type represents Boolean values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Boolean;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"dateTime\", {\n            /** Indicates whether the type represents any date/time values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.DateTime ||\n                    this.primitiveType === PrimitiveType.Date ||\n                    this.primitiveType === PrimitiveType.Time;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"duration\", {\n            /** Indicates whether the type represents duration values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Duration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"binary\", {\n            /** Indicates whether the type represents binary values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Binary;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"none\", {\n            /** Indicates whether the type represents none values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.None;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"temporal\", {\n            // Extended types\n            /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\n            get: function () {\n                return this.temporalType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"geography\", {\n            /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\n            get: function () {\n                return this.geographyType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"misc\", {\n            /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\n            get: function () {\n                return this.miscType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"formatting\", {\n            /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\n            get: function () {\n                return this.formattingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"enum\", {\n            /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\n            get: function () {\n                return this.enumType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"scripting\", {\n            get: function () {\n                return this.scriptingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ValueType.typeCache = {};\n        return ValueType;\n    }());\n    powerbi.ValueType = ValueType;\n    var ScriptType = (function () {\n        function ScriptType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(ScriptType.prototype, \"source\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return ScriptType;\n    }());\n    powerbi.ScriptType = ScriptType;\n    var TemporalType = (function () {\n        function TemporalType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(TemporalType.prototype, \"year\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TemporalType.prototype, \"month\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return TemporalType;\n    }());\n    powerbi.TemporalType = TemporalType;\n    var GeographyType = (function () {\n        function GeographyType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(GeographyType.prototype, \"address\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"city\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"continent\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"country\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"county\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"region\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"postalCode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"stateOrProvince\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"place\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"latitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"longitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return GeographyType;\n    }());\n    powerbi.GeographyType = GeographyType;\n    var MiscellaneousType = (function () {\n        function MiscellaneousType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(MiscellaneousType.prototype, \"image\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"imageUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"webUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"barcode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return MiscellaneousType;\n    }());\n    powerbi.MiscellaneousType = MiscellaneousType;\n    var FormattingType = (function () {\n        function FormattingType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(FormattingType.prototype, \"color\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"formatString\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"alignment\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDisplayUnits\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"fontSize\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDensity\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return FormattingType;\n    }());\n    powerbi.FormattingType = FormattingType;\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\n    (function (PrimitiveType) {\n        PrimitiveType[PrimitiveType[\"Null\"] = 0] = \"Null\";\n        PrimitiveType[PrimitiveType[\"Text\"] = 1] = \"Text\";\n        PrimitiveType[PrimitiveType[\"Decimal\"] = 2] = \"Decimal\";\n        PrimitiveType[PrimitiveType[\"Double\"] = 3] = \"Double\";\n        PrimitiveType[PrimitiveType[\"Integer\"] = 4] = \"Integer\";\n        PrimitiveType[PrimitiveType[\"Boolean\"] = 5] = \"Boolean\";\n        PrimitiveType[PrimitiveType[\"Date\"] = 6] = \"Date\";\n        PrimitiveType[PrimitiveType[\"DateTime\"] = 7] = \"DateTime\";\n        PrimitiveType[PrimitiveType[\"DateTimeZone\"] = 8] = \"DateTimeZone\";\n        PrimitiveType[PrimitiveType[\"Time\"] = 9] = \"Time\";\n        PrimitiveType[PrimitiveType[\"Duration\"] = 10] = \"Duration\";\n        PrimitiveType[PrimitiveType[\"Binary\"] = 11] = \"Binary\";\n        PrimitiveType[PrimitiveType[\"None\"] = 12] = \"None\";\n    })(powerbi.PrimitiveType || (powerbi.PrimitiveType = {}));\n    var PrimitiveType = powerbi.PrimitiveType;\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\n    (function (ExtendedType) {\n        // Flags (1 << 8-15 range [0xFF00])\n        // Important: Enum members must be declared before they are used in TypeScript.\n        ExtendedType[ExtendedType[\"Numeric\"] = 256] = \"Numeric\";\n        ExtendedType[ExtendedType[\"Temporal\"] = 512] = \"Temporal\";\n        ExtendedType[ExtendedType[\"Geography\"] = 1024] = \"Geography\";\n        ExtendedType[ExtendedType[\"Miscellaneous\"] = 2048] = \"Miscellaneous\";\n        ExtendedType[ExtendedType[\"Formatting\"] = 4096] = \"Formatting\";\n        ExtendedType[ExtendedType[\"Scripting\"] = 8192] = \"Scripting\";\n        // Primitive types (0-255 range [0xFF] | flags)\n        // The member names and base values must match those in PrimitiveType.\n        ExtendedType[ExtendedType[\"Null\"] = 0] = \"Null\";\n        ExtendedType[ExtendedType[\"Text\"] = 1] = \"Text\";\n        ExtendedType[ExtendedType[\"Decimal\"] = 258] = \"Decimal\";\n        ExtendedType[ExtendedType[\"Double\"] = 259] = \"Double\";\n        ExtendedType[ExtendedType[\"Integer\"] = 260] = \"Integer\";\n        ExtendedType[ExtendedType[\"Boolean\"] = 5] = \"Boolean\";\n        ExtendedType[ExtendedType[\"Date\"] = 518] = \"Date\";\n        ExtendedType[ExtendedType[\"DateTime\"] = 519] = \"DateTime\";\n        ExtendedType[ExtendedType[\"DateTimeZone\"] = 520] = \"DateTimeZone\";\n        ExtendedType[ExtendedType[\"Time\"] = 521] = \"Time\";\n        ExtendedType[ExtendedType[\"Duration\"] = 10] = \"Duration\";\n        ExtendedType[ExtendedType[\"Binary\"] = 11] = \"Binary\";\n        ExtendedType[ExtendedType[\"None\"] = 12] = \"None\";\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\n        // Temporal\n        ExtendedType[ExtendedType[\"Year\"] = 66048] = \"Year\";\n        ExtendedType[ExtendedType[\"Year_Text\"] = 66049] = \"Year_Text\";\n        ExtendedType[ExtendedType[\"Year_Integer\"] = 66308] = \"Year_Integer\";\n        ExtendedType[ExtendedType[\"Year_Date\"] = 66054] = \"Year_Date\";\n        ExtendedType[ExtendedType[\"Year_DateTime\"] = 66055] = \"Year_DateTime\";\n        ExtendedType[ExtendedType[\"Month\"] = 131584] = \"Month\";\n        ExtendedType[ExtendedType[\"Month_Text\"] = 131585] = \"Month_Text\";\n        ExtendedType[ExtendedType[\"Month_Integer\"] = 131844] = \"Month_Integer\";\n        ExtendedType[ExtendedType[\"Month_Date\"] = 131590] = \"Month_Date\";\n        ExtendedType[ExtendedType[\"Month_DateTime\"] = 131591] = \"Month_DateTime\";\n        // Geography\n        ExtendedType[ExtendedType[\"Address\"] = 6554625] = \"Address\";\n        ExtendedType[ExtendedType[\"City\"] = 6620161] = \"City\";\n        ExtendedType[ExtendedType[\"Continent\"] = 6685697] = \"Continent\";\n        ExtendedType[ExtendedType[\"Country\"] = 6751233] = \"Country\";\n        ExtendedType[ExtendedType[\"County\"] = 6816769] = \"County\";\n        ExtendedType[ExtendedType[\"Region\"] = 6882305] = \"Region\";\n        ExtendedType[ExtendedType[\"PostalCode\"] = 6947840] = \"PostalCode\";\n        ExtendedType[ExtendedType[\"PostalCode_Text\"] = 6947841] = \"PostalCode_Text\";\n        ExtendedType[ExtendedType[\"PostalCode_Integer\"] = 6948100] = \"PostalCode_Integer\";\n        ExtendedType[ExtendedType[\"StateOrProvince\"] = 7013377] = \"StateOrProvince\";\n        ExtendedType[ExtendedType[\"Place\"] = 7078913] = \"Place\";\n        ExtendedType[ExtendedType[\"Latitude\"] = 7144448] = \"Latitude\";\n        ExtendedType[ExtendedType[\"Latitude_Decimal\"] = 7144706] = \"Latitude_Decimal\";\n        ExtendedType[ExtendedType[\"Latitude_Double\"] = 7144707] = \"Latitude_Double\";\n        ExtendedType[ExtendedType[\"Longitude\"] = 7209984] = \"Longitude\";\n        ExtendedType[ExtendedType[\"Longitude_Decimal\"] = 7210242] = \"Longitude_Decimal\";\n        ExtendedType[ExtendedType[\"Longitude_Double\"] = 7210243] = \"Longitude_Double\";\n        // Miscellaneous\n        ExtendedType[ExtendedType[\"Image\"] = 13109259] = \"Image\";\n        ExtendedType[ExtendedType[\"ImageUrl\"] = 13174785] = \"ImageUrl\";\n        ExtendedType[ExtendedType[\"WebUrl\"] = 13240321] = \"WebUrl\";\n        ExtendedType[ExtendedType[\"Barcode\"] = 13305856] = \"Barcode\";\n        ExtendedType[ExtendedType[\"Barcode_Text\"] = 13305857] = \"Barcode_Text\";\n        ExtendedType[ExtendedType[\"Barcode_Integer\"] = 13306116] = \"Barcode_Integer\";\n        // Formatting\n        ExtendedType[ExtendedType[\"Color\"] = 19664897] = \"Color\";\n        ExtendedType[ExtendedType[\"FormatString\"] = 19730433] = \"FormatString\";\n        ExtendedType[ExtendedType[\"Alignment\"] = 20058113] = \"Alignment\";\n        ExtendedType[ExtendedType[\"LabelDisplayUnits\"] = 20123649] = \"LabelDisplayUnits\";\n        ExtendedType[ExtendedType[\"FontSize\"] = 20189443] = \"FontSize\";\n        ExtendedType[ExtendedType[\"LabelDensity\"] = 20254979] = \"LabelDensity\";\n        // Enumeration\n        ExtendedType[ExtendedType[\"Enumeration\"] = 26214401] = \"Enumeration\";\n        // Scripting\n        ExtendedType[ExtendedType[\"ScriptSource\"] = 32776193] = \"ScriptSource\";\n        // NOTE: To avoid confusion, underscores should be used only to delimit primitive type variants of an extended type\n        // (e.g. Year_Integer or Latitude_Double above)\n        //Operations\n        ExtendedType[ExtendedType[\"SearchEnabled\"] = 65541] = \"SearchEnabled\";\n    })(powerbi.ExtendedType || (powerbi.ExtendedType = {}));\n    var ExtendedType = powerbi.ExtendedType;\n    var PrimitiveTypeMask = 0xFF;\n    var PrimitiveTypeWithFlagsMask = 0xFFFF;\n    var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\n    function getPrimitiveType(extendedType) {\n        return extendedType & PrimitiveTypeMask;\n    }\n    function isPrimitiveType(extendedType) {\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\n    }\n    function getCategoryFromExtendedType(extendedType) {\n        if (isPrimitiveType(extendedType))\n            return null;\n        var category = ExtendedType[extendedType];\n        if (category) {\n            // Check for ExtendedType declaration without a primitive type.\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\n            var delimIdx = category.lastIndexOf('_');\n            if (delimIdx > 0) {\n                var baseCategory = category.slice(0, delimIdx);\n                if (ExtendedType[baseCategory]) {\n                    debug.assert((ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), 'Unexpected value for ExtendedType base member of ' + extendedType);\n                    category = baseCategory;\n                }\n            }\n        }\n        return category || null;\n    }\n    function toExtendedType(primitiveType, category) {\n        var primitiveString = PrimitiveType[primitiveType];\n        var t = ExtendedType[primitiveString];\n        if (t == null) {\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\n            t = ExtendedType.Null;\n        }\n        if (primitiveType && category) {\n            var categoryType = ExtendedType[category];\n            if (categoryType) {\n                var categoryPrimitiveType = getPrimitiveType(categoryType);\n                if (categoryPrimitiveType === PrimitiveType.Null) {\n                    // Category supports multiple primitive types, check if requested primitive type is supported\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\n                    categoryType = t | categoryType;\n                    if (ExtendedType[categoryType]) {\n                        debug.assert(ExtendedType[categoryType] === (category + '_' + primitiveString), 'Unexpected name for ExtendedType member ' + categoryType);\n                        t = categoryType;\n                    }\n                }\n                else if (categoryPrimitiveType === primitiveType) {\n                    // Primitive type matches the single supported type for the category\n                    t = categoryType;\n                }\n            }\n        }\n        return t;\n    }\n    function matchesExtendedTypeWithAnyPrimitive(a, b) {\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (DataShapeBindingLimitType) {\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Top\"] = 0] = \"Top\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"First\"] = 1] = \"First\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Last\"] = 2] = \"Last\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Sample\"] = 3] = \"Sample\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Bottom\"] = 4] = \"Bottom\";\n        })(data.DataShapeBindingLimitType || (data.DataShapeBindingLimitType = {}));\n        var DataShapeBindingLimitType = data.DataShapeBindingLimitType;\n        (function (SubtotalType) {\n            SubtotalType[SubtotalType[\"None\"] = 0] = \"None\";\n            SubtotalType[SubtotalType[\"Before\"] = 1] = \"Before\";\n            SubtotalType[SubtotalType[\"After\"] = 2] = \"After\";\n        })(data.SubtotalType || (data.SubtotalType = {}));\n        var SubtotalType = data.SubtotalType;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataShapeBindingDataReduction;\n        (function (DataShapeBindingDataReduction) {\n            function createFrom(reduction) {\n                if (!reduction)\n                    return;\n                var result;\n                if (reduction.top) {\n                    result = {\n                        Top: {}\n                    };\n                    if (reduction.top.count)\n                        result.Top.Count = reduction.top.count;\n                }\n                if (reduction.bottom) {\n                    result = {\n                        Bottom: {}\n                    };\n                    if (reduction.bottom.count)\n                        result.Bottom.Count = reduction.bottom.count;\n                }\n                if (reduction.sample) {\n                    result = {\n                        Sample: {}\n                    };\n                    if (reduction.sample.count)\n                        result.Sample.Count = reduction.sample.count;\n                }\n                if (reduction.window) {\n                    result = {\n                        Window: {}\n                    };\n                    if (reduction.window.count)\n                        result.Window.Count = reduction.window.count;\n                }\n                return result;\n            }\n            DataShapeBindingDataReduction.createFrom = createFrom;\n        })(DataShapeBindingDataReduction = data.DataShapeBindingDataReduction || (data.DataShapeBindingDataReduction = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Represents a federated conceptual schema. */\n        var FederatedConceptualSchema = (function () {\n            function FederatedConceptualSchema(options) {\n                debug.assertValue(options, 'options');\n                this.schemas = options.schemas;\n                if (options.links)\n                    this.links = options.links;\n            }\n            FederatedConceptualSchema.prototype.schema = function (name) {\n                return this.schemas[name];\n            };\n            return FederatedConceptualSchema;\n        }());\n        data.FederatedConceptualSchema = FederatedConceptualSchema;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_1) {\n        var Selector;\n        (function (Selector) {\n            function filterFromSelector(selectors, isNot) {\n                if (_.isEmpty(selectors))\n                    return;\n                var exprs = [];\n                for (var i = 0, ilen = selectors.length; i < ilen; i++) {\n                    var identity = selectors[i];\n                    var data_2 = identity.data;\n                    var exprToAdd = undefined;\n                    if (data_2 && data_2.length) {\n                        for (var j = 0, jlen = data_2.length; j < jlen; j++) {\n                            exprToAdd = data_1.SQExprBuilder.and(exprToAdd, identity.data[j].expr);\n                        }\n                    }\n                    if (exprToAdd)\n                        exprs.push(exprToAdd);\n                }\n                if (!_.isEmpty(exprs))\n                    return powerbi.DataViewScopeIdentity.filterFromExprs(exprs, isNot);\n            }\n            Selector.filterFromSelector = filterFromSelector;\n            function matchesData(selector, identities) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(identities, 'identities');\n                var selectorData = selector.data;\n                if (selectorData.length !== identities.length)\n                    return false;\n                for (var i = 0, len = selectorData.length; i < len; i++) {\n                    var dataItem = selector.data[i];\n                    var selectorDataItem = dataItem;\n                    if (selectorDataItem.expr) {\n                        if (!powerbi.DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\n                            return false;\n                    }\n                    else {\n                        if (!data_1.DataViewScopeWildcard.matches(dataItem, identities[i]))\n                            return false;\n                    }\n                }\n                return true;\n            }\n            Selector.matchesData = matchesData;\n            function matchesKeys(selector, keysList) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(keysList, 'keysList');\n                var selectorData = selector.data, selectorDataLength = selectorData.length;\n                if (selectorDataLength !== keysList.length)\n                    return false;\n                for (var i = 0; i < selectorDataLength; i++) {\n                    var selectorDataItem = selector.data[i], selectorDataExprs = void 0;\n                    if (selectorDataItem.expr) {\n                        selectorDataExprs = data_1.ScopeIdentityExtractor.getKeys(selectorDataItem.expr);\n                    }\n                    else if (selectorDataItem.exprs) {\n                        selectorDataExprs = selectorDataItem.exprs;\n                    }\n                    else {\n                        // In case DataViewRoleWildcard\n                        return false;\n                    }\n                    if (!selectorDataExprs)\n                        continue;\n                    if (!data_1.SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\n                        return false;\n                }\n                return true;\n            }\n            Selector.matchesKeys = matchesKeys;\n            /** Determines whether two selectors are equal. */\n            function equals(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (x.id !== y.id)\n                    return false;\n                if (x.metadata !== y.metadata)\n                    return false;\n                if (!equalsDataArray(x.data, y.data))\n                    return false;\n                return true;\n            }\n            Selector.equals = equals;\n            function equalsDataArray(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                if (x.length !== y.length)\n                    return false;\n                for (var i = 0, len = x.length; i < len; i++) {\n                    if (!equalsData(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            function equalsData(x, y) {\n                var selector1 = x;\n                var selector2 = y;\n                if (selector1.expr && selector2.expr)\n                    return powerbi.DataViewScopeIdentity.equals(selector1, selector2);\n                if (selector1.exprs && selector2.exprs)\n                    return data_1.DataViewScopeWildcard.equals(selector1, selector2);\n                if (selector1.roles && selector2.roles)\n                    return data_1.DataViewRoleWildcard.equals(selector1, selector2);\n                return false;\n            }\n            function getKey(selector) {\n                var toStringify = {};\n                if (selector.data) {\n                    var data_3 = [];\n                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {\n                        data_3.push(selector.data[i].key);\n                    }\n                    toStringify.data = data_3;\n                }\n                if (selector.metadata)\n                    toStringify.metadata = selector.metadata;\n                if (selector.id)\n                    toStringify.id = selector.id;\n                return JSON.stringify(toStringify);\n            }\n            Selector.getKey = getKey;\n            function containsWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (!dataItems)\n                    return false;\n                for (var _i = 0, dataItems_1 = dataItems; _i < dataItems_1.length; _i++) {\n                    var dataItem = dataItems_1[_i];\n                    var wildCard = dataItem;\n                    if (wildCard.exprs || wildCard.roles)\n                        return true;\n                }\n                return false;\n            }\n            Selector.containsWildcard = containsWildcard;\n            function hasRoleWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (_.isEmpty(dataItems))\n                    return false;\n                for (var _i = 0, dataItems_2 = dataItems; _i < dataItems_2.length; _i++) {\n                    var dataItem = dataItems_2[_i];\n                    if (isRoleWildcard(dataItem))\n                        return true;\n                }\n                return false;\n            }\n            Selector.hasRoleWildcard = hasRoleWildcard;\n            function isRoleWildcard(dataItem) {\n                return !_.isEmpty(dataItem.roles);\n            }\n            Selector.isRoleWildcard = isRoleWildcard;\n        })(Selector = data_1.Selector || (data_1.Selector = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (EntitySourceType) {\n            EntitySourceType[EntitySourceType[\"Table\"] = 0] = \"Table\";\n            EntitySourceType[EntitySourceType[\"Pod\"] = 1] = \"Pod\";\n        })(data.EntitySourceType || (data.EntitySourceType = {}));\n        var EntitySourceType = data.EntitySourceType;\n        function getArithmeticOperatorName(arithmeticOperatorKind) {\n            switch (arithmeticOperatorKind) {\n                case 0 /* Add */:\n                    return \"Add\";\n                case 1 /* Subtract */:\n                    return \"Subtract\";\n                case 2 /* Multiply */:\n                    return \"Multiply\";\n                case 3 /* Divide */:\n                    return \"Divide\";\n            }\n            throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\n        }\n        data.getArithmeticOperatorName = getArithmeticOperatorName;\n        (function (TimeUnit) {\n            TimeUnit[TimeUnit[\"Day\"] = 0] = \"Day\";\n            TimeUnit[TimeUnit[\"Week\"] = 1] = \"Week\";\n            TimeUnit[TimeUnit[\"Month\"] = 2] = \"Month\";\n            TimeUnit[TimeUnit[\"Year\"] = 3] = \"Year\";\n            TimeUnit[TimeUnit[\"Decade\"] = 4] = \"Decade\";\n            TimeUnit[TimeUnit[\"Second\"] = 5] = \"Second\";\n            TimeUnit[TimeUnit[\"Minute\"] = 6] = \"Minute\";\n            TimeUnit[TimeUnit[\"Hour\"] = 7] = \"Hour\";\n        })(data.TimeUnit || (data.TimeUnit = {}));\n        var TimeUnit = data.TimeUnit;\n        (function (QueryAggregateFunction) {\n            QueryAggregateFunction[QueryAggregateFunction[\"Sum\"] = 0] = \"Sum\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Avg\"] = 1] = \"Avg\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Count\"] = 2] = \"Count\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Min\"] = 3] = \"Min\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Max\"] = 4] = \"Max\";\n            QueryAggregateFunction[QueryAggregateFunction[\"CountNonNull\"] = 5] = \"CountNonNull\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Median\"] = 6] = \"Median\";\n            QueryAggregateFunction[QueryAggregateFunction[\"StandardDeviation\"] = 7] = \"StandardDeviation\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Variance\"] = 8] = \"Variance\";\n        })(data.QueryAggregateFunction || (data.QueryAggregateFunction = {}));\n        var QueryAggregateFunction = data.QueryAggregateFunction;\n        (function (QueryComparisonKind) {\n            QueryComparisonKind[QueryComparisonKind[\"Equal\"] = 0] = \"Equal\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThan\"] = 1] = \"GreaterThan\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThanOrEqual\"] = 2] = \"GreaterThanOrEqual\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThan\"] = 3] = \"LessThan\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThanOrEqual\"] = 4] = \"LessThanOrEqual\";\n        })(data.QueryComparisonKind || (data.QueryComparisonKind = {}));\n        var QueryComparisonKind = data.QueryComparisonKind;\n        /** Defines semantic data types. */\n        (function (SemanticType) {\n            SemanticType[SemanticType[\"None\"] = 0] = \"None\";\n            SemanticType[SemanticType[\"Number\"] = 1] = \"Number\";\n            SemanticType[SemanticType[\"Integer\"] = 3] = \"Integer\";\n            SemanticType[SemanticType[\"DateTime\"] = 4] = \"DateTime\";\n            SemanticType[SemanticType[\"Time\"] = 8] = \"Time\";\n            SemanticType[SemanticType[\"Date\"] = 20] = \"Date\";\n            SemanticType[SemanticType[\"Month\"] = 35] = \"Month\";\n            SemanticType[SemanticType[\"Year\"] = 67] = \"Year\";\n            SemanticType[SemanticType[\"YearAndMonth\"] = 128] = \"YearAndMonth\";\n            SemanticType[SemanticType[\"MonthAndDay\"] = 256] = \"MonthAndDay\";\n            SemanticType[SemanticType[\"Decade\"] = 515] = \"Decade\";\n            SemanticType[SemanticType[\"YearAndWeek\"] = 1024] = \"YearAndWeek\";\n            SemanticType[SemanticType[\"String\"] = 2048] = \"String\";\n            SemanticType[SemanticType[\"Boolean\"] = 4096] = \"Boolean\";\n            SemanticType[SemanticType[\"Table\"] = 8192] = \"Table\";\n            SemanticType[SemanticType[\"Range\"] = 16384] = \"Range\";\n        })(data.SemanticType || (data.SemanticType = {}));\n        var SemanticType = data.SemanticType;\n        (function (FilterKind) {\n            FilterKind[FilterKind[\"Default\"] = 0] = \"Default\";\n            FilterKind[FilterKind[\"Period\"] = 1] = \"Period\";\n        })(data.FilterKind || (data.FilterKind = {}));\n        var FilterKind = data.FilterKind;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var QueryProjectionCollection = (function () {\n            function QueryProjectionCollection(items, activeProjectionRefs, showAll) {\n                debug.assertValue(items, 'items');\n                this.items = items;\n                this._activeProjectionRefs = activeProjectionRefs;\n                this._showAll = showAll;\n            }\n            /** Returns all projections in a mutable array. */\n            QueryProjectionCollection.prototype.all = function () {\n                return this.items;\n            };\n            Object.defineProperty(QueryProjectionCollection.prototype, \"activeProjectionRefs\", {\n                get: function () {\n                    return this._activeProjectionRefs;\n                },\n                set: function (queryReferences) {\n                    if (!_.isEmpty(queryReferences)) {\n                        var queryRefs = this.items.map(function (val) { return val.queryRef; });\n                        for (var _i = 0, queryReferences_1 = queryReferences; _i < queryReferences_1.length; _i++) {\n                            var queryReference = queryReferences_1[_i];\n                            if (!_.contains(queryRefs, queryReference))\n                                return;\n                        }\n                        this._activeProjectionRefs = queryReferences;\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(QueryProjectionCollection.prototype, \"showAll\", {\n                get: function () {\n                    return this._showAll;\n                },\n                set: function (value) {\n                    this._showAll = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            QueryProjectionCollection.prototype.addActiveQueryReference = function (queryRef) {\n                if (!this._activeProjectionRefs)\n                    this._activeProjectionRefs = [queryRef];\n                else\n                    this._activeProjectionRefs.push(queryRef);\n            };\n            QueryProjectionCollection.prototype.getLastActiveQueryReference = function () {\n                if (!_.isEmpty(this._activeProjectionRefs)) {\n                    return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\n                }\n            };\n            /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */\n            QueryProjectionCollection.prototype.replaceQueryRef = function (oldQueryRef, newQueryRef) {\n                debug.assertValue(oldQueryRef, 'oldQueryRef');\n                debug.assertValue(newQueryRef, 'newQueryRef');\n                debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');\n                debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');\n                // Note: the same queryRef can get projected multiple times\n                for (var _i = 0, _a = this.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    if (item.queryRef === oldQueryRef) {\n                        item.queryRef = newQueryRef;\n                    }\n                }\n            };\n            QueryProjectionCollection.prototype.clone = function () {\n                return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);\n            };\n            return QueryProjectionCollection;\n        }());\n        data.QueryProjectionCollection = QueryProjectionCollection;\n        var QueryProjectionsByRole;\n        (function (QueryProjectionsByRole) {\n            /** Clones the QueryProjectionsByRole. */\n            function clone(roles) {\n                if (!roles)\n                    return roles;\n                var clonedRoles = {};\n                for (var roleName in roles)\n                    clonedRoles[roleName] = roles[roleName].clone();\n                return clonedRoles;\n            }\n            QueryProjectionsByRole.clone = clone;\n            /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\n            function getRole(roles, name) {\n                debug.assertAnyValue(roles, 'roles');\n                debug.assertValue(name, 'name');\n                if (!roles)\n                    return;\n                return roles[name];\n            }\n            QueryProjectionsByRole.getRole = getRole;\n        })(QueryProjectionsByRole = data.QueryProjectionsByRole || (data.QueryProjectionsByRole = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** The system used to determine display units used during formatting */\n    (function (DisplayUnitSystemType) {\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Default\"] = 0] = \"Default\";\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Verbose\"] = 1] = \"Verbose\";\n        /**\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\n         * Suitable for dashboard tile cards\n         */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"WholeUnits\"] = 2] = \"WholeUnits\";\n        /**A display unit system that also contains Auto and None units for data labels*/\n        DisplayUnitSystemType[DisplayUnitSystemType[\"DataLabels\"] = 3] = \"DataLabels\";\n    })(powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));\n    var DisplayUnitSystemType = powerbi.DisplayUnitSystemType;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Repreasents the sequence of the dates/times */\n    var DateTimeSequence = (function () {\n        // Constructors\n        /** Creates new instance of the DateTimeSequence */\n        function DateTimeSequence(unit) {\n            this.unit = unit;\n            this.sequence = [];\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\n        }\n        // Methods\n        /**\n         * Add a new Date to a sequence.\n         * @param date - date to add\n         */\n        DateTimeSequence.prototype.add = function (date) {\n            if (date < this.min) {\n                this.min = date;\n            }\n            if (date > this.max) {\n                this.max = date;\n            }\n            this.sequence.push(date);\n        };\n        // Methods\n        /**\n         * Extends the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.extendToCover = function (min, max) {\n            var x = this.min;\n            while (min < x) {\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\n                this.sequence.splice(0, 0, x);\n            }\n            this.min = x;\n            x = this.max;\n            while (x < max) {\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\n                this.sequence.push(x);\n            }\n            this.max = x;\n        };\n        /**\n         * Move the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.moveToCover = function (min, max) {\n            var delta = DateTimeSequence.getDelta(min, max, this.unit);\n            var count = Math.floor(delta / this.interval);\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\n            this.sequence = [];\n            this.sequence.push(this.min);\n            this.max = this.min;\n            while (this.max < max) {\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\n                this.sequence.push(this.max);\n            }\n        };\n        // Static\n        /**\n         * Calculate a new DateTimeSequence\n         * @param dataMin - Date representing min of the data range\n         * @param dataMax - Date representing max of the data range\n         * @param expectedCount - expected number of intervals in the sequence\n         * @param unit - of the intervals in the sequence\n         */\n        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {\n            if (!unit) {\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\n            }\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Month:\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Week:\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Day:\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Second:\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\n                default:\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\n            }\n        };\n        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\n            // Calculate range and sequence\n            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\n            // Calculate year sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\n            var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;\n            var date = new Date(newMinYear, 0, 1);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);\n            return result;\n        };\n        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var minYear = dataMin.getFullYear();\n            var maxYear = dataMax.getFullYear();\n            var minMonth = dataMin.getMonth();\n            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\n            var date = new Date(minYear, 0, 1);\n            // Calculate month sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);\n            return result;\n        };\n        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            var firstDayOfWeek = 0;\n            var minDayOfWeek = dataMin.getDay();\n            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\n            var minDay = dataMin.getDate() - dayOffset;\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week));\n            // Calculate week sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);\n            return result;\n        };\n        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day));\n            // Calculate day sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);\n            return result;\n        };\n        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour));\n            // Calculate hour sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);\n            return result;\n        };\n        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);\n            return result;\n        };\n        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);\n            return result;\n        };\n        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\n            var min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond);\n            var max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond);\n            // Calculate milliseconds numeric sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);\n            return result;\n        };\n        DateTimeSequence.addInterval = function (value, interval, unit) {\n            interval = Math.round(interval);\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateUtils.addYears(value, interval);\n                case powerbi.DateTimeUnit.Month:\n                    return DateUtils.addMonths(value, interval);\n                case powerbi.DateTimeUnit.Week:\n                    return DateUtils.addWeeks(value, interval);\n                case powerbi.DateTimeUnit.Day:\n                    return DateUtils.addDays(value, interval);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateUtils.addHours(value, interval);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateUtils.addMinutes(value, interval);\n                case powerbi.DateTimeUnit.Second:\n                    return DateUtils.addSeconds(value, interval);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateUtils.addMilliseconds(value, interval);\n            }\n        };\n        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {\n            var result = new DateTimeSequence(unit);\n            for (var i = 0; i < sequence.sequence.length; i++) {\n                var x = sequence.sequence[i];\n                var d = DateTimeSequence.addInterval(date, x, unit);\n                result.add(d);\n            }\n            result.interval = sequence.interval;\n            result.intervalOffset = sequence.intervalOffset;\n            return result;\n        };\n        DateTimeSequence.getDelta = function (min, max, unit) {\n            var delta = 0;\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    delta = max.getFullYear() - min.getFullYear();\n                    break;\n                case powerbi.DateTimeUnit.Month:\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\n                    break;\n                case powerbi.DateTimeUnit.Week:\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Day:\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Hour:\n                    delta = (max.getTime() - min.getTime()) / 3600000;\n                    break;\n                case powerbi.DateTimeUnit.Minute:\n                    delta = (max.getTime() - min.getTime()) / 60000;\n                    break;\n                case powerbi.DateTimeUnit.Second:\n                    delta = (max.getTime() - min.getTime()) / 1000;\n                    break;\n                case powerbi.DateTimeUnit.Millisecond:\n                    delta = max.getTime() - min.getTime();\n                    break;\n            }\n            return delta;\n        };\n        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {\n            maxCount = Math.max(maxCount, 2);\n            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\n                return powerbi.DateTimeUnit.Year;\n            if (totalDays > 60 && totalDays > 7 * maxCount)\n                return powerbi.DateTimeUnit.Month;\n            if (totalDays > 14 && totalDays > 2 * maxCount)\n                return powerbi.DateTimeUnit.Week;\n            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);\n            if (totalDays > 2 && totalHours > 12 * maxCount)\n                return powerbi.DateTimeUnit.Day;\n            if (totalHours >= 24 && totalHours >= maxCount)\n                return powerbi.DateTimeUnit.Hour;\n            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\n                return powerbi.DateTimeUnit.Minute;\n            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\n                return powerbi.DateTimeUnit.Second;\n            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);\n            if (totalMilliseconds > 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\n            var date = min;\n            if (date.getMilliseconds() !== 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            if (date.getSeconds() !== 0)\n                return powerbi.DateTimeUnit.Second;\n            if (date.getMinutes() !== 0)\n                return powerbi.DateTimeUnit.Minute;\n            if (date.getHours() !== 0)\n                return powerbi.DateTimeUnit.Hour;\n            if (date.getDate() !== 1)\n                return powerbi.DateTimeUnit.Day;\n            if (date.getMonth() !== 0)\n                return powerbi.DateTimeUnit.Month;\n            return powerbi.DateTimeUnit.Year;\n        };\n        // Constants\n        DateTimeSequence.MIN_COUNT = 1;\n        DateTimeSequence.MAX_COUNT = 1000;\n        return DateTimeSequence;\n    }());\n    powerbi.DateTimeSequence = DateTimeSequence;\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\n    var DateUtils;\n    (function (DateUtils) {\n        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        /**\n         * Returns bool indicating weither the provided year is a leap year.\n         * @param year - year value\n         */\n        function isLeap(year) {\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\n        }\n        /**\n         * Returns number of days in the provided year/month.\n         * @param year - year value\n         * @param month - month value\n         */\n        function getMonthDays(year, month) {\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\n        }\n        /**\n         * Adds a specified number of years to the provided date.\n         * @param date - date value\n         * @param yearDelta - number of years to add\n         */\n        function addYears(date, yearDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var isLeapDay = month === 2 && day === 29;\n            var result = new Date(date.getTime());\n            year = year + yearDelta;\n            if (isLeapDay && !isLeap(year)) {\n                day = 28;\n            }\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addYears = addYears;\n        /**\n         * Adds a specified number of months to the provided date.\n         * @param date - date value\n         * @param monthDelta - number of months to add\n         */\n        function addMonths(date, monthDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            year += (monthDelta - (monthDelta % 12)) / 12;\n            month += monthDelta % 12;\n            // VSTS 1325771: Certain column charts don't display any data\n            // Wrap arround the month if is after december (value 11)\n            if (month > 11) {\n                month = month % 12;\n                year++;\n            }\n            day = Math.min(day, getMonthDays(year, month));\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addMonths = addMonths;\n        /**\n         * Adds a specified number of weeks to the provided date.\n         * @param date - date value\n         * @param weeks - number of weeks to add\n         */\n        function addWeeks(date, weeks) {\n            return addDays(date, weeks * 7);\n        }\n        DateUtils.addWeeks = addWeeks;\n        /**\n         * Adds a specified number of days to the provided date.\n         * @param date - date value\n         * @param days - number of days to add\n         */\n        function addDays(date, days) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            result.setFullYear(year, month, day + days);\n            return result;\n        }\n        DateUtils.addDays = addDays;\n        /**\n         * Adds a specified number of hours to the provided date.\n         * @param date - date value\n         * @param hours - number of hours to add\n         */\n        function addHours(date, hours) {\n            return new Date(date.getTime() + hours * 3600000);\n        }\n        DateUtils.addHours = addHours;\n        /**\n         * Adds a specified number of minutes to the provided date.\n         * @param date - date value\n         * @param minutes - number of minutes to add\n         */\n        function addMinutes(date, minutes) {\n            return new Date(date.getTime() + minutes * 60000);\n        }\n        DateUtils.addMinutes = addMinutes;\n        /**\n         * Adds a specified number of seconds to the provided date.\n         * @param date - date value\n         * @param seconds - number of seconds to add\n         */\n        function addSeconds(date, seconds) {\n            return new Date(date.getTime() + seconds * 1000);\n        }\n        DateUtils.addSeconds = addSeconds;\n        /**\n         * Adds a specified number of milliseconds to the provided date.\n         * @param date - date value\n         * @param milliseconds - number of milliseconds to add\n         */\n        function addMilliseconds(date, milliseconds) {\n            return new Date(date.getTime() + milliseconds);\n        }\n        DateUtils.addMilliseconds = addMilliseconds;\n    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    // Constants\n    var maxExponent = 24;\n    var defaultScientificBigNumbersBoundary = 1E15;\n    var scientificSmallNumbersBoundary = 1E-4;\n    var PERCENTAGE_FORMAT = '%';\n    var SCIENTIFIC_FORMAT = 'E+0';\n    var DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\n    // Regular expressions\n    /**\n     * This regex looks for strings that match one of the following conditions:\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\n     * The entire string (start to end) must match, and the match is not case-sensitive.\n     */\n    var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\n    var DisplayUnit = (function () {\n        function DisplayUnit() {\n        }\n        // Methods\n        DisplayUnit.prototype.project = function (value) {\n            if (this.value) {\n                return powerbi.Double.removeDecimalNoise(value / this.value);\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.reverseProject = function (value) {\n            if (this.value) {\n                return value * this.value;\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.isApplicableTo = function (value) {\n            value = Math.abs(value);\n            var precision = powerbi.Double.getPrecision(value, 3);\n            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);\n        };\n        DisplayUnit.prototype.isScaling = function () {\n            return this.value > 1;\n        };\n        return DisplayUnit;\n    }());\n    powerbi.DisplayUnit = DisplayUnit;\n    var DisplayUnitSystem = (function () {\n        // Constructor\n        function DisplayUnitSystem(units) {\n            this.units = units ? units : [];\n        }\n        Object.defineProperty(DisplayUnitSystem.prototype, \"title\", {\n            // Properties\n            get: function () {\n                return this.displayUnit ? this.displayUnit.title : undefined;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        DisplayUnitSystem.prototype.update = function (value) {\n            if (value === undefined)\n                return;\n            this.unitBaseValue = value;\n            this.displayUnit = this.findApplicableDisplayUnit(value);\n        };\n        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {\n            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {\n                var unit = _a[_i];\n                if (unit.isApplicableTo(value))\n                    return unit;\n            }\n            return undefined;\n        };\n        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\n            if (this.isFormatSupported(format)) {\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\n                if (this.hasScientitifcFormat(format)) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\n                }\n                if (decimals != null) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n            }\n            return powerbi.formattingService.formatValue(value, format);\n        };\n        DisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DisplayUnitSystem.prototype.isPercentageFormat = function (format) {\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\n        };\n        DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {\n            return !this.isPercentageFormat(format);\n        };\n        DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {\n            return decimals;\n        };\n        DisplayUnitSystem.prototype.isScalingUnit = function () {\n            return this.displayUnit && this.displayUnit.isScaling();\n        };\n        DisplayUnitSystem.prototype.formatHelper = function (value, nonScientificFormat, format, decimals, trailingZeros) {\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\n            if ((format === 'g' || format === 'G') && decimals != null)\n                format = powerbi.visuals.valueFormatter.DefaultNumericFormat;\n            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\n            if (format && !powerbi.formattingService.isStandardNumberFormat(format))\n                return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\n            if (!format)\n                format = 'G';\n            if (!nonScientificFormat)\n                nonScientificFormat = '{0}';\n            var text = powerbi.formattingService.formatValue(value, format);\n            return powerbi.formattingService.format(nonScientificFormat, [text]);\n        };\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\n        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros) {\n            // Change unit base to a value appropriate for this value\n            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);\n            return this.format(value, format, decimals, trailingZeros);\n        };\n        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {\n            if (this.units.length === 0)\n                return true;\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\n            var applicableRangeMin = 0;\n            for (var i = 0; i < this.units.length; i++) {\n                if (this.units[i].isScaling()) {\n                    applicableRangeMin = this.units[i].applicableRangeMin;\n                    break;\n                }\n            }\n            return Math.abs(value) < applicableRangeMin;\n        };\n        DisplayUnitSystem.prototype.isScientific = function (value) {\n            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\n        };\n        DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\n        };\n        DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {\n            if (format)\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\n            return true;\n        };\n        DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {\n            return !this.hasScientitifcFormat(format)\n                && this.supportsScientificFormat(format)\n                && this.isScientific(value);\n        };\n        DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {\n            // Use scientific format outside of the range\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\n                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);\n                if (decimals)\n                    numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\n                if (numericFormat)\n                    return numericFormat + SCIENTIFIC_FORMAT;\n                else\n                    return DEFAULT_SCIENTIFIC_FORMAT;\n            }\n            return format;\n        };\n        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\n        return DisplayUnitSystem;\n    }());\n    powerbi.DisplayUnitSystem = DisplayUnitSystem;\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\n    var NoDisplayUnitSystem = (function (_super) {\n        __extends(NoDisplayUnitSystem, _super);\n        // Constructor\n        function NoDisplayUnitSystem() {\n            _super.call(this, []);\n        }\n        return NoDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\n        we are showing values (chart axes) and as such it is the default unit system. */\n    var DefaultDisplayUnitSystem = (function (_super) {\n        __extends(DefaultDisplayUnitSystem, _super);\n        // Constructor\n        function DefaultDisplayUnitSystem(unitLookup) {\n            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));\n        }\n        // Methods\n        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        DefaultDisplayUnitSystem.reset = function () {\n            DefaultDisplayUnitSystem.units = null;\n        };\n        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DefaultDisplayUnitSystem.units) {\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\n                    if (value - previousUnitValue >= 1000) {\n                        return value / 10;\n                    }\n                    return min;\n                });\n                // Ensure last unit has max of infinity\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DefaultDisplayUnitSystem.units;\n        };\n        return DefaultDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\n        where we have restricted space but do not want to show partial units. */\n    var WholeUnitsDisplayUnitSystem = (function (_super) {\n        __extends(WholeUnitsDisplayUnitSystem, _super);\n        // Constructor\n        function WholeUnitsDisplayUnitSystem(unitLookup) {\n            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        WholeUnitsDisplayUnitSystem.reset = function () {\n            WholeUnitsDisplayUnitSystem.units = null;\n        };\n        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!WholeUnitsDisplayUnitSystem.units) {\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\n                // Ensure last unit has max of infinity\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return WholeUnitsDisplayUnitSystem.units;\n        };\n        WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        return WholeUnitsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;\n    var DataLabelsDisplayUnitSystem = (function (_super) {\n        __extends(DataLabelsDisplayUnitSystem, _super);\n        function DataLabelsDisplayUnitSystem(unitLookup) {\n            _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DataLabelsDisplayUnitSystem.units) {\n                var units = [];\n                var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {\n                    // Never returns true, we are always ignoring\n                    // We do not early switch (e.g. 100K instead of 0.1M)\n                    // Intended? If so, remove this function, otherwise, remove if statement\n                    if (value === -1)\n                        if (value - previousUnitValue >= 1000) {\n                            return value / 10;\n                        }\n                    return min;\n                };\n                // Add Auto & None\n                var names = unitLookup(-1);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                names = unitLookup(0);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                // Add normal units\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\n                // Ensure last unit has max of infinity\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DataLabelsDisplayUnitSystem.units;\n        };\n        DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        // Constants\n        DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;\n        DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;\n        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\n        return DataLabelsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;\n    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {\n        var units = [];\n        for (var i = 3; i < maxExponent; i++) {\n            var names = unitLookup(i);\n            if (names)\n                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\n        }\n        return units;\n    }\n    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {\n        if (title || labelFormat) {\n            var min = value;\n            if (units.length > 0) {\n                var previousUnit = units[units.length - 1];\n                if (adjustMinBasedOnPreviousUnit)\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\n                previousUnit.applicableRangeMax = min;\n            }\n            var unit = new DisplayUnit();\n            unit.value = value;\n            unit.applicableRangeMin = min;\n            unit.applicableRangeMax = min * 1000;\n            unit.title = title;\n            unit.labelFormat = labelFormat;\n            units.push(unit);\n        }\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequence = (function () {\n        function NumericSequence() {\n        }\n        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {\n            debug.assertValue(range, \"range\");\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\n            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), \"minPower\");\n            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), \"maxAllowedMargin\");\n            var result = new NumericSequence();\n            if (expectedCount === undefined)\n                expectedCount = 10;\n            else\n                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (minPower === undefined)\n                minPower = powerbi.Double.MIN_EXP;\n            if (useZeroRefPoint === undefined)\n                useZeroRefPoint = false;\n            if (maxAllowedMargin === undefined)\n                maxAllowedMargin = 1;\n            if (steps === undefined)\n                steps = [1, 2, 5];\n            // Handle single stop case\n            if (range.forcedSingleStop) {\n                result.interval = range.getSize();\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\n                result.min = range.min;\n                result.max = range.max;\n                result.sequence = [range.forcedSingleStop];\n                return result;\n            }\n            var interval = 0;\n            var min = 0;\n            var max = 9;\n            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\n            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\n            var size = range.getSize();\n            var exp = powerbi.Double.log10(size);\n            // Account for Exp of steps\n            var stepExp = powerbi.Double.log10(steps[0]);\n            exp = exp - stepExp;\n            // Account for MaxCount\n            var expectedCountExp = powerbi.Double.log10(expectedCount);\n            exp = exp - expectedCountExp;\n            // Account for MinPower\n            exp = Math.max(exp, minPower - stepExp + 1);\n            var count = undefined;\n            // Create array of \"good looking\" numbers\n            if (interval !== 0) {\n                // If explicit interval is defined - use it instead of the steps array.\n                var power = powerbi.Double.pow10(exp);\n                var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\n                roundRange.shrinkByStep(range, interval);\n                min = roundRange.min;\n                max = roundRange.max;\n                count = Math.floor(roundRange.getSize() / interval);\n            }\n            else {\n                // No interval defined -> find optimal interval\n                var dexp = void 0;\n                for (dexp = 0; dexp < 3; dexp++) {\n                    var e = exp + dexp;\n                    var power = powerbi.Double.pow10(e);\n                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\n                    var stepsCount = steps.length;\n                    var stepPower = powerbi.Double.pow10(e - 1);\n                    for (var i = 0; i < stepsCount; i++) {\n                        var step = steps[i] * stepPower;\n                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\n                        roundRange.shrinkByStep(range, step);\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\n                            roundRange.min -= step;\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\n                            roundRange.max += step;\n                        // Count the intervals\n                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\n                            interval = step;\n                            min = roundRange.min;\n                            max = roundRange.max;\n                            break;\n                        }\n                    }\n                    // Increase the scale power until the interval is found\n                    if (interval !== 0)\n                        break;\n                }\n            }\n            // Avoid extreme count cases (>1000 ticks)\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\n                interval = (max - min) / count;\n            }\n            result.min = min;\n            result.max = max;\n            result.interval = interval;\n            result.intervalOffset = min - range.min;\n            result.maxAllowedMargin = maxAllowedMargin;\n            result.canExtendMin = canExtendMin;\n            result.canExtendMax = canExtendMax;\n            // Fill in the Sequence\n            var precision = powerbi.Double.getPrecision(interval, 0);\n            result.precision = precision;\n            var sequence = [];\n            var x = powerbi.Double.roundToPrecision(min, precision);\n            sequence.push(x);\n            for (var i = 0; i < count; i++) {\n                x = powerbi.Double.roundToPrecision(x + interval, precision);\n                sequence.push(x);\n            }\n            result.sequence = sequence;\n            result.trimMinMax(range.min, range.max);\n            return result;\n        };\n        /**\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.\n         * @min - The minimum of the range.\n         * @max - The maximum of the range.\n         * @maxCount - The max count of intervals.\n         * @steps - array of intervals.\n         */\n        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {\n            // Initialization actions\n            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (min === max) {\n                max = min + 1;\n            }\n            var stepCount = 0;\n            var step = 0;\n            // Calculate step\n            for (var i = 0; i < steps.length; i++) {\n                step = steps[i];\n                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);\n                var minStepCount = powerbi.Double.floorWithPrecision(min / step);\n                stepCount = maxStepCount - minStepCount;\n                if (stepCount <= maxCount) {\n                    break;\n                }\n            }\n            // Calculate the offset\n            var offset = -min;\n            offset = offset % step;\n            // Create sequence\n            var result = new NumericSequence();\n            result.sequence = [];\n            for (var x = min + offset;; x += step) {\n                result.sequence.push(x);\n                if (x >= max)\n                    break;\n            }\n            result.interval = step;\n            result.intervalOffset = offset;\n            result.min = result.sequence[0];\n            result.max = result.sequence[result.sequence.length - 1];\n            return result;\n        };\n        NumericSequence.prototype.trimMinMax = function (min, max) {\n            var minMargin = (min - this.min) / this.interval;\n            var maxMargin = (this.max - max) / this.interval;\n            var marginPrecision = 0.001;\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\n                this.min = min;\n            }\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\n                this.max = max;\n            }\n        };\n        NumericSequence.MIN_COUNT = 1;\n        NumericSequence.MAX_COUNT = 1000;\n        return NumericSequence;\n    }());\n    powerbi.NumericSequence = NumericSequence;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequenceRange = (function () {\n        function NumericSequenceRange() {\n        }\n        NumericSequenceRange.prototype._ensureIncludeZero = function () {\n            if (this.includeZero) {\n                // fixed min and max has higher priority than includeZero\n                if (this.min > 0 && !this.hasFixedMin) {\n                    this.min = 0;\n                }\n                if (this.max < 0 && !this.hasFixedMax) {\n                    this.max = 0;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureNotEmpty = function () {\n            if (this.min === this.max) {\n                if (!this.min) {\n                    this.min = 0;\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\n                    this.hasFixedMin = true;\n                    this.hasFixedMax = true;\n                }\n                else {\n                    // We are dealing with a single data value (includeZero is not set)\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\n                    // Interval is calculated based on the number:\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\n                    var value = this.min;\n                    var exp = powerbi.Double.log10(Math.abs(value));\n                    var step = void 0;\n                    if (exp >= 0 && exp < 4) {\n                        step = 0.5;\n                        this.forcedSingleStop = value;\n                    }\n                    else {\n                        step = powerbi.Double.pow10(exp) / 2;\n                        this.forcedSingleStop = null;\n                    }\n                    this.min = value - step;\n                    this.max = value + step;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureDirection = function () {\n            if (this.min > this.max) {\n                var temp = this.min;\n                this.min = this.max;\n                this.max = temp;\n            }\n        };\n        NumericSequenceRange.prototype.getSize = function () {\n            return this.max - this.min;\n        };\n        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {\n            debug.assertValue(range, \"range\");\n            debug.assert(step > 0, \"step\");\n            var oldCount = this.min / step;\n            var newCount = range.min / step;\n            var deltaCount = Math.floor(newCount - oldCount);\n            this.min += deltaCount * step;\n            oldCount = this.max / step;\n            newCount = range.max / step;\n            deltaCount = Math.ceil(newCount - oldCount);\n            this.max += deltaCount * step;\n        };\n        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\n            var result = new NumericSequenceRange();\n            result.includeZero = includeZero ? true : false;\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\n            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            // Calculate the range using the min, max, dataRange\n            if (result.hasFixedMin && result.hasFixedMax) {\n                result.min = fixedMin;\n                result.max = fixedMax;\n            }\n            else if (result.hasFixedMin) {\n                result.min = fixedMin;\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\n            }\n            else if (result.hasFixedMax) {\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\n                result.max = fixedMax;\n            }\n            else if (result.hasDataRange) {\n                result.min = dataMin;\n                result.max = dataMax;\n            }\n            else {\n                result.min = 0;\n                result.max = 0;\n            }\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            if (result.min === 0) {\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\n            }\n            else if (result.max === 0) {\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\n            }\n            return result;\n        };\n        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\n            }\n            else {\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\n            }\n        };\n        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {\n            debug.assertValue(fixedMin, \"fixedMin\");\n            debug.assertValue(fixedMax, \"fixedMax\");\n            var result = new NumericSequenceRange();\n            result.hasDataRange = false;\n            result.includeZero = includeZero;\n            result.min = fixedMin;\n            result.max = fixedMax;\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            result.hasFixedMin = true;\n            result.hasFixedMax = true;\n            return result;\n        };\n        NumericSequenceRange.DEFAULT_MAX = 10;\n        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;\n        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;\n        return NumericSequenceRange;\n    }());\n    powerbi.NumericSequenceRange = NumericSequenceRange;\n    /** Note: Exported for testability */\n    var ValueUtil;\n    (function (ValueUtil) {\n        function hasValue(value) {\n            return value !== undefined && value !== null;\n        }\n        ValueUtil.hasValue = hasValue;\n    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var valueFormatter;\n        (function (valueFormatter) {\n            var StringExtensions = jsCommon.StringExtensions;\n            var BeautifiedFormat = {\n                '0.00 %;-0.00 %;0.00 %': 'Percentage',\n                '0.0 %;-0.0 %;0.0 %': 'Percentage1',\n            };\n            valueFormatter.DefaultIntegerFormat = 'g';\n            valueFormatter.DefaultNumericFormat = '#,0.00';\n            valueFormatter.DefaultDateFormat = 'd';\n            var defaultLocalizedStrings = {\n                'NullValue': '(Blank)',\n                'BooleanTrue': 'True',\n                'BooleanFalse': 'False',\n                'NaNValue': 'NaN',\n                'InfinityValue': '+Infinity',\n                'NegativeInfinityValue': '-Infinity',\n                'RestatementComma': '{0}, {1}',\n                'RestatementCompoundAnd': '{0} and {1}',\n                'RestatementCompoundOr': '{0} or {1}',\n                'DisplayUnitSystem_EAuto_Title': 'Auto',\n                'DisplayUnitSystem_E0_Title': 'None',\n                'DisplayUnitSystem_E3_LabelFormat': '{0}K',\n                'DisplayUnitSystem_E3_Title': 'Thousands',\n                'DisplayUnitSystem_E6_LabelFormat': '{0}M',\n                'DisplayUnitSystem_E6_Title': 'Millions',\n                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\n                'DisplayUnitSystem_E9_Title': 'Billions',\n                'DisplayUnitSystem_E12_LabelFormat': '{0}T',\n                'DisplayUnitSystem_E12_Title': 'Trillions',\n                'Percentage': '#,0.##%',\n                'Percentage1': '#,0.#%',\n                'TableTotalLabel': 'Total',\n                'Tooltip_HighlightedValueDisplayName': 'Highlighted',\n                'Funnel_PercentOfFirst': 'Percent of first',\n                'Funnel_PercentOfPrevious': 'Percent of previous',\n                'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',\n                'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',\n                // Geotagging strings\n                'GeotaggingString_Continent': 'continent',\n                'GeotaggingString_Continents': 'continents',\n                'GeotaggingString_Country': 'country',\n                'GeotaggingString_Countries': 'countries',\n                'GeotaggingString_State': 'state',\n                'GeotaggingString_States': 'states',\n                'GeotaggingString_City': 'city',\n                'GeotaggingString_Cities': 'cities',\n                'GeotaggingString_Town': 'town',\n                'GeotaggingString_Towns': 'towns',\n                'GeotaggingString_Province': 'province',\n                'GeotaggingString_Provinces': 'provinces',\n                'GeotaggingString_County': 'county',\n                'GeotaggingString_Counties': 'counties',\n                'GeotaggingString_Village': 'village',\n                'GeotaggingString_Villages': 'villages',\n                'GeotaggingString_Post': 'post',\n                'GeotaggingString_Zip': 'zip',\n                'GeotaggingString_Code': 'code',\n                'GeotaggingString_Place': 'place',\n                'GeotaggingString_Places': 'places',\n                'GeotaggingString_Address': 'address',\n                'GeotaggingString_Addresses': 'addresses',\n                'GeotaggingString_Street': 'street',\n                'GeotaggingString_Streets': 'streets',\n                'GeotaggingString_Longitude': 'longitude',\n                'GeotaggingString_Longitude_Short': 'lon',\n                'GeotaggingString_Latitude': 'latitude',\n                'GeotaggingString_Latitude_Short': 'lat',\n                'GeotaggingString_PostalCode': 'postal code',\n                'GeotaggingString_PostalCodes': 'postal codes',\n                'GeotaggingString_ZipCode': 'zip code',\n                'GeotaggingString_ZipCodes': 'zip codes',\n                'GeotaggingString_Territory': 'territory',\n                'GeotaggingString_Territories': 'territories',\n            };\n            function beautify(format) {\n                var key = BeautifiedFormat[format];\n                if (key)\n                    return defaultLocalizedStrings[key] || format;\n                return format;\n            }\n            function describeUnit(exponent) {\n                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\n                var title = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\n                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\n                if (title || format)\n                    return { title: title, format: format };\n            }\n            function getLocalizedString(stringId) {\n                return defaultLocalizedStrings[stringId];\n            }\n            valueFormatter.getLocalizedString = getLocalizedString;\n            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\n            var locale = {\n                null: defaultLocalizedStrings['NullValue'],\n                true: defaultLocalizedStrings['BooleanTrue'],\n                false: defaultLocalizedStrings['BooleanFalse'],\n                NaN: defaultLocalizedStrings['NaNValue'],\n                infinity: defaultLocalizedStrings['InfinityValue'],\n                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\n                beautify: function (format) { return beautify(format); },\n                describe: function (exponent) { return describeUnit(exponent); },\n                restatementComma: defaultLocalizedStrings['RestatementComma'],\n                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\n                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\n            };\n            var MaxScaledDecimalPlaces = 2;\n            var MaxValueForDisplayUnitRounding = 1000;\n            var MinIntegerValueForDisplayUnits = 10000;\n            var MinPrecisionForDisplayUnits = 2;\n            var DateTimeMetadataColumn = {\n                displayName: '',\n                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.DateTime),\n            };\n            function getFormatMetadata(format) {\n                return powerbi.NumberFormat.getCustomFormatMetadata(format);\n            }\n            valueFormatter.getFormatMetadata = getFormatMetadata;\n            function setLocaleOptions(options) {\n                debug.assertValue(options, 'options');\n                locale = options;\n                powerbi.DefaultDisplayUnitSystem.reset();\n                powerbi.WholeUnitsDisplayUnitSystem.reset();\n            }\n            valueFormatter.setLocaleOptions = setLocaleOptions;\n            function createDefaultFormatter(formatString, allowFormatBeautification) {\n                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }\n                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;\n                return {\n                    format: function (value) {\n                        if (value == null)\n                            return locale.null;\n                        return formatCore(value, formatBeaut);\n                    }\n                };\n            }\n            valueFormatter.createDefaultFormatter = createDefaultFormatter;\n            /** Creates an IValueFormatter to be used for a range of values. */\n            function create(options) {\n                debug.assertValue(options, 'options');\n                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\n                if (shouldUseNumericDisplayUnits(options)) {\n                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);\n                    var singleValueFormattingMode_1 = !!options.formatSingleValues;\n                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\n                    var forcePrecision_1 = options.precision != null;\n                    var decimals_1;\n                    if (forcePrecision_1)\n                        decimals_1 = -options.precision;\n                    else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)\n                        decimals_1 = -MaxScaledDecimalPlaces;\n                    // Detect axis precision\n                    if (options.detectAxisPrecision) {\n                        // Trailing zeroes\n                        forcePrecision_1 = true;\n                        var axisValue = options.value;\n                        if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 0)\n                            axisValue = axisValue / displayUnitSystem_1.displayUnit.value;\n                        if (powerbi.Double.isInteger(axisValue))\n                            decimals_1 = 0;\n                        else\n                            decimals_1 = powerbi.Double.log10(axisValue);\n                    }\n                    return {\n                        format: function (value) {\n                            var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);\n                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                                return formattedValue;\n                            // Round to Double.DEFAULT_PRECISION\n                            if (value && !displayUnitSystem_1.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision_1)\n                                value = powerbi.Double.roundToPrecision(value);\n                            return singleValueFormattingMode_1 ?\n                                displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1) :\n                                displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1);\n                        },\n                        displayUnit: displayUnitSystem_1.displayUnit,\n                        options: options\n                    };\n                }\n                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\n                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\n                    return {\n                        format: function (value) {\n                            if (value == null)\n                                return locale.null;\n                            var formatString = powerbi.formattingService.dateFormatString(unit_1);\n                            return formatCore(value, formatString);\n                        },\n                        options: options\n                    };\n                }\n                return createDefaultFormatter(format);\n            }\n            valueFormatter.create = create;\n            function format(value, format, allowFormatBeautification) {\n                if (value == null)\n                    return locale.null;\n                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);\n            }\n            valueFormatter.format = format;\n            /**\n             * Value formatting function to handle variant measures.\n             * For a Date/Time value within a non-date/time field, it's formatted with the default date/time formatString instead of as a number\n             * @param {any} value Value to be formatted\n             * @param {DataViewMetadataColumn} column Field which the value belongs to\n             * @param {DataViewObjectPropertyIdentifier} formatStringProp formatString Property ID\n             * @param {boolean} nullsAreBlank? Whether to show \"(Blank)\" instead of empty string for null values\n             * @returns Formatted value\n             */\n            function formatVariantMeasureValue(value, column, formatStringProp, nullsAreBlank) {\n                // If column type is not datetime, but the value is of time datetime,\n                // then use the default date format string\n                if (!(column && column.type && column.type.dateTime) && value instanceof Date) {\n                    var valueFormat = getFormatString(DateTimeMetadataColumn, null, false);\n                    return formatCore(value, valueFormat, nullsAreBlank);\n                }\n                else {\n                    return formatCore(value, getFormatString(column, formatStringProp), nullsAreBlank);\n                }\n            }\n            valueFormatter.formatVariantMeasureValue = formatVariantMeasureValue;\n            function createDisplayUnitSystem(displayUnitSystemType) {\n                if (displayUnitSystemType == null)\n                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                switch (displayUnitSystemType) {\n                    case powerbi.DisplayUnitSystemType.Default:\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.WholeUnits:\n                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.Verbose:\n                        return new powerbi.NoDisplayUnitSystem();\n                    case powerbi.DisplayUnitSystemType.DataLabels:\n                        return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);\n                    default:\n                        debug.assertFail('Unknown display unit system type');\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                }\n            }\n            function shouldUseNumericDisplayUnits(options) {\n                var value = options.value;\n                var value2 = options.value2;\n                var format = options.format;\n                // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\n                if (options.formatSingleValues && format) {\n                    if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\n                        var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\n                        if (isCustomFormat) {\n                            var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\n                            if (precision < MinPrecisionForDisplayUnits)\n                                return false;\n                        }\n                        else if (powerbi.Double.isInteger(value))\n                            return false;\n                    }\n                }\n                if ((typeof value === 'number') || (typeof value2 === 'number')) {\n                    return true;\n                }\n            }\n            function shouldUseDateUnits(value, value2, tickCount) {\n                // must check both value and value2 because we'll need to get an interval for date units\n                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\n            }\n            /*\n             * Get the column format. Order of precendence is:\n             *  1. Column format\n             *  2. Default PowerView policy for column type\n             */\n            function getFormatString(column, formatStringProperty, suppressTypeFallback) {\n                if (column) {\n                    if (formatStringProperty) {\n                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);\n                        if (propertyValue)\n                            return propertyValue;\n                    }\n                    if (!suppressTypeFallback) {\n                        var columnType = column.type;\n                        if (columnType) {\n                            if (columnType.dateTime)\n                                return valueFormatter.DefaultDateFormat;\n                            if (columnType.integer)\n                                return valueFormatter.DefaultIntegerFormat;\n                            if (columnType.numeric)\n                                return valueFormatter.DefaultNumericFormat;\n                        }\n                    }\n                }\n            }\n            valueFormatter.getFormatString = getFormatString;\n            function formatListCompound(strings, conjunction) {\n                var result;\n                if (!strings) {\n                    return null;\n                }\n                var length = strings.length;\n                if (length > 0) {\n                    result = strings[0];\n                    var lastIndex = length - 1;\n                    for (var i = 1, len = lastIndex; i < len; i++) {\n                        var value = strings[i];\n                        result = StringExtensions.format(locale.restatementComma, result, value);\n                    }\n                    if (length > 1) {\n                        var value = strings[lastIndex];\n                        result = StringExtensions.format(conjunction, result, value);\n                    }\n                }\n                else {\n                    result = null;\n                }\n                return result;\n            }\n            /** The returned string will look like 'A, B, ..., and C'  */\n            function formatListAnd(strings) {\n                return formatListCompound(strings, locale.restatementCompoundAnd);\n            }\n            valueFormatter.formatListAnd = formatListAnd;\n            /** The returned string will look like 'A, B, ..., or C' */\n            function formatListOr(strings) {\n                return formatListCompound(strings, locale.restatementCompoundOr);\n            }\n            valueFormatter.formatListOr = formatListOr;\n            function formatCore(value, format, nullsAreBlank) {\n                var formattedValue = getStringFormat(value, nullsAreBlank ? nullsAreBlank : false /*nullsAreBlank*/);\n                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                    return formattedValue;\n                return powerbi.formattingService.formatValue(value, format);\n            }\n            function getStringFormat(value, nullsAreBlank) {\n                if (value == null && nullsAreBlank)\n                    return locale.null;\n                if (value === true)\n                    return locale.true;\n                if (value === false)\n                    return locale.false;\n                if (typeof value === 'number' && isNaN(value))\n                    return locale.NaN;\n                if (value === Number.NEGATIVE_INFINITY)\n                    return locale.negativeInfinity;\n                if (value === Number.POSITIVE_INFINITY)\n                    return locale.infinity;\n                return '';\n            }\n            function getDisplayUnits(displayUnitSystemType) {\n                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\n                return displayUnitSystem.units;\n            }\n            valueFormatter.getDisplayUnits = getDisplayUnits;\n        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper;\n        (function (DataRoleHelper) {\n            function getMeasureIndexOfRole(grouped, roleName) {\n                if (!_.isEmpty(grouped)) {\n                    var firstGroup = grouped[0];\n                    if (firstGroup.values && firstGroup.values.length > 0) {\n                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\n                            var value = firstGroup.values[i];\n                            if (value && value.source) {\n                                if (hasRole(value.source, roleName))\n                                    return i;\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\n            function getCategoryIndexOfRole(categories, roleName) {\n                if (!_.isEmpty(categories)) {\n                    for (var i = 0, ilen = categories.length; i < ilen; i++) {\n                        if (hasRole(categories[i].source, roleName))\n                            return i;\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\n            function hasRole(column, name) {\n                var roles = column.roles;\n                return roles && roles[name];\n            }\n            DataRoleHelper.hasRole = hasRole;\n            function hasRoleInDataView(dataView, name) {\n                return dataView != null\n                    && dataView.metadata != null\n                    && dataView.metadata.columns\n                    && _.any(dataView.metadata.columns, function (c) { return c.roles && c.roles[name] !== undefined; });\n            }\n            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\n            function hasRoleInValueColumn(valueColumn, name) {\n                return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\n            }\n            DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;\n        })(DataRoleHelper = data.DataRoleHelper || (data.DataRoleHelper = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper = powerbi.data.DataRoleHelper;\n        function createIDataViewCategoricalReader(dataView) {\n            return new DataViewCategoricalReader(dataView);\n        }\n        data.createIDataViewCategoricalReader = createIDataViewCategoricalReader;\n        var DataViewCategoricalReader = (function () {\n            function DataViewCategoricalReader(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                this.dataView = dataView;\n                // Validate categories\n                var categorical;\n                if (dataView)\n                    categorical = dataView.categorical;\n                var categories;\n                if (categorical)\n                    categories = this.categories = categorical.categories;\n                this.hasValidCategories = !_.isEmpty(categories);\n                // Validate values\n                var values;\n                if (categorical)\n                    values = categorical.values;\n                // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\n                // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\n                this.hasAnyValidValues = false;\n                if (values != null) {\n                    var grouped = dataView.categorical.values.grouped();\n                    if (grouped.length > 0) {\n                        this.hasAnyValidValues = true;\n                        this.grouped = grouped;\n                        // Iterate through the first group's values to populate the valueRoleIndexMapping\n                        var valueRoleIndexMapping = {};\n                        var firstGroupValues = grouped[0].values;\n                        for (var valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\n                            var valueRoles = firstGroupValues[valueIndex].source.roles;\n                            for (var role in valueRoles) {\n                                if (valueRoles[role]) {\n                                    if (!valueRoleIndexMapping[role])\n                                        valueRoleIndexMapping[role] = [];\n                                    valueRoleIndexMapping[role].push(valueIndex);\n                                }\n                            }\n                        }\n                        this.valueRoleIndexMapping = valueRoleIndexMapping;\n                    }\n                }\n                if (this.hasAnyValidValues)\n                    this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\n            }\n            // Category methods\n            DataViewCategoricalReader.prototype.hasCategories = function () {\n                return this.hasValidCategories;\n            };\n            DataViewCategoricalReader.prototype.getCategoryCount = function () {\n                if (this.hasValidCategories)\n                    return this.categories[0].values.length;\n                else\n                    return 0;\n            };\n            DataViewCategoricalReader.prototype.getCategoryValues = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryValue = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values[categoryIndex] : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumn = function (roleName) {\n                if (this.hasValidCategories)\n                    return this.getCategoryFromRole(roleName);\n            };\n            DataViewCategoricalReader.prototype.getCategoryMetadataColumn = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.source : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumnIdentityFields = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.identityFields : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryDisplayName = function (roleName) {\n                if (this.hasValidCategories) {\n                    var targetColumn = this.getCategoryColumn(roleName);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.hasCompositeCategories = function () {\n                if (this.hasValidCategories)\n                    return this.categories.length > 1;\n            };\n            DataViewCategoricalReader.prototype.hasCategoryWithRole = function (roleName) {\n                return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\n            };\n            DataViewCategoricalReader.prototype.getCategoryObjects = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var category = this.getCategoryFromRole(roleName);\n                    if (category && category.objects) {\n                        return category.objects[categoryIndex];\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryFromRole = function (roleName) {\n                var categories = this.categories;\n                return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\n            };\n            // Value and measure methods\n            DataViewCategoricalReader.prototype.hasValues = function (roleName) {\n                return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\n            };\n            DataViewCategoricalReader.prototype.hasHighlights = function (roleName) {\n                if (this.hasValues(roleName)) {\n                    return !_.isEmpty(this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].highlights);\n                }\n                return false;\n            };\n            DataViewCategoricalReader.prototype.getValue = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        // For dynamic series, we only ever obtain the first value column from a role\n                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, false /* getHighlight */);\n                    }\n                    else {\n                        // For static series or single series, we obtain value columns from the first series\n                        //    and use the seriesIndex to index into the value columns within the role\n                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, false /* getHighlight */);\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getHighlight = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        // For dynamic series, we only ever obtain the first value column from a role\n                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, true /* getHighlight */);\n                    }\n                    else {\n                        // For static series or single series, we obtain value columns from the first series\n                        //    and use the seriesIndex to index into the value columns within the role\n                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, true /* getHighlight */);\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllValuesForRole = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var valuesInRole = [];\n                    for (var roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, false /* getHighlight */));\n                    }\n                    return valuesInRole;\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllHighlightsForRole = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var valuesInRole = [];\n                    for (var roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, true /* getHighlight */));\n                    }\n                    return valuesInRole;\n                }\n            };\n            /**\n             * Obtains the value from grouped.\n             *\n             * Grouped:             [0] [1] [2] [3] (seriesIndex)\n             *                         /   \\\n             * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\n             *                    /    \\ \\  \\\n             * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\n             *\n             *--------------------------------|\n             *                      |Category |\n             * Series|Value Columns |A B C D E|\n             *--------------------------------|\n             *      0|col0 (tooltip)|         |\n             *       |col1 (value)  |         |\n             *       |col2 (value)  |         |\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      1|col0 (tooltip)|         |\n             *       |col1 (value)  |0 1 2 3 4|\n             *       |col2 (value)  |5 6 7 8 9|\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      2|col0 (tooltip)|...      |\n             *\n             * valueColumnIndexInRole is for indexing into the values for a single role\n             * valueColumnIndex is for indexing into the entire value array including\n             * all roles\n             *\n             * The valueRoleIndexMapping converts roleValueIndex and role (value role\n             * with an index of 1) into groupedValueIndex (2)\n             *\n             * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\n             * the second value column with role \"value\" (which is converted to a\n             * groupedValueIndex of 2) and the fourth value within that value column.\n             */\n            DataViewCategoricalReader.prototype.getValueInternal = function (roleName, categoryIndex, groupIndex, valueColumnIndexInRole, getHighlight) {\n                if (this.hasValues(roleName)) {\n                    var valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\n                    var groupedValues = this.grouped[groupIndex].values[valueColumnIndex];\n                    return getHighlight ? groupedValues.highlights[categoryIndex] : groupedValues.values[categoryIndex];\n                }\n            };\n            DataViewCategoricalReader.prototype.getFirstNonNullValueForCategory = function (roleName, categoryIndex) {\n                if (this.hasValues(roleName)) {\n                    if (!this.dataHasDynamicSeries) {\n                        debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\n                        return this.getValue(roleName, categoryIndex);\n                    }\n                    for (var seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\n                        var value = this.getValue(roleName, categoryIndex, seriesIndex);\n                        if (value != null) {\n                            return value;\n                        }\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getMeasureQueryName = function (roleName) {\n                if (this.hasValues(roleName))\n                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\n            };\n            DataViewCategoricalReader.prototype.getValueColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\n                    }\n                    else {\n                        return this.grouped[0].values[this.valueRoleIndexMapping[roleName][seriesIndex]];\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getValueMetadataColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                var valueColumn = this.getValueColumn(roleName, seriesIndex);\n                if (valueColumn) {\n                    return valueColumn.source;\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllValueMetadataColumnsForRole = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var metadata = [];\n                    for (var roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        var column = this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][roleValueIndex]].source;\n                        metadata.push(column);\n                    }\n                    return metadata;\n                }\n            };\n            DataViewCategoricalReader.prototype.getValueDisplayName = function (roleName, seriesIndex) {\n                if (this.hasValues(roleName)) {\n                    var targetColumn = this.getValueColumn(roleName, seriesIndex);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            // Series methods\n            DataViewCategoricalReader.prototype.hasDynamicSeries = function () {\n                return this.dataHasDynamicSeries;\n            };\n            DataViewCategoricalReader.prototype.getSeriesCount = function (valueRoleName) {\n                if (!this.hasAnyValidValues)\n                    return;\n                if (this.dataHasDynamicSeries) {\n                    return this.grouped.length;\n                }\n                else {\n                    var roleIndexMap = valueRoleName && this.valueRoleIndexMapping[valueRoleName];\n                    if (roleIndexMap)\n                        return roleIndexMap.length;\n                    return 1;\n                }\n            };\n            DataViewCategoricalReader.prototype.getSeriesObjects = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].objects;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumns = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumnGroup = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex];\n            };\n            DataViewCategoricalReader.prototype.getSeriesMetadataColumn = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.source;\n            };\n            DataViewCategoricalReader.prototype.getSeriesColumnIdentityFields = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.identityFields;\n            };\n            DataViewCategoricalReader.prototype.getSeriesName = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].name;\n            };\n            DataViewCategoricalReader.prototype.getSeriesDisplayName = function () {\n                if (this.hasAnyValidValues && this.dataHasDynamicSeries)\n                    return this.dataView.categorical.values.source.displayName;\n            };\n            return DataViewCategoricalReader;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var valueFormatter = powerbi.visuals.valueFormatter;\n        var DataViewConcatenateCategoricalColumns;\n        (function (DataViewConcatenateCategoricalColumns) {\n            function detectAndApply(dataView, objectDescriptors, roleMappings, projectionOrdering, selects, projectionActiveItems) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                var result = dataView;\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical) {\n                    var concatenationSource = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\n                    if (concatenationSource) {\n                        // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\n                        var columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\n                        if (columnsSortedByProjectionOrdering.length >= 2) {\n                            var activeItemsToIgnoreInConcatenation = _.chain(projectionActiveItems[concatenationSource.roleName])\n                                .filter(function (activeItemInfo) { return activeItemInfo.suppressConcat; })\n                                .map(function (activeItemInfo) { return activeItemInfo.queryRef; })\n                                .value();\n                            result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\n                        }\n                    }\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.detectAndApply = detectAndApply;\n            /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\n            function applyToPlayChartCategorical(metadata, objectDescriptors, categoryRoleName, categorical) {\n                debug.assertValue(metadata, 'metadata');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(categorical, 'categorical');\n                var result;\n                if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\n                    // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\n                    // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\n                    // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\n                    // use inherit() rather than inheritSingle() here.\n                    var transformingColumns_1 = inherit(metadata.columns);\n                    var transformingMetadata = inherit(metadata, function (m) { m.columns = transformingColumns_1; });\n                    var transformingDataView = { metadata: transformingMetadata, categorical: categorical };\n                    result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\n                }\n                else {\n                    result = { metadata: metadata, categorical: categorical };\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical = applyToPlayChartCategorical;\n            /**\n             * Returns the role and its assocated category columns (from dataViewCategorical.categories)\n             * that should be concatenated for the case of hierarchical group.\n             *\n             * Note: In the future if we support sibling hierarchical groups in categorical,\n             * change the return type to CategoryColumnsByRole[] and update detection logic.\n             */\n            function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, metadata, dataViewMappings, selects, projectionActiveItems) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\n                var result;\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var supportedRoleMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // The following code will choose a role name only if all supportedRoleMappings share the same role for Categorical Category.\n                // Handling multiple supportedRoleMappings is necessary for TransformActions with splits, which can happen in scenarios such as:\n                // 1. combo chart with a field for both Line and Column values, and\n                // 2. chart with regression line enabled.\n                // In case 1, you can pretty much get exactly the one from supportedRoleMappings for which this code is currently processing for,\n                // by looking at the index of the current split in DataViewTransformActions.splits.\n                // In case 2, however, supportedRoleMappings.length will be different than DataViewTransformActions.splits.length, hence it is\n                // not straight forward to figure out for which one in supportedRoleMappings is this code currently processing.\n                // SO... This code will just choose the category role name if it is consistent across all supportedRoleMappings.\n                var isEveryRoleMappingForCategorical = !_.isEmpty(supportedRoleMappings) &&\n                    _.every(supportedRoleMappings, function (roleMapping) { return !!roleMapping.categorical; });\n                if (isEveryRoleMappingForCategorical) {\n                    var targetRoleName_1 = getSingleCategoryRoleNameInEveryRoleMapping(supportedRoleMappings);\n                    if (targetRoleName_1 &&\n                        isVisualExpectingMaxOneCategoryColumn(targetRoleName_1, supportedRoleMappings)) {\n                        var categoryColumnsForTargetRole_1 = _.filter(dataViewCategorical.categories, function (categoryColumn) { return categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName_1]; });\n                        // There is no need to concatenate columns unless there is actually more than one column\n                        if (categoryColumnsForTargetRole_1.length >= 2) {\n                            // At least for now, we expect all category columns for the same role to have the same number of value entries.\n                            // If that's not the case, we won't run the concatenate logic for that role at all...\n                            var areValuesCountsEqual = _.every(categoryColumnsForTargetRole_1, function (categoryColumn) { return categoryColumn.values.length === categoryColumnsForTargetRole_1[0].values.length; });\n                            if (areValuesCountsEqual) {\n                                result = {\n                                    roleName: targetRoleName_1,\n                                    categories: categoryColumnsForTargetRole_1,\n                                };\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            /** If all mappings in the specified roleMappings have the same single role name for their categorical category roles, return that role name, else returns undefined. */\n            function getSingleCategoryRoleNameInEveryRoleMapping(categoricalRoleMappings) {\n                debug.assertNonEmpty(categoricalRoleMappings, 'categoricalRoleMappings');\n                debug.assert(_.every(categoricalRoleMappings, function (roleMapping) { return !!roleMapping.categorical; }), 'All mappings in categoricalRoleMappings must contain a DataViewCategoricalMapping');\n                var result;\n                // With \"list\" in role mapping, it is possible to have multiple role names for category.\n                // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\n                // We can change this if we want to support independent (sibling) group hierarchies in categorical.\n                var uniqueCategoryRoles = _.chain(categoricalRoleMappings)\n                    .map(function (roleMapping) {\n                    var categoryRoles = getAllRolesInCategories(roleMapping.categorical);\n                    return categoryRoles.length === 1 ? categoryRoles[0] : undefined;\n                })\n                    .uniq() // Note: _.uniq() does not treat two arrays with same elements as equal\n                    .value();\n                var isSameCategoryRoleNameInAllRoleMappings = uniqueCategoryRoles.length === 1 && !_.isUndefined(uniqueCategoryRoles[0]);\n                if (isSameCategoryRoleNameInAllRoleMappings) {\n                    result = uniqueCategoryRoles[0];\n                }\n                return result;\n            }\n            function isVisualExpectingMaxOneCategoryColumn(categoricalRoleName, roleMappings) {\n                debug.assertValue(categoricalRoleName, 'categoricalRoleName');\n                debug.assertNonEmpty(roleMappings, 'roleMappings');\n                var isVisualExpectingMaxOneCategoryColumn = _.every(roleMappings, function (roleMapping) {\n                    return !_.isEmpty(roleMapping.conditions) &&\n                        _.every(roleMapping.conditions, function (condition) { return condition[categoricalRoleName] && condition[categoricalRoleName].max === 1; });\n                });\n                return isVisualExpectingMaxOneCategoryColumn;\n            }\n            /**\n             * Returns the array of role names that are mapped to categorical categories.\n             * Returns an empty array if none exists.\n             */\n            function getAllRolesInCategories(categoricalRoleMapping) {\n                debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\n                var roleNames = [];\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalRoleMapping.categories, {\n                    visitRole: function (roleName) {\n                        roleNames.push(roleName);\n                    }\n                });\n                return roleNames;\n            }\n            function applyConcatenation(dataView, objectDescriptors, roleName, columnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(roleName, 'roleName');\n                debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\n                var formatStringPropId = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                var concatenatedValues = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\n                var columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, function (categoryColumn) { return categoryColumn.source; });\n                var concatenatedColumnMetadata = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\n                var transformedDataView = inheritSingle(dataView);\n                addToMetadata(transformedDataView, concatenatedColumnMetadata);\n                var concatenatedCategoryColumn = createConcatenatedCategoryColumn(columnsSortedByProjectionOrdering, concatenatedColumnMetadata, concatenatedValues);\n                var dataViewCategorical = dataView.categorical;\n                var transformedCategoricalCategories = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\n                transformedCategoricalCategories.push(concatenatedCategoryColumn);\n                var transformedCategorical = inheritSingle(dataViewCategorical);\n                transformedCategorical.categories = transformedCategoricalCategories;\n                transformedDataView.categorical = transformedCategorical;\n                return transformedDataView;\n            }\n            function concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId) {\n                debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\n                debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\n                debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\n                var concatenatedValues = [];\n                // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\n                for (var _i = 0, columnsSortedByProjectionOrdering_1 = columnsSortedByProjectionOrdering; _i < columnsSortedByProjectionOrdering_1.length; _i++) {\n                    var categoryColumn = columnsSortedByProjectionOrdering_1[_i];\n                    var formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\n                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {\n                        if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\n                            var value = categoryColumn.values && categoryColumn.values[i];\n                            var formattedValue = valueFormatter.format(value, formatString);\n                            concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\n                        }\n                    }\n                }\n                return concatenatedValues;\n            }\n            /**\n            * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\n            */\n            function sortColumnsByProjectionOrdering(projectionOrdering, roleName, columns) {\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                debug.assertValue(roleName, 'roleName');\n                debug.assertValue(columns, 'columns');\n                var columnsInProjectionOrdering;\n                if (projectionOrdering) {\n                    // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\n                    var columnsByIndex_1 = {};\n                    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n                        var column = columns_1[_i];\n                        if (column.source.roles[roleName]) {\n                            debug.assert(!columnsByIndex_1[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\n                            columnsByIndex_1[column.source.index] = column;\n                        }\n                    }\n                    var columnIndicesInProjectionOrdering = projectionOrdering[roleName];\n                    columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\n                        .map(function (columnIndex) { return columnsByIndex_1[columnIndex]; })\n                        .filter(function (column) { return !!column; })\n                        .value();\n                }\n                else {\n                    // If projectionOrder is unspecified, just return the columns for the specified role in their current order\n                    columnsInProjectionOrdering = _.filter(columns, function (column) { return column.source.roles[roleName]; });\n                }\n                return columnsInProjectionOrdering;\n            }\n            /**\n             * Creates the column metadata that will back the column with the concatenated values.\n             */\n            function createConcatenatedColumnMetadata(roleName, sourceColumnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(roleName, 'roleName');\n                debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\n                debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(function (c) { return c.isMeasure; }).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\n                var concatenatedDisplayName;\n                for (var _i = 0, sourceColumnsSortedByProjectionOrdering_1 = sourceColumnsSortedByProjectionOrdering; _i < sourceColumnsSortedByProjectionOrdering_1.length; _i++) {\n                    var columnSource = sourceColumnsSortedByProjectionOrdering_1[_i];\n                    if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\n                        concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\n                    }\n                }\n                var newRoles = {};\n                newRoles[roleName] = true;\n                var newColumnMetadata = {\n                    displayName: concatenatedDisplayName,\n                    roles: newRoles,\n                    type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Text)\n                };\n                var columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\n                if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\n                    newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\n                }\n                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\n                // If queryName is not set at all, the column chart visual will only render column for the first group instance.\n                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\n                newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\n                return newColumnMetadata;\n            }\n            function addToMetadata(transformedDataView, newColumn) {\n                debug.assertValue(transformedDataView, 'transformedDataView');\n                debug.assertValue(newColumn, 'newColumn');\n                var transformedColumns = inheritSingle(transformedDataView.metadata.columns);\n                transformedColumns.push(newColumn);\n                var transformedMetadata = inheritSingle(transformedDataView.metadata);\n                transformedMetadata.columns = transformedColumns;\n                transformedDataView.metadata = transformedMetadata;\n            }\n            function createConcatenatedCategoryColumn(sourceColumnsSortedByProjectionOrdering, columnMetadata, concatenatedValues) {\n                debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\n                var newCategoryColumn = {\n                    source: columnMetadata,\n                    values: concatenatedValues\n                };\n                // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\n                // So, we'll just take the identities and identityFields from the first column\n                var firstColumn = sourceColumnsSortedByProjectionOrdering[0];\n                if (firstColumn.identity) {\n                    newCategoryColumn.identity = firstColumn.identity;\n                }\n                if (firstColumn.identityFields) {\n                    newCategoryColumn.identityFields = firstColumn.identityFields;\n                }\n                // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\n                if (firstColumn.objects) {\n                    newCategoryColumn.objects = firstColumn.objects;\n                }\n                return newCategoryColumn;\n            }\n        })(DataViewConcatenateCategoricalColumns = data.DataViewConcatenateCategoricalColumns || (data.DataViewConcatenateCategoricalColumns = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewMapping;\n    (function (DataViewMapping) {\n        function visitMapping(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var categorical = mapping.categorical;\n            if (categorical)\n                visitCategorical(categorical, visitor);\n            var table = mapping.table;\n            if (table)\n                visitTable(table, visitor);\n            var matrix = mapping.matrix;\n            if (matrix)\n                visitMatrix(matrix, visitor);\n            var tree = mapping.tree;\n            if (tree)\n                visitTree(tree, visitor);\n            var single = mapping.single;\n            if (single)\n                visitSingle(single, visitor);\n        }\n        DataViewMapping.visitMapping = visitMapping;\n        function visitCategorical(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitCategoricalCategories(mapping.categories, visitor);\n            visitCategoricalValues(mapping.values, visitor);\n        }\n        DataViewMapping.visitCategorical = visitCategorical;\n        function visitCategoricalCategories(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor);\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitCategoricalCategories = visitCategoricalCategories;\n        function visitCategoricalValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor, 0 /* CategoricalValue */);\n                visitFor(mapping, visitor, 0 /* CategoricalValue */);\n                visitList(mapping, visitor, 0 /* CategoricalValue */);\n                var groupedRoleMapping = mapping;\n                visitGrouped(groupedRoleMapping, visitor);\n                var group = groupedRoleMapping.group;\n                if (group) {\n                    for (var _i = 0, _a = group.select; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        visitBind(item, visitor, 1 /* CategoricalValueGroup */);\n                        visitFor(item, visitor, 1 /* CategoricalValueGroup */);\n                    }\n                }\n            }\n        }\n        DataViewMapping.visitCategoricalValues = visitCategoricalValues;\n        function visitTable(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var rows = mapping.rows;\n            visitBind(rows, visitor);\n            visitFor(rows, visitor);\n            visitList(rows, visitor);\n            visitReduction(rows, visitor);\n        }\n        DataViewMapping.visitTable = visitTable;\n        function visitMatrix(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitMatrixItems(mapping.rows, visitor);\n            visitMatrixItems(mapping.columns, visitor);\n            visitMatrixItems(mapping.values, visitor);\n        }\n        /**\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         *\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         * @param visitor The visitor.\n         */\n        function visitMatrixItems(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitMatrixItems = visitMatrixItems;\n        function visitTree(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitTreeNodes(mapping.nodes, visitor);\n            visitTreeValues(mapping.values, visitor);\n        }\n        function visitTreeNodes(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeNodes = visitTreeNodes;\n        function visitTreeValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeValues = visitTreeValues;\n        function visitBind(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var bind = mapping.bind;\n            if (bind) {\n                if (context != null)\n                    visitor.visitRole(bind.to, context);\n                else\n                    visitor.visitRole(bind.to);\n            }\n        }\n        function visitFor(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var forValue = mapping.for;\n            if (forValue) {\n                if (context != null)\n                    visitor.visitRole(forValue.in, context);\n                else\n                    visitor.visitRole(forValue.in);\n            }\n        }\n        function visitList(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var select = mapping.select;\n            if (select) {\n                for (var _i = 0, select_1 = select; _i < select_1.length; _i++) {\n                    var item = select_1[_i];\n                    visitBind(item, visitor, context);\n                    visitFor(item, visitor, context);\n                }\n            }\n        }\n        function visitGrouped(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (!mapping)\n                return;\n            var group = mapping.group;\n            if (group) {\n                visitor.visitRole(group.by);\n                visitReduction(group, visitor);\n            }\n        }\n        DataViewMapping.visitGrouped = visitGrouped;\n        function visitReduction(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (visitor.visitReduction) {\n                var reductionAlgorithm = mapping.dataReductionAlgorithm;\n                if (reductionAlgorithm) {\n                    visitor.visitReduction(reductionAlgorithm);\n                }\n            }\n        }\n        function visitSingle(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitor.visitRole(mapping.role);\n        }\n    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewNormalizeValues;\n        (function (DataViewNormalizeValues) {\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                var rolesToNormalize = _.filter(options.dataRoles, function (role) { return !_.isEmpty(role.requiredTypes); });\n                filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\n            }\n            DataViewNormalizeValues.apply = apply;\n            function filterVariantMeasures(dataview, dataViewMappings, rolesToNormalize) {\n                debug.assertValue(dataview, 'dataview');\n                // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\n                    return;\n                var columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\n                var valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\n                var usedMappings = {};\n                for (var _i = 0, dataViewMappings_1 = dataViewMappings; _i < dataViewMappings_1.length; _i++) {\n                    var dataViewMapping = dataViewMappings_1[_i];\n                    // Get dataview specified in mappings which are also in dataview\n                    for (var dataViewMappingProp in dataViewMapping) {\n                        if (dataview[dataViewMappingProp] != null)\n                            usedMappings[dataViewMappingProp] = true;\n                    }\n                }\n                if (usedMappings['categorical'])\n                    filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\n                if (usedMappings['table'])\n                    filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\n                if (usedMappings['tree'])\n                    filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\n                if (usedMappings['matrix'])\n                    filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\n                if (usedMappings['single'])\n                    filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\n            }\n            DataViewNormalizeValues.filterVariantMeasures = filterVariantMeasures;\n            function generateMetadataColumnFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return false; };\n                var columnsToNormalize = {};\n                for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n                    var column = columns_2[_i];\n                    var roles = column.roles;\n                    if (!roles)\n                        continue;\n                    for (var _a = 0, rolesToNormalize_1 = rolesToNormalize; _a < rolesToNormalize_1.length; _a++) {\n                        var role = rolesToNormalize_1[_a];\n                        if (!roles[role.name])\n                            continue;\n                        columnsToNormalize[column.index] = true;\n                        break;\n                    }\n                }\n                return function (columnIndex) {\n                    if (isNaN(columnIndex))\n                        return false;\n                    return !!columnsToNormalize[columnIndex];\n                };\n            }\n            DataViewNormalizeValues.generateMetadataColumnFilter = generateMetadataColumnFilter;\n            function generateValueFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return true; };\n                var columnValueFilters = [];\n                // Build columnValueFilters based on role requiredTypes\n                for (var _i = 0, columns_3 = columns; _i < columns_3.length; _i++) {\n                    var column = columns_3[_i];\n                    var columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\n                    if (columnValueFilter)\n                        columnValueFilters[column.index] = columnValueFilter;\n                }\n                return function (columnIndex, value) {\n                    if (columnValueFilters[columnIndex])\n                        return columnValueFilters[columnIndex](value);\n                    return true;\n                };\n            }\n            DataViewNormalizeValues.generateValueFilter = generateValueFilter;\n            function generateColumnValueFilter(column, rolesToNormalize) {\n                var requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\n                if (_.isEmpty(requiredTypes))\n                    return;\n                return function (value) {\n                    return doesValueMatchTypes(value, requiredTypes);\n                };\n            }\n            function getColumnRequiredTypes(column, rolesToNormalize) {\n                var requiredTypes = [];\n                var columnRoles = column && column.roles;\n                if (!columnRoles)\n                    return requiredTypes;\n                for (var _i = 0, rolesToNormalize_2 = rolesToNormalize; _i < rolesToNormalize_2.length; _i++) {\n                    var role = rolesToNormalize_2[_i];\n                    if (!columnRoles[role.name])\n                        continue;\n                    for (var _a = 0, _b = role.requiredTypes; _a < _b.length; _a++) {\n                        var typeDescriptor = _b[_a];\n                        var type = powerbi.ValueType.fromDescriptor(typeDescriptor);\n                        requiredTypes.push(type);\n                    }\n                }\n                return requiredTypes;\n            }\n            DataViewNormalizeValues.getColumnRequiredTypes = getColumnRequiredTypes;\n            function filterVariantMeasuresCategorical(dataview, columnFilter, valueFilter) {\n                var values = dataview && dataview.values;\n                if (!values)\n                    return;\n                var valuesGrouped = values.grouped();\n                if (!valuesGrouped)\n                    return;\n                for (var _i = 0, valuesGrouped_1 = valuesGrouped; _i < valuesGrouped_1.length; _i++) {\n                    var valueGroup = valuesGrouped_1[_i];\n                    var valuesInGroup = valueGroup.values;\n                    for (var _a = 0, valuesInGroup_1 = valuesInGroup; _a < valuesInGroup_1.length; _a++) {\n                        var valueColumn = valuesInGroup_1[_a];\n                        var columnIndex = valueColumn.source.index;\n                        if (!columnFilter(columnIndex))\n                            continue;\n                        for (var i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\n                            valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\n                        }\n                    }\n                }\n            }\n            function filterVariantMeasuresTable(dataview, columnFilter, valueFilter) {\n                var columns = dataview && dataview.columns;\n                if (!columns)\n                    return;\n                var filteredColumns = [];\n                for (var _i = 0, columns_4 = columns; _i < columns_4.length; _i++) {\n                    var column = columns_4[_i];\n                    if (columnFilter(column.index))\n                        filteredColumns.push(column.index);\n                }\n                var rows = dataview.rows;\n                for (var i = 0, ilen = rows.length; i < ilen; i++) {\n                    for (var _a = 0, filteredColumns_1 = filteredColumns; _a < filteredColumns_1.length; _a++) {\n                        var index = filteredColumns_1[_a];\n                        rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresTreeNode(node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var columnIndex in node.values) {\n                        // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\n                        if (columnFilter(columnIndex)) {\n                            // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\n                            if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\n                                node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);\n                            else\n                                node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresMatrix(dataview, columnFilter, valueFilter) {\n                var root = dataview && dataview.rows && dataview.rows.root;\n                if (!root)\n                    return;\n                // Recurse into rows.children\n                // e.g. rows.children -> .children -> .children.values\n                filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\n            }\n            function filterVariantMeasuresMatrixRecursive(dataviewMatrix, node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var id in node.values) {\n                        // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\n                        var nodeValue = node.values[id];\n                        // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\n                        var valueSourceIndex = nodeValue.valueSourceIndex || 0;\n                        // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\n                        var columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\n                        if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\n                            node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter) {\n                if (!dataview.single)\n                    return;\n                var roleNames = [];\n                for (var _i = 0, rolesToNormalize_3 = rolesToNormalize; _i < rolesToNormalize_3.length; _i++) {\n                    var role = rolesToNormalize_3[_i];\n                    if (role.name)\n                        roleNames.push(role.name);\n                }\n                var columns = dataview.metadata.columns;\n                for (var _a = 0, dataViewMappings_2 = dataViewMappings; _a < dataViewMappings_2.length; _a++) {\n                    var dataViewMapping = dataViewMappings_2[_a];\n                    var roleName = dataViewMapping.single.role;\n                    if (roleNames.indexOf(roleName) !== -1) {\n                        var column = firstColumnByRoleName(columns, roleName);\n                        if (column)\n                            dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\n                        return;\n                    }\n                }\n            }\n            function normalizeVariant(object, key, columnIndex, valueFilter) {\n                if (!object)\n                    return;\n                var value = object[key];\n                if (value !== null && !valueFilter(columnIndex, value)) {\n                    object = inheritSingle(object);\n                    object[key] = null;\n                }\n                return object;\n            }\n            DataViewNormalizeValues.normalizeVariant = normalizeVariant;\n            function doesValueMatchTypes(value, types) {\n                for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n                    var type = types_1[_i];\n                    if (type.numeric || type.integer)\n                        return typeof (value) === 'number';\n                }\n                return false;\n            }\n            function firstColumnByRoleName(columns, roleName) {\n                for (var _i = 0, columns_5 = columns; _i < columns_5.length; _i++) {\n                    var column = columns_5[_i];\n                    var columnRoles = column && column.roles;\n                    if (columnRoles && columnRoles[roleName])\n                        return column;\n                }\n            }\n        })(DataViewNormalizeValues = data.DataViewNormalizeValues || (data.DataViewNormalizeValues = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewObjects;\n    (function (DataViewObjects) {\n        /** Gets the value of the given object/property pair. */\n        function getValue(objects, propertyId, defaultValue) {\n            debug.assertAnyValue(objects, 'objects');\n            debug.assertValue(propertyId, 'propertyId');\n            if (!objects)\n                return defaultValue;\n            var objectOrMap = objects[propertyId.objectName];\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\n            var object = objectOrMap;\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\n        }\n        DataViewObjects.getValue = getValue;\n        /** Gets an object from objects. */\n        function getObject(objects, objectName, defaultValue) {\n            if (objects && objects[objectName]) {\n                var object = objects[objectName];\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\n                return object;\n            }\n            else {\n                return defaultValue;\n            }\n        }\n        DataViewObjects.getObject = getObject;\n        /** Gets a map of user-defined objects. */\n        function getUserDefinedObjects(objects, objectName) {\n            if (objects && objects[objectName]) {\n                var map = objects[objectName];\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\n                return map;\n            }\n        }\n        DataViewObjects.getUserDefinedObjects = getUserDefinedObjects;\n        /** Gets the solid color from a fill property. */\n        function getFillColor(objects, propertyId, defaultColor) {\n            var value = getValue(objects, propertyId);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObjects.getFillColor = getFillColor;\n        /** Returns true if the given object represents a collection of user-defined objects */\n        function isUserDefined(objectOrMap) {\n            return _.isArray(objectOrMap);\n        }\n        DataViewObjects.isUserDefined = isUserDefined;\n    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));\n    var DataViewObject;\n    (function (DataViewObject) {\n        function getValue(object, propertyName, defaultValue) {\n            debug.assertAnyValue(object, 'object');\n            debug.assertValue(propertyName, 'propertyName');\n            if (!object)\n                return defaultValue;\n            var propertyValue = object[propertyName];\n            if (propertyValue === undefined)\n                return defaultValue;\n            return propertyValue;\n        }\n        DataViewObject.getValue = getValue;\n        /** Gets the solid color from a fill property using only a propertyName */\n        function getFillColorByPropertyName(objects, propertyName, defaultColor) {\n            var value = DataViewObject.getValue(objects, propertyName);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\n    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var JsonComparer = jsCommon.JsonComparer;\n        var DataViewObjectDefinitions;\n        (function (DataViewObjectDefinitions) {\n            /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\n            function ensure(defns, objectName, selector) {\n                debug.assertValue(defns, 'defns');\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    defns[objectName] = defnsForObject = [];\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n                var newDefn = {\n                    selector: selector,\n                    properties: {},\n                };\n                defnsForObject.push(newDefn);\n                return newDefn;\n            }\n            DataViewObjectDefinitions.ensure = ensure;\n            function deleteProperty(defns, objectName, selector, propertyName) {\n                debug.assertValue(defns, 'defns');\n                var defn = getObjectDefinition(defns, objectName, selector);\n                if (!defn)\n                    return;\n                DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\n            }\n            DataViewObjectDefinitions.deleteProperty = deleteProperty;\n            function setValue(defns, propertyId, selector, value) {\n                debug.assertValue(defns, 'defns');\n                debug.assertValue(propertyId, 'propertyId');\n                ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\n            }\n            DataViewObjectDefinitions.setValue = setValue;\n            function getValue(defns, propertyId, selector) {\n                var properties = getPropertyContainer(defns, propertyId, selector);\n                if (!properties)\n                    return;\n                return properties[propertyId.propertyName];\n            }\n            DataViewObjectDefinitions.getValue = getValue;\n            function getPropertyContainer(defns, propertyId, selector) {\n                var defn = getObjectDefinition(defns, propertyId.objectName, selector);\n                if (!defn)\n                    return;\n                return defn.properties;\n            }\n            DataViewObjectDefinitions.getPropertyContainer = getPropertyContainer;\n            function getObjectDefinition(defns, objectName, selector) {\n                debug.assertAnyValue(defns, 'defns');\n                debug.assertValue(objectName, 'objectName');\n                debug.assertAnyValue(selector, 'selector');\n                if (!defns)\n                    return;\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    return;\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n            }\n            DataViewObjectDefinitions.getObjectDefinition = getObjectDefinition;\n            function propertiesAreEqual(a, b) {\n                if (a instanceof data.SemanticFilter && b instanceof data.SemanticFilter) {\n                    return data.SemanticFilter.isSameFilter(a, b);\n                }\n                return JsonComparer.equals(a, b);\n            }\n            DataViewObjectDefinitions.propertiesAreEqual = propertiesAreEqual;\n            function allPropertiesAreEqual(a, b) {\n                debug.assertValue(a, 'a');\n                debug.assertValue(b, 'b');\n                if (Object.keys(a).length !== Object.keys(b).length)\n                    return false;\n                for (var property in a) {\n                    if (!propertiesAreEqual(a[property], b[property]))\n                        return false;\n                }\n                return true;\n            }\n            DataViewObjectDefinitions.allPropertiesAreEqual = allPropertiesAreEqual;\n            function encodePropertyValue(value, valueTypeDescriptor) {\n                debug.assertAnyValue(value, 'value');\n                debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\n                if (valueTypeDescriptor.bool) {\n                    if (typeof (value) !== 'boolean')\n                        value = false; // This is fallback, which doesn't really belong here.\n                    return data.SQExprBuilder.boolean(value);\n                }\n                else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\n                    return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.numeric) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                }\n                else if (valueTypeDescriptor.fill) {\n                    if (value) {\n                        return {\n                            solid: { color: data.SQExprBuilder.text(value) }\n                        };\n                    }\n                }\n                else if (valueTypeDescriptor.formatting) {\n                    if (valueTypeDescriptor.formatting.labelDisplayUnits) {\n                        return data.SQExprBuilder.double(+value);\n                    }\n                    else {\n                        return data.SQExprBuilder.text(value);\n                    }\n                }\n                else if (valueTypeDescriptor.enumeration) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                    else\n                        return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.misc) {\n                    if (value) {\n                        value = data.SQExprBuilder.text(value);\n                    }\n                    else {\n                        value = null;\n                    }\n                }\n                else if (valueTypeDescriptor.image) {\n                    if (value) {\n                        var imageValue = value;\n                        var imageDefinition = {\n                            name: data.SQExprBuilder.text(imageValue.name),\n                            url: data.SQExprBuilder.text(imageValue.url),\n                        };\n                        if (imageValue.scaling)\n                            imageDefinition.scaling = data.SQExprBuilder.text(imageValue.scaling);\n                        return imageDefinition;\n                    }\n                }\n                return value;\n            }\n            DataViewObjectDefinitions.encodePropertyValue = encodePropertyValue;\n            function clone(original) {\n                debug.assertValue(original, 'original');\n                var cloned = {};\n                for (var objectName in original) {\n                    var originalDefns = original[objectName];\n                    if (_.isEmpty(originalDefns))\n                        continue;\n                    var clonedDefns = [];\n                    for (var _i = 0, originalDefns_1 = originalDefns; _i < originalDefns_1.length; _i++) {\n                        var originalDefn = originalDefns_1[_i];\n                        clonedDefns.push({\n                            properties: cloneProperties(originalDefn.properties),\n                            selector: originalDefn.selector,\n                        });\n                    }\n                    cloned[objectName] = clonedDefns;\n                }\n                return cloned;\n            }\n            DataViewObjectDefinitions.clone = clone;\n            function cloneProperties(original) {\n                debug.assertValue(original, 'original');\n                // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\n                return _.clone(original);\n            }\n        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));\n        var DataViewObjectDefinition;\n        (function (DataViewObjectDefinition) {\n            function deleteSingleProperty(defn, propertyName) {\n                //note: We decided that delete is acceptable here and that we don't need optimization here\n                delete defn.properties[propertyName];\n            }\n            DataViewObjectDefinition.deleteSingleProperty = deleteSingleProperty;\n        })(DataViewObjectDefinition = data.DataViewObjectDefinition || (data.DataViewObjectDefinition = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectDescriptors;\n        (function (DataViewObjectDescriptors) {\n            /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\n            function findFormatString(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\n                });\n            }\n            DataViewObjectDescriptors.findFormatString = findFormatString;\n            /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\n            function findFilterOutput(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && propType.filter && !propType.filter.selfFilter;\n                });\n            }\n            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;\n            /** Attempts to find the self filter property. */\n            function findSelfFilter(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && propType.filter && propType.filter.selfFilter;\n                });\n            }\n            DataViewObjectDescriptors.findSelfFilter = findSelfFilter;\n            /** Attempts to find the self filter enabled property. */\n            function findSelfFilterEnabled(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && propType.operations && propType.operations.searchEnabled;\n                });\n            }\n            DataViewObjectDescriptors.findSelfFilterEnabled = findSelfFilterEnabled;\n            /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\n            function findDefaultValue(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.expression && propType.expression.defaultValue;\n                });\n            }\n            DataViewObjectDescriptors.findDefaultValue = findDefaultValue;\n            function findProperty(descriptors, propPredicate) {\n                debug.assertAnyValue(descriptors, 'descriptors');\n                debug.assertAnyValue(propPredicate, 'propPredicate');\n                if (!descriptors)\n                    return;\n                for (var objectName in descriptors) {\n                    var objPropDescs = descriptors[objectName].properties;\n                    for (var propertyName in objPropDescs) {\n                        if (propPredicate(objPropDescs[propertyName])) {\n                            return {\n                                objectName: objectName,\n                                propertyName: propertyName,\n                            };\n                        }\n                    }\n                }\n            }\n        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n*  Power BI Visualizations\n*\n*  Copyright (c) Microsoft Corporation\n*  All rights reserved.\n *  MIT License\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n*\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n*  THE SOFTWARE.\n*/\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectEvaluationUtils;\n        (function (DataViewObjectEvaluationUtils) {\n            function evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var objects;\n                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {\n                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;\n                    var evaluatedObject = data.DataViewObjectEvaluator.run(evalContext, objectDescriptors[objectName], objectDefinition.properties);\n                    if (!evaluatedObject)\n                        continue;\n                    if (!objects)\n                        objects = {};\n                    // NOTE: this currently has last-object-wins semantics.\n                    objects[objectName] = evaluatedObject;\n                }\n                return objects;\n            }\n            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;\n            function groupObjectsBySelector(objectDefinitions) {\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                var grouped = {\n                    data: [],\n                };\n                if (objectDefinitions) {\n                    for (var objectName in objectDefinitions) {\n                        var objectDefnList = objectDefinitions[objectName];\n                        for (var i = 0, len = objectDefnList.length; i < len; i++) {\n                            var objectDefn = objectDefnList[i];\n                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\n                                name: objectName,\n                                properties: objectDefn.properties,\n                            });\n                        }\n                    }\n                }\n                return grouped;\n            }\n            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;\n            function ensureDefinitionListForSelector(grouped, selector) {\n                debug.assertValue(grouped, 'grouped');\n                debug.assertAnyValue(selector, 'selector');\n                if (!selector) {\n                    if (!grouped.metadataOnce)\n                        grouped.metadataOnce = { objects: [] };\n                    return grouped.metadataOnce;\n                }\n                var groupedObjects;\n                if (selector.data) {\n                    groupedObjects = grouped.data;\n                }\n                else if (selector.metadata) {\n                    if (!grouped.metadata)\n                        grouped.metadata = [];\n                    groupedObjects = grouped.metadata;\n                }\n                else if (selector.id) {\n                    if (!grouped.userDefined)\n                        grouped.userDefined = [];\n                    groupedObjects = grouped.userDefined;\n                }\n                debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\n                for (var _i = 0, groupedObjects_1 = groupedObjects; _i < groupedObjects_1.length; _i++) {\n                    var item_1 = groupedObjects_1[_i];\n                    if (data.Selector.equals(selector, item_1.selector))\n                        return item_1;\n                }\n                var item = {\n                    selector: selector,\n                    objects: [],\n                };\n                groupedObjects.push(item);\n                return item;\n            }\n            function addImplicitObjects(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                if (selectTransforms) {\n                    addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                    addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                }\n            }\n            DataViewObjectEvaluationUtils.addImplicitObjects = addImplicitObjects;\n            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                if (!formatStringProp)\n                    return;\n                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                    var selectTransform = selectTransforms[selectIdx];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\n                }\n            }\n            /** Registers properties for default value, if the properties are not explicitly provided. */\n            function addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var defaultValueProp = data.DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\n                if (!defaultValueProp)\n                    return;\n                for (var _i = 0, selectTransforms_1 = selectTransforms; _i < selectTransforms_1.length; _i++) {\n                    var selectTransform = selectTransforms_1[_i];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyDefaultValue(objectsForAllSelectors, defaultValueProp, selectTransform.queryName, selectTransform.defaultValue);\n                }\n            }\n            function getColumnFormatForIndex(columns, selectIdx) {\n                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\n                    var column = columns[columnIdx];\n                    if (!column || column.index !== selectIdx)\n                        continue;\n                    return column.format;\n                }\n            }\n            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {\n                if (!formatStringValue)\n                    return;\n                // There is a format string specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, formatStringProp, { metadata: queryName }, data.SQExprBuilder.text(formatStringValue));\n            }\n            function applyDefaultValue(objectsForAllSelectors, defaultValueProp, queryName, defaultValue) {\n                if (!defaultValue)\n                    return;\n                // There is a default value specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, defaultValueProp, { metadata: queryName }, defaultValue);\n            }\n            function applyMetadataProperty(objectsForAllSelectors, propertyId, selector, value) {\n                var objectDefns;\n                if (selector) {\n                    var metadataObjects = objectsForAllSelectors.metadata;\n                    if (!metadataObjects)\n                        metadataObjects = objectsForAllSelectors.metadata = [];\n                    objectDefns = metadataObjects;\n                }\n                else {\n                    var metadataOnce = objectsForAllSelectors.metadataOnce;\n                    if (!metadataOnce)\n                        metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\n                    objectDefns = [metadataOnce];\n                }\n                var targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\n                var targetObjectDefn;\n                if (targetMetadataObject) {\n                    var targetObjectDefns = targetMetadataObject.objects;\n                    targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\n                    if (targetObjectDefn) {\n                        if (targetObjectDefn.properties[propertyId.propertyName])\n                            return;\n                    }\n                    else {\n                        targetObjectDefn = {\n                            name: propertyId.objectName,\n                            properties: {},\n                        };\n                        targetObjectDefns.push(targetObjectDefn);\n                    }\n                }\n                else {\n                    targetObjectDefn = {\n                        name: propertyId.objectName,\n                        properties: {}\n                    };\n                    objectDefns.push({\n                        selector: selector,\n                        objects: [targetObjectDefn],\n                    });\n                }\n                targetObjectDefn.properties[propertyId.propertyName] = value;\n            }\n            function findWithMatchingSelector(objects, selector) {\n                debug.assertValue(objects, 'objects');\n                debug.assertAnyValue(selector, 'selector');\n                for (var i = 0, len = objects.length; i < len; i++) {\n                    var object = objects[i];\n                    if (data.Selector.equals(object.selector, selector))\n                        return object;\n                }\n            }\n            function findExistingObject(objectDefns, objectName) {\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(objectName, 'objectName');\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefn = objectDefns[i];\n                    if (objectDefn.name === objectName)\n                        return objectDefn;\n                }\n            }\n        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\n        var DataViewObjectEvaluator;\n        (function (DataViewObjectEvaluator) {\n            var colorValueType = powerbi.ValueType.fromDescriptor({ formatting: { color: true } });\n            var numericType = powerbi.ValueType.fromDescriptor({ numeric: true });\n            var textType = powerbi.ValueType.fromDescriptor({ text: true });\n            function run(evalContext, objectDescriptor, propertyDefinitions) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\n                debug.assertValue(propertyDefinitions, 'propertyDefinitions');\n                if (!objectDescriptor)\n                    return;\n                var object, propertyDescriptors = objectDescriptor.properties;\n                for (var propertyName in propertyDefinitions) {\n                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];\n                    if (!propertyDescriptor)\n                        continue;\n                    var propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\n                    if (propertyValue === undefined)\n                        continue;\n                    if (!object)\n                        object = {};\n                    object[propertyName] = propertyValue;\n                }\n                return object;\n            }\n            DataViewObjectEvaluator.run = run;\n            /** Note: Exported for testability */\n            function evaluateProperty(evalContext, propertyDescriptor, propertyDefinition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(propertyDescriptor, 'propertyDescriptor');\n                debug.assertValue(propertyDefinition, 'propertyDefinition');\n                var structuralType = propertyDescriptor.type;\n                if (structuralType && structuralType.expression)\n                    return propertyDefinition;\n                var value = evaluateValue(evalContext, propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));\n                if (value !== undefined || (propertyDefinition instanceof data.RuleEvaluation))\n                    return value;\n                return evaluateFill(evalContext, propertyDefinition, structuralType)\n                    || evaluateFillRule(evalContext, propertyDefinition, structuralType)\n                    || evaluateImage(evalContext, propertyDefinition, structuralType)\n                    || evaluateParagraphs(evalContext, propertyDefinition, structuralType)\n                    || propertyDefinition;\n            }\n            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;\n            function evaluateFill(evalContext, fillDefn, type) {\n                var fillType = type.fill;\n                if (!fillType)\n                    return;\n                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\n                    return {\n                        solid: {\n                            color: evaluateValue(evalContext, fillDefn.solid.color, powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Color)),\n                        }\n                    };\n                }\n            }\n            function evaluateFillRule(evalContext, fillRuleDefn, type) {\n                if (!type.fillRule)\n                    return;\n                if (fillRuleDefn.linearGradient2) {\n                    var linearGradient2 = fillRuleDefn.linearGradient2;\n                    return {\n                        linearGradient2: {\n                            min: evaluateColorStop(evalContext, linearGradient2.min),\n                            max: evaluateColorStop(evalContext, linearGradient2.max),\n                        }\n                    };\n                }\n                if (fillRuleDefn.linearGradient3) {\n                    var linearGradient3 = fillRuleDefn.linearGradient3;\n                    return {\n                        linearGradient3: {\n                            min: evaluateColorStop(evalContext, linearGradient3.min),\n                            mid: evaluateColorStop(evalContext, linearGradient3.mid),\n                            max: evaluateColorStop(evalContext, linearGradient3.max),\n                        }\n                    };\n                }\n            }\n            function evaluateColorStop(evalContext, colorStop) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(colorStop, 'colorStop');\n                var step = {\n                    color: evaluateValue(evalContext, colorStop.color, colorValueType),\n                };\n                var value = evaluateValue(evalContext, colorStop.value, numericType);\n                if (value != null)\n                    step.value = value;\n                return step;\n            }\n            function evaluateImage(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.image || !definition)\n                    return;\n                var value = {\n                    name: evaluateValue(evalContext, definition.name, textType),\n                    url: evaluateValue(evalContext, definition.url, powerbi.ValueType.fromDescriptor(powerbi.ImageDefinition.urlType)),\n                };\n                if (definition.scaling)\n                    value.scaling = evaluateValue(evalContext, definition.scaling, textType);\n                return value;\n            }\n            function evaluateParagraphs(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.paragraphs || !definition)\n                    return;\n                return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\n            }\n            function evaluateParagraph(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionTextRuns = definition.textRuns;\n                var evaluatedTextRuns = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\n                if (definitionTextRuns !== evaluatedTextRuns) {\n                    evaluated = _.clone(definition);\n                    evaluated.textRuns = evaluatedTextRuns;\n                }\n                return evaluated || definition;\n            }\n            function evaluateTextRun(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionValue = definition.value;\n                var evaluatedValue = evaluateValue(evalContext, definitionValue, textType);\n                if (evaluatedValue !== undefined) {\n                    evaluated = _.clone(definition);\n                    evaluated.value = evaluatedValue;\n                }\n                return evaluated || definition;\n            }\n            /**\n             * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\n             * other than the input to it.\n             */\n            function evaluateArrayCopyOnChange(evalContext, definitions, evaluator) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definitions, 'definitions');\n                debug.assertValue(evaluator, 'evaluator');\n                var evaluatedValues;\n                for (var i = 0, len = definitions.length; i < len; i++) {\n                    var definition = definitions[i];\n                    var evaluated = evaluator(evalContext, definition);\n                    // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\n                    // between TEvaluated & TDefinition\n                    if (!evaluatedValues && definition !== evaluated) {\n                        evaluatedValues = _.take(definitions, i);\n                    }\n                    if (evaluatedValues) {\n                        evaluatedValues.push(evaluated);\n                    }\n                }\n                return evaluatedValues || definitions;\n            }\n            function evaluateValue(evalContext, definition, valueType) {\n                if (definition instanceof data.SQExpr)\n                    return ExpressionEvaluator.evaluate(definition, evalContext);\n                if (definition instanceof data.RuleEvaluation)\n                    return definition.evaluate(evalContext);\n            }\n            /** Responsible for evaluating SQExprs into values. */\n            var ExpressionEvaluator = (function (_super) {\n                __extends(ExpressionEvaluator, _super);\n                function ExpressionEvaluator() {\n                    _super.apply(this, arguments);\n                }\n                ExpressionEvaluator.evaluate = function (expr, evalContext) {\n                    if (expr == null)\n                        return;\n                    return expr.accept(ExpressionEvaluator.instance, evalContext);\n                };\n                ExpressionEvaluator.prototype.visitColumnRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitConstant = function (expr, evalContext) {\n                    return expr.value;\n                };\n                ExpressionEvaluator.prototype.visitMeasureRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitAggr = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitFillRule = function (expr, evalContext) {\n                    var inputValue = expr.input.accept(this, evalContext);\n                    if (inputValue !== undefined) {\n                        var colorAllocator = evalContext.getColorAllocator(expr);\n                        if (colorAllocator) {\n                            return colorAllocator.color(inputValue);\n                        }\n                    }\n                };\n                ExpressionEvaluator.prototype.visitSelectRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.instance = new ExpressionEvaluator();\n                return ExpressionEvaluator;\n            }(data.DefaultSQExprVisitorWithArg));\n        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var DataViewPivotCategorical;\n        (function (DataViewPivotCategorical) {\n            /**\n             * Pivots categories in a categorical DataView into valueGroupings.\n             * This is akin to a mathematical matrix transpose.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                var categorical = dataView.categorical;\n                if (!categorical)\n                    return null;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return null;\n                var values = categorical.values;\n                if (_.isEmpty(values) || values.source)\n                    return null;\n                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];\n                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\n                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];\n                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\n                        var value = values[colIdx], pivotedColumn = inherit(value.source);\n                        // A value has a series group, which is not implemented for pivoting -- just give up.\n                        if (value.identity)\n                            return null;\n                        pivotedColumn.groupName = categoryValue;\n                        var pivotedValue = {\n                            source: pivotedColumn,\n                            values: [value.values[rowIdx]],\n                            identity: categoryIdentity,\n                            min: value.min,\n                            max: value.max,\n                            subtotal: value.subtotal\n                        };\n                        var highlights = value.highlights;\n                        if (highlights) {\n                            pivotedValue.highlights = [highlights[rowIdx]];\n                        }\n                        pivotedColumns.push(pivotedColumn);\n                        pivotedValues.push(pivotedValue);\n                    }\n                }\n                var pivotedMetadata = inherit(dataView.metadata);\n                pivotedMetadata.columns = pivotedColumns;\n                values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields, category.source);\n                return {\n                    metadata: pivotedMetadata,\n                    categorical: {\n                        values: values,\n                    },\n                    matrix: dataView.matrix\n                };\n            }\n            DataViewPivotCategorical.apply = apply;\n        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewPivotMatrix;\n        (function (DataViewPivotMatrix) {\n            /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\n            function apply(dataViewMatrix, context) {\n                debug.assertValue(dataViewMatrix, 'dataViewMatrix');\n                if (!context.columnHierarchyRewritten)\n                    dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);\n                var columns = dataViewMatrix.columns;\n                if (!context.rowHierarchyRewritten)\n                    dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);\n                var rows = dataViewMatrix.rows;\n                if (columns.levels.length > 1)\n                    return;\n                var pivotedRowNode = {\n                    level: 0\n                };\n                var columnLeafNodes = columns.root.children;\n                var measureCount = columnLeafNodes.length;\n                // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\n                // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\n                // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \n                // in a matrix with 2+ column fields and 2+ measure fields.\n                // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\n                // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\n                var pivotResultMeasureHeaderLevel = rows.levels.length;\n                if (measureCount > 0) {\n                    var index_1 = 0;\n                    var callback = function (node) {\n                        // Collect values and remove them from row leaves\n                        if (node.values) {\n                            if (!pivotedRowNode.values)\n                                pivotedRowNode.values = {};\n                            for (var i = 0; i < measureCount; i++)\n                                pivotedRowNode.values[index_1++] = node.values[i];\n                            delete node.values;\n                        }\n                        // Create measure headers if there are more than one measures\n                        if (measureCount > 1) {\n                            if (!node.children)\n                                node.children = [];\n                            for (var j = 0; j < measureCount; j++) {\n                                var measureHeaderLeaf = { level: pivotResultMeasureHeaderLevel };\n                                // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\n                                var columnLeafNode = columnLeafNodes[j];\n                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\n                                if (node.isSubtotal)\n                                    measureHeaderLeaf.isSubtotal = true;\n                                node.children.push(measureHeaderLeaf);\n                            }\n                        }\n                    };\n                    if (context.hierarchyTreesRewritten) {\n                        forEachLeaf(rows.root, callback);\n                    }\n                    else {\n                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\n                    }\n                }\n                else {\n                    if (!context.hierarchyTreesRewritten) {\n                        dataViewMatrix.columns.root = cloneTree(rows.root);\n                    }\n                }\n                if (measureCount > 1) {\n                    // Keep measure headers, but move them to the innermost level\n                    var level = { sources: columns.levels[0].sources };\n                    rows.levels.push(level);\n                    columns.levels.length = 0;\n                }\n                if (context.hierarchyTreesRewritten) {\n                    dataViewMatrix.columns.root = rows.root;\n                    dataViewMatrix.rows.root = {\n                        children: [pivotedRowNode]\n                    };\n                }\n                else {\n                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);\n                    updatedRowRoot.children = [pivotedRowNode];\n                    dataViewMatrix.rows.root = updatedRowRoot;\n                }\n                dataViewMatrix.columns.levels = rows.levels;\n                dataViewMatrix.rows.levels = [];\n            }\n            DataViewPivotMatrix.apply = apply;\n            function forEachLeaf(root, callback) {\n                var children = root.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachLeaf(children[i], callback);\n                    return;\n                }\n                callback(root);\n            }\n            function cloneTree(node) {\n                return cloneTreeExecuteOnLeaf(node);\n            }\n            DataViewPivotMatrix.cloneTree = cloneTree;\n            function cloneTreeExecuteOnLeaf(node, callback) {\n                var updatedNode = powerbi.Prototype.inherit(node);\n                var children = node.children;\n                if (children && children.length > 0) {\n                    var newChildren = [];\n                    for (var i = 0, ilen = children.length; i < ilen; i++) {\n                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\n                        newChildren.push(updatedChild);\n                    }\n                    updatedNode.children = newChildren;\n                }\n                else {\n                    if (callback)\n                        callback(updatedNode);\n                }\n                return updatedNode;\n            }\n            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;\n        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelfCrossJoin;\n        (function (DataViewSelfCrossJoin) {\n            /**\n             * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\n             * to itself as a value grouping.\n             * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                if (!dataView.categorical)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\n                    return;\n                if (dataViewCategorical.values && dataViewCategorical.values.source)\n                    return;\n                return applyCategorical(dataView.metadata, dataViewCategorical);\n            }\n            DataViewSelfCrossJoin.apply = apply;\n            function applyCategorical(dataViewMetadata, dataViewCategorical) {\n                debug.assertValue(dataViewMetadata, 'dataViewMetadata');\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\n                var category = dataViewCategorical.categories[0], categoryValues = category.values, categoryLength = categoryValues.length;\n                if (categoryLength === 0)\n                    return;\n                var valuesArray = dataViewCategorical.values\n                    ? dataViewCategorical.values.grouped()[0].values\n                    : [];\n                var transformedDataView = data.createCategoricalDataViewBuilder()\n                    .withCategories(dataViewCategorical.categories)\n                    .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\n                    .build();\n                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);\n                dataViewMetadata.columns = transformedDataView.metadata.columns;\n                return {\n                    metadata: dataViewMetadata,\n                    categorical: transformedDataView.categorical,\n                };\n            }\n            function createGroupedValues(category, categoryValues, categoryLength, valuesArray) {\n                debug.assertValue(category, 'category');\n                debug.assertValue(categoryValues, 'categoryValues');\n                debug.assertValue(categoryLength, 'categoryLength');\n                debug.assertValue(valuesArray, 'valuesArray');\n                var nullValuesArray = createNullValues(categoryLength), valuesArrayLen = valuesArray.length, seriesData = [];\n                for (var i = 0; i < categoryLength; i++) {\n                    var seriesDataItem = [];\n                    for (var j = 0; j < valuesArrayLen; j++) {\n                        var originalValueColumn = valuesArray[j], originalHighlightValues = originalValueColumn.highlights;\n                        var seriesDataItemCategory = {\n                            values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\n                        };\n                        if (originalHighlightValues)\n                            seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\n                        seriesDataItem.push(seriesDataItemCategory);\n                    }\n                    seriesData.push(seriesDataItem);\n                }\n                return {\n                    groupColumn: {\n                        source: category.source,\n                        identityFrom: { fields: category.identityFields, identities: category.identity },\n                        values: category.values,\n                    },\n                    valueColumns: _.map(valuesArray, function (v) { return { source: v.source }; }),\n                    data: seriesData,\n                };\n            }\n        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));\n        function createNullValues(length) {\n            debug.assertValue(length, 'length');\n            var array = new Array(length);\n            for (var i = 0; i < length; i++)\n                array[i] = null;\n            return array;\n        }\n        function inheritArrayWithValue(nullValues, original, index) {\n            var inherited = powerbi.Prototype.inherit(nullValues);\n            inherited[index] = original[index];\n            return inherited;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewPivotCategoricalToPrimaryGroups;\n        (function (DataViewPivotCategoricalToPrimaryGroups) {\n            /**\n             * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\n             * pivot the secondary before the primary.\n             */\n            function pivotBinding(binding, allMappings, finalMapping, defaultDataVolume) {\n                // unpivot is inferred from result in DataViewTransform.apply but it does not have the\n                // compiled mappings available, let alone the merged mapping, only the original\n                // DataViewMappings. to keep that inference easy, only apply pivot when there's\n                // only one matching mapping\n                if (!allMappings || allMappings.length !== 1)\n                    return;\n                if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\n                    return;\n                if (!binding)\n                    return;\n                if (!canPivotCategorical(binding, finalMapping))\n                    return;\n                // pivot secondary onto front of primary\n                binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\n                binding.Secondary = undefined;\n                // set primary to pivot reduction\n                binding.DataReduction = {\n                    Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\n                    DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\n                };\n            }\n            DataViewPivotCategoricalToPrimaryGroups.pivotBinding = pivotBinding;\n            /** narrowly targets scatter chart scenario for now to keep code simple */\n            function isPivotableAxis(axis) {\n                return axis\n                    && axis.Groupings\n                    && axis.Groupings.length === 1\n                    && !_.isEmpty(axis.Groupings[0].Projections)\n                    && !axis.Groupings[0].Subtotal\n                    && _.isEmpty(axis.Groupings[0].SuppressedProjections);\n            }\n            function canPivotCategorical(binding, mapping) {\n                if (!isPivotableAxis(binding.Primary))\n                    return false;\n                if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\n                    return false;\n                // don't pivot if either axis has a data reduction\n                if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\n                    return false;\n                return true;\n            }\n            function unpivotResult(oldDataView, selects, dataViewMappings, projectionActiveItems) {\n                if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\n                    return oldDataView;\n                // This returns a subsetted version of the DataView rather than using prototypal inheritance because\n                // any dataviews in the old one (including ones invented after this code is written) will correspond\n                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\n                // querying code made.\n                var newDataView = {\n                    metadata: {\n                        columns: ArrayExtensions.copy(oldDataView.metadata.columns),\n                    },\n                };\n                // preserve view types that aren't affected by pivoting\n                if (oldDataView.single)\n                    newDataView.single = oldDataView.single;\n                if (oldDataView.table)\n                    newDataView.table = oldDataView.table;\n                // other views are derived from matrix\n                if (oldDataView.matrix) {\n                    var newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\n                    // categorical only if there's data\n                    if (!_.isEmpty(newDataViewMatrix.valueSources)) {\n                        // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \n                        // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\n                        // this.canPivotCategorical() would have returned false in the first place for this query.\n                        var hasCompositeGroupInSeries = data.utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\n                        if (!hasCompositeGroupInSeries) {\n                            newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\n                        }\n                    }\n                }\n                return newDataView;\n            }\n            DataViewPivotCategoricalToPrimaryGroups.unpivotResult = unpivotResult;\n            /**\n             * Infer from the query result and the visual mappings whether the query was pivoted.\n             * Narrowly targets scatter chart scenario for now to keep code simple\n             */\n            function inferUnpivotTransform(selects, dataViewMappings, dataView, projectionActiveItems) {\n                if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\n                    return false;\n                // select applicable mappings based on select roles\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var supportedDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\n                if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\n                    return false;\n                var categoricalMapping = supportedDataViewMappings[0].categorical;\n                if (!categoricalMapping)\n                    return false;\n                // pivoted query will have produced a matrix\n                var matrixDataview = dataView.matrix;\n                if (!matrixDataview)\n                    return false;\n                // matrix must have two levels of grouping\n                if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\n                    return false;\n                // get category and value grouping roles\n                var categoryGroups = [];\n                var valueGroups = [];\n                var addGroupingRole = function (roleName, groups) {\n                    var roleProjections = projections[roleName];\n                    if (!roleProjections)\n                        return;\n                    for (var _i = 0, _a = roleProjections.all(); _i < _a.length; _i++) {\n                        var roleProjection = _a[_i];\n                        if (roleKinds[roleProjection.queryRef] === powerbi.VisualDataRoleKind.Grouping)\n                            groups.push(roleProjection.queryRef);\n                    }\n                };\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, categoryGroups); }\n                });\n                powerbi.DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, valueGroups); }\n                });\n                // need both for pivot to have been done\n                if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\n                    return false;\n                // if there was a pivot, there won't be any measures left in the columns\n                for (var _i = 0, _a = matrixDataview.columns.levels; _i < _a.length; _i++) {\n                    var level = _a[_i];\n                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {\n                        var source = _c[_b];\n                        if (!source.isMeasure)\n                            return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\n             * this function changes that so that the categories become the rows and the series the columns.\n             */\n            function unpivotMatrix(oldMatrix) {\n                var oldRows = oldMatrix.rows;\n                var oldRoot = oldRows.root;\n                var oldChildren = oldRoot.children;\n                // series are the outer grouping\n                var series = [];\n                var seriesIdLevel = oldRows.levels[0];\n                var seriesIdFields = oldRoot.childIdentityFields;\n                // categories are the inner grouping. \n                var categoryIndex = {};\n                var categories = [];\n                var categoryIdLevel = oldRows.levels[1];\n                var categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\n                var measureCount = oldMatrix.valueSources.length;\n                // within each series value, the category list may not be complete so cannot simply use the inner loop index\n                // to reference it.\n                var findCategory = function (identity) {\n                    var index = categoryIndex[identity.key];\n                    debug.assert(index !== undefined, \"findcat() !== undefined\");\n                    return index;\n                };\n                // collect series and categories from the row hierarchy\n                if (oldChildren) {\n                    var addCategory = function (categoryNode) {\n                        var key = categoryNode.identity.key;\n                        var index = categoryIndex[key];\n                        if (index === undefined) {\n                            index = categories.length;\n                            categoryIndex[key] = index;\n                            categories.push(categoryNode);\n                        }\n                    };\n                    for (var _i = 0, oldChildren_1 = oldChildren; _i < oldChildren_1.length; _i++) {\n                        var seriesNode = oldChildren_1[_i];\n                        series.push(seriesNode);\n                        for (var _a = 0, _b = seriesNode.children; _a < _b.length; _a++) {\n                            var categoryNode = _b[_a];\n                            addCategory(categoryNode);\n                        }\n                    }\n                }\n                // extract intersection values from pivoted matrix\n                // values will be indexed by categories then series\n                var matrixValues = new Array(categories.length);\n                for (var j = 0; j < series.length; ++j) {\n                    var seriesNode = oldChildren[j];\n                    for (var _c = 0, _d = seriesNode.children; _c < _d.length; _c++) {\n                        var categoryNode = _d[_c];\n                        var i = findCategory(categoryNode.identity); // must lookup actual category index\n                        if (!matrixValues[i])\n                            matrixValues[i] = new Array(series.length);\n                        matrixValues[i][j] = categoryNode.values;\n                    }\n                }\n                // columns of the unpivoted matrix are the series\n                var newColumns = {\n                    root: {\n                        children: _.map(series, function (s) {\n                            var inheritedNode = inheritSingle(s);\n                            inheritedNode.level = 0; // s.level should already be 0, but just in case...\n                            inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\n                            inheritedNode.childIdentityFields = undefined;\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: seriesIdFields,\n                    },\n                    levels: [\n                        seriesIdLevel,\n                    ],\n                };\n                // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\n                if (measureCount > 0) {\n                    var newColChildren = _.map(oldMatrix.columns.root.children, function (srcnode) {\n                        var dstnode = { level: 1 };\n                        if (srcnode.levelSourceIndex)\n                            dstnode.levelSourceIndex = srcnode.levelSourceIndex;\n                        return dstnode;\n                    });\n                    for (var i = 0; i < newColumns.root.children.length; ++i)\n                        newColumns.root.children[i].children = newColChildren;\n                    newColumns.levels.push(oldMatrix.columns.levels[0]);\n                }\n                // rows of the unpivoted matrix are the categories\n                var newRows = {\n                    root: {\n                        children: _.map(categories, function (c) {\n                            var inheritedNode = inheritSingle(c);\n                            inheritedNode.level = 0;\n                            inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\n                            inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: categoryIdFields,\n                    },\n                    levels: [\n                        categoryIdLevel,\n                    ],\n                };\n                // put values into rows\n                if (measureCount > 0) {\n                    for (var i = 0; i < categories.length; ++i) {\n                        var row = newRows.root.children[i];\n                        var rowValues = {};\n                        for (var j = 0; j < series.length; ++j) {\n                            var mvalues = matrixValues[i] && matrixValues[i][j];\n                            for (var k = 0; k < measureCount; ++k) {\n                                var l = j * measureCount + k;\n                                rowValues[l] = !mvalues\n                                    ? (k === 0 ? { value: null } : { value: null, valueSourceIndex: k })\n                                    : mvalues[k];\n                            }\n                        }\n                        row.values = rowValues;\n                    }\n                }\n                var newMatrix = {\n                    rows: newRows,\n                    columns: newColumns,\n                    valueSources: oldMatrix.valueSources,\n                };\n                return newMatrix;\n            }\n            /** build a categorical data view from an unpivoted matrix. */\n            function categoricalFromUnpivotedMatrix(matrix, columnMetadata) {\n                var seriesCount = matrix.columns.root.children.length;\n                var measureMetadata = matrix.valueSources;\n                var measureCount = measureMetadata.length;\n                var categories = createCategoryColumnsFromUnpivotedMatrix(matrix);\n                // create grouped values\n                var groups = [];\n                for (var j = 0; j < seriesCount; ++j) {\n                    var seriesColumn = matrix.columns.root.children[j];\n                    var group = {\n                        values: [],\n                        identity: seriesColumn.identity,\n                        name: seriesColumn.value || null,\n                    };\n                    groups.push(group);\n                    for (var k = 0; k < measureCount; ++k) {\n                        var valueColumnMetadataSrc = measureMetadata[k];\n                        var valueColumnMetadataDst = {};\n                        for (var key in valueColumnMetadataSrc)\n                            valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\n                        valueColumnMetadataDst.groupName = group.name;\n                        columnMetadata.push(valueColumnMetadataDst);\n                        var valueColumn = {\n                            source: valueColumnMetadataDst,\n                            values: [],\n                            identity: group.identity,\n                        };\n                        group.values.push(valueColumn);\n                        // grab measure values in the group from across rows of matrix\n                        var index = k + j * measureCount;\n                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {\n                            var categoryNode = _a[_i];\n                            var value = categoryNode.values[index].value;\n                            valueColumn.values.push(value);\n                        }\n                    }\n                }\n                // and now ungrouped\n                var values = [];\n                for (var _b = 0, groups_1 = groups; _b < groups_1.length; _b++) {\n                    var group = groups_1[_b];\n                    for (var k = 0; k < measureCount; ++k) {\n                        values.push(group.values[k]);\n                    }\n                }\n                values.grouped = function () { return groups; };\n                values.identityFields = matrix.columns.root.childIdentityFields;\n                values.source = matrix.columns.levels[0].sources[0];\n                // final assembly\n                var categorical = {\n                    categories: categories,\n                    values: values,\n                };\n                return categorical;\n            }\n            function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix) {\n                debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\n                debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1), 'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\n                // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \n                // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \n                // same amongst the resulting DataViewCategoryColumns.\n                var categoryIdentity = _.map(unpivotedMatrix.rows.root.children, function (x) { return x.identity; });\n                var categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\n                var categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\n                var categories = [];\n                for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\n                    var groupLevelValues = _.map(unpivotedMatrix.rows.root.children, function (categoryNode) {\n                        var levelValues = categoryNode.levelValues;\n                        // Please refer to the interface comments on when this is undefined... But in today's code\n                        // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \n                        if (levelValues !== undefined) {\n                            debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i), 'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\n                            return levelValues[i].value;\n                        }\n                    });\n                    categories.push({\n                        source: categorySourceColumns[i],\n                        values: groupLevelValues,\n                        identity: categoryIdentity,\n                        identityFields: categoryIdentityFields,\n                    });\n                }\n                return categories;\n            }\n        })(DataViewPivotCategoricalToPrimaryGroups = data.DataViewPivotCategoricalToPrimaryGroups || (data.DataViewPivotCategoricalToPrimaryGroups = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var EnumExtensions = jsCommon.EnumExtensions;\n        // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\n        var DataViewTransform;\n        (function (DataViewTransform) {\n            var fillRulePropertyDescriptor = { type: { fillRule: {} } };\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\n                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, dataViewMappings = options.dataViewMappings, transforms = options.transforms, projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems, colorAllocatorFactory = options.colorAllocatorFactory, dataRoles = options.dataRoles;\n                if (!prototype)\n                    return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\n                if (!transforms)\n                    return [prototype];\n                // Transform Query DataView\n                prototype = data.DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\n                var visualDataViews = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\n                // Transform and generate derived visual DataViews\n                visualDataViews = data.DataViewRegression.run({\n                    dataViewMappings: dataViewMappings,\n                    visualDataViews: visualDataViews,\n                    dataRoles: dataRoles,\n                    objectDescriptors: objectDescriptors,\n                    objectDefinitions: transforms.objects,\n                    colorAllocatorFactory: colorAllocatorFactory,\n                    transformSelects: transforms.selects,\n                    metadata: prototype.metadata,\n                    projectionActiveItems: projectionActiveItems,\n                });\n                return visualDataViews;\n            }\n            DataViewTransform.apply = apply;\n            function transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles) {\n                var transformedDataViews = [];\n                var splits = transforms.splits;\n                if (_.isEmpty(splits)) {\n                    transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\n                }\n                else {\n                    for (var _i = 0, splits_1 = splits; _i < splits_1.length; _i++) {\n                        var split = splits_1[_i];\n                        var transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\n                        transformedDataViews.push(transformed);\n                    }\n                }\n                return transformedDataViews;\n            }\n            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {\n                if (transforms && transforms.objects) {\n                    var emptyDataView = {\n                        metadata: {\n                            columns: [],\n                        }\n                    };\n                    transformObjects(emptyDataView, 0 /* None */, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                    return [emptyDataView];\n                }\n                return [];\n            }\n            function transformDataView(prototype, objectDescriptors, roleMappings, transforms, colorAllocatorFactory, dataRoles, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(transforms, 'transforms');\n                debug.assert(!selectsToInclude ||\n                    _.filter(Object.keys(selectsToInclude), function (selectIndex) { return selectsToInclude[selectIndex] && (!transforms.selects || !transforms.selects[selectIndex]); })\n                        .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0\n                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');\n                var targetKinds = getTargetKinds(roleMappings);\n                var transformed = inherit(prototype);\n                transformed.metadata = inherit(prototype.metadata);\n                var projectionOrdering = transforms.roles && transforms.roles.ordering;\n                var projectionActiveItems = transforms.roles && transforms.roles.activeItems;\n                transformed = transformSelects(transformed, targetKinds, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\n                transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\n                transformed = data.DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\n                data.DataViewNormalizeValues.apply({\n                    dataview: transformed,\n                    dataViewMappings: roleMappings,\n                    dataRoles: dataRoles,\n                });\n                return transformed;\n            }\n            function getTargetKinds(roleMappings) {\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                if (!roleMappings)\n                    return 0 /* None */;\n                var result = 0 /* None */;\n                for (var _i = 0, roleMappings_1 = roleMappings; _i < roleMappings_1.length; _i++) {\n                    var roleMapping = roleMappings_1[_i];\n                    if (roleMapping.categorical)\n                        result |= 1 /* Categorical */;\n                    if (roleMapping.matrix)\n                        result |= 2 /* Matrix */;\n                    if (roleMapping.single)\n                        result |= 4 /* Single */;\n                    if (roleMapping.table)\n                        result |= 8 /* Table */;\n                    if (roleMapping.tree)\n                        result |= 16 /* Tree */;\n                }\n                return result;\n            }\n            function transformSelects(dataView, targetDataViewKinds, roleMappings, selectTransforms, projectionOrdering, selectsToInclude) {\n                var columnRewrites = [];\n                if (selectTransforms) {\n                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);\n                }\n                // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\n                if (dataView.categorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    // NOTE: This is slightly DSR-specific.\n                    dataView = pivotIfNecessary(dataView, roleMappings);\n                }\n                // Don't perform this potentially expensive transform unless we actually have a matrix.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (dataView.matrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var matrixTransformationContext = {\n                        rowHierarchyRewritten: false,\n                        columnHierarchyRewritten: false,\n                        hierarchyTreesRewritten: false\n                    };\n                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    if (shouldPivotMatrix(dataView.matrix, roleMappings))\n                        data.DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\n                }\n                // Don't perform this potentially expensive transform unless we actually have a table.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (dataView.table && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    dataView.table = applyRewritesToTable(dataView.table, columnRewrites, projectionOrdering);\n                }\n                return dataView;\n            }\n            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {\n                debug.assertValue(prototypeColumns, 'columns');\n                if (!selects)\n                    return prototypeColumns;\n                //column may contain undefined entries\n                var columns = inherit(prototypeColumns);\n                for (var i = 0, len = prototypeColumns.length; i < len; i++) {\n                    var prototypeColumn = prototypeColumns[i];\n                    var select = selects[prototypeColumn.index];\n                    if (!select)\n                        continue;\n                    var column = columns[i] = inherit(prototypeColumn);\n                    if (select.roles)\n                        column.roles = select.roles;\n                    if (select.type)\n                        column.type = select.type;\n                    column.format = getFormatForColumn(select, column);\n                    if (select.displayName)\n                        column.displayName = select.displayName;\n                    if (select.queryName)\n                        column.queryName = select.queryName;\n                    if (select.kpi)\n                        column.kpi = select.kpi;\n                    if (select.sort)\n                        column.sort = select.sort;\n                    if (select.discourageAggregationAcrossGroups)\n                        column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\n                    rewrites.push({\n                        from: prototypeColumn,\n                        to: column,\n                    });\n                }\n                return columns;\n            }\n            /**\n             * Get the column format. Order of precendence is:\n             *  1. Select format\n             *  2. Column format\n             */\n            function getFormatForColumn(select, column) {\n                // TODO: we already copied the select.Format to column.format, we probably don't need this check\n                return select.format || column.format;\n            }\n            function applyRewritesToCategorical(prototype, columnRewrites, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var categorical = inherit(prototype);\n                function override(value) {\n                    var rewrittenSource = findOverride(value.source, columnRewrites);\n                    if (rewrittenSource) {\n                        var rewritten = inherit(value);\n                        rewritten.source = rewrittenSource;\n                        return rewritten;\n                    }\n                }\n                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);\n                if (categories)\n                    categorical.categories = categories;\n                var valuesOverride = powerbi.Prototype.overrideArray(prototype.values, override);\n                var valueColumns = valuesOverride || prototype.values;\n                if (valueColumns) {\n                    if (valueColumns.source) {\n                        if (selectsToInclude && !selectsToInclude[valueColumns.source.index]) {\n                            // if processing a split and this is the split without series...\n                            valueColumns.source = undefined;\n                        }\n                        else {\n                            var rewrittenValuesSource = findOverride(valueColumns.source, columnRewrites);\n                            if (rewrittenValuesSource)\n                                valueColumns.source = rewrittenValuesSource;\n                        }\n                    }\n                    if (selectsToInclude) {\n                        // Apply selectsToInclude to values by removing value columns not included\n                        for (var i = valueColumns.length - 1; i >= 0; i--) {\n                            if (!selectsToInclude[valueColumns[i].source.index]) {\n                                valueColumns.splice(i, 1);\n                            }\n                        }\n                    }\n                    var isDynamicSeries_1 = !!valueColumns.source;\n                    debug.assert((prototype.values.length === 1) && (_.isEmpty(prototype.values[0].values)) ||\n                        _.every(valueColumns, function (valueColumn) { return isDynamicSeries_1 === !!valueColumn.identity; }), 'After applying selectsToInclude, all remaining DataViewValueColumn objects should have a consistent scope type (static vs. dynamic) with the parent DataViewValueColumns object.');\n                    // Dynamic or not, always update the return values of grouped() to have the rewritten 'source' property\n                    var seriesGroups_1;\n                    if (isDynamicSeries_1) {\n                        // We have a dynamic series, so update the return value of grouped() to have the DataViewValueColumn objects with rewritten 'source'.\n                        // Also, exclude any column that belongs to a static series.\n                        seriesGroups_1 = inherit(valueColumns.grouped());\n                        var nextSeriesGroupIndex = 0;\n                        var currentSeriesGroup = void 0;\n                        for (var i = 0, ilen = valueColumns.length; i < ilen; i++) {\n                            var currentValueColumn = valueColumns[i];\n                            if (!currentSeriesGroup || (currentValueColumn.identity !== currentSeriesGroup.identity)) {\n                                currentSeriesGroup = inherit(seriesGroups_1[nextSeriesGroupIndex]);\n                                seriesGroups_1[nextSeriesGroupIndex] = currentSeriesGroup;\n                                currentSeriesGroup.values = [];\n                                nextSeriesGroupIndex++;\n                                debug.assert(currentValueColumn.identity === currentSeriesGroup.identity, 'expecting the value columns are sequenced by series groups');\n                            }\n                            currentSeriesGroup.values.push(currentValueColumn);\n                        }\n                    }\n                    else {\n                        // We are in a static series, so we should throw away the grouped and recreate it using the static values\n                        //   which have already been filtered\n                        seriesGroups_1 = [{ values: valueColumns }];\n                    }\n                    valueColumns.grouped = function () { return seriesGroups_1; };\n                    categorical.values = valueColumns;\n                }\n                return categorical;\n            }\n            function applyRewritesToTable(prototype, columnRewrites, projectionOrdering) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var table = inherit(prototype);\n                // Copy the rewritten columns into the table view\n                var override = function (metadata) { return findOverride(metadata, columnRewrites); };\n                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);\n                if (columns)\n                    table.columns = columns;\n                if (!projectionOrdering)\n                    return table;\n                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\n                if (!newToOldPositions)\n                    return table;\n                // Reorder the columns\n                var columnsClone = columns.slice(0);\n                var keys = Object.keys(newToOldPositions);\n                for (var i = 0, len = keys.length; i < len; i++) {\n                    var sourceColumn = columnsClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === columns.length)\n                        columns.push(sourceColumn);\n                    else {\n                        debug.assert(i < columns.length, 'The column index is out of range for reordering.');\n                        columns[i] = sourceColumn;\n                    }\n                }\n                // Reorder the rows\n                var rows = powerbi.Prototype.overrideArray(table.rows, function (row) {\n                    var newRow = [];\n                    for (var i = 0, len = keys.length; i < len; ++i)\n                        newRow[i] = row[newToOldPositions[keys[i]]];\n                    return newRow;\n                });\n                if (rows)\n                    table.rows = rows;\n                return table;\n            }\n            /** Creates a mapping of new position to original position. */\n            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {\n                var roles = Object.keys(projectionOrdering);\n                // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\n                if (roles.length !== 1)\n                    return;\n                var role = roles[0], originalOrder = _.map(columnRewrites, function (rewrite) { return rewrite.from.index; }), newOrder = projectionOrdering[role];\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            function applyRewritesToMatrix(prototype, columnRewrites, roleMappings, projectionOrdering, context) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                debug.assertValue(roleMappings, 'roleMappings');\n                var firstRoleMappingWithMatrix = _.find(roleMappings, function (roleMapping) { return !!roleMapping.matrix; });\n                debug.assertValue(firstRoleMappingWithMatrix, 'roleMappings - at least one role mapping is expected to target DataViewMatrix');\n                var matrixMapping = firstRoleMappingWithMatrix.matrix;\n                var matrix = inherit(prototype);\n                function override(metadata) {\n                    return findOverride(metadata, columnRewrites);\n                }\n                function overrideHierarchy(hierarchy) {\n                    var rewrittenHierarchy = null;\n                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, function (level) {\n                        var newLevel = null;\n                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);\n                        if (levelSources)\n                            newLevel = ensureRewritten(newLevel, level, function (h) { return h.sources = levelSources; });\n                        return newLevel;\n                    });\n                    if (newLevels)\n                        rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, function (r) { return r.levels = newLevels; });\n                    return rewrittenHierarchy;\n                }\n                var rows = overrideHierarchy(matrix.rows);\n                if (rows) {\n                    matrix.rows = rows;\n                    context.rowHierarchyRewritten = true;\n                }\n                var columns = overrideHierarchy(matrix.columns);\n                if (columns) {\n                    matrix.columns = columns;\n                    context.columnHierarchyRewritten = true;\n                }\n                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);\n                if (valueSources) {\n                    matrix.valueSources = valueSources;\n                    // Only need to reorder if we have more than one value source, and they are all bound to the same role\n                    var matrixValues = matrixMapping.values;\n                    if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\n                        var columnLevels = columns.levels.length;\n                        if (columnLevels > 0) {\n                            var newToOldPositions_1 = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\n                            if (newToOldPositions_1) {\n                                var keys_1 = Object.keys(newToOldPositions_1);\n                                var numKeys_1 = keys_1.length;\n                                // Reorder the value columns\n                                columns.root = data.DataViewPivotMatrix.cloneTree(columns.root);\n                                if (columnLevels === 1)\n                                    reorderChildNodes(columns.root, newToOldPositions_1);\n                                else\n                                    forEachNodeAtLevel(columns.root, columnLevels - 2, function (node) { return reorderChildNodes(node, newToOldPositions_1); });\n                                // Reorder the value rows\n                                matrix.rows.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, function (node) {\n                                    if (!node.values)\n                                        return;\n                                    var newValues = {};\n                                    var iterations = Object.keys(node.values).length / numKeys_1;\n                                    for (var i = 0, len = iterations; i < len; i++) {\n                                        var offset = i * numKeys_1;\n                                        for (var keysIndex = 0; keysIndex < numKeys_1; keysIndex++)\n                                            newValues[offset + keysIndex] = node.values[offset + newToOldPositions_1[keys_1[keysIndex]]];\n                                    }\n                                    node.values = newValues;\n                                });\n                                context.hierarchyTreesRewritten = true;\n                            }\n                        }\n                    }\n                }\n                reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\n                return matrix;\n            }\n            function reorderChildNodes(node, newToOldPositions) {\n                var keys = Object.keys(newToOldPositions);\n                var numKeys = keys.length;\n                var children = node.children;\n                var childrenClone = children.slice(0);\n                for (var i = 0, len = numKeys; i < len; i++) {\n                    var sourceColumn = childrenClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === children.length)\n                        children.push(sourceColumn);\n                    else {\n                        debug.assert(i < children.length, 'The column index is out of range for reordering.');\n                        children[i] = sourceColumn;\n                    }\n                }\n            }\n            /**\n             * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\n             * and values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified prototype is necessary.\n             */\n            function reorderMatrixCompositeGroups(prototype, supportedDataViewMapping, projection) {\n                var transformedDataView;\n                if (prototype && supportedDataViewMapping && projection) {\n                    // reorder levelValues in any composite groups in rows hierarchy\n                    var transformedRowsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\n                        visitRole: function (role, context) {\n                            transformedRowsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedRowsHierarchy_1 || prototype.rows, role, projection);\n                        }\n                    });\n                    // reorder levelValues in any composite groups in columns hierarchy\n                    var transformedColumnsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\n                        visitRole: function (role, context) {\n                            transformedColumnsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedColumnsHierarchy_1 || prototype.columns, role, projection);\n                        }\n                    });\n                    if (transformedRowsHierarchy_1 || transformedColumnsHierarchy_1) {\n                        transformedDataView = inheritSingle(prototype);\n                        transformedDataView.rows = transformedRowsHierarchy_1 || transformedDataView.rows;\n                        transformedDataView.columns = transformedColumnsHierarchy_1 || transformedDataView.columns;\n                    }\n                }\n                return transformedDataView;\n            }\n            /**\n             * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\n             * values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\n             */\n            function reorderMatrixHierarchyCompositeGroups(matrixHierarchy, hierarchyRole, projection) {\n                debug.assertValue(matrixHierarchy, 'matrixHierarchy');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                var transformedHierarchy;\n                var selectIndicesInProjectionOrder = projection[hierarchyRole];\n                // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\n                var hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\n                if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\n                    for (var i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\n                        var hierarchyLevel = matrixHierarchy.levels[i];\n                        // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\n                        var newToOldLevelSourceIndicesMapping = createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\n                        if (newToOldLevelSourceIndicesMapping) {\n                            if (_.isUndefined(transformedHierarchy)) {\n                                // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\n                                // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\n                                transformedHierarchy = inheritSingle(matrixHierarchy);\n                                transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\n                                // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\n                                // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\n                                // happen in other hierarchy levels in the later iterations of this for-loop.\n                                transformedHierarchy.root = data.utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\n                            }\n                            // reorder the metadata columns in the sources array at that level\n                            var transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\n                            transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\n                            // reorder the level values in the composite group nodes at the current hierarchy level\n                            reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\n                        }\n                    }\n                }\n                return transformedHierarchy;\n            }\n            /**\n             * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\n             * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\n             *\n             * The returned value maps level source indices from the new target order (calculated from projection order)\n             * back to the original order as they appear in the specified hierarchyLevel's sources.\n             * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\n             *\n             * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\n             *\n             * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\n             * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\n             * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\n             */\n            function createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\n                var newToOldLevelSourceIndicesMapping;\n                var levelSourceColumns = hierarchyLevel.sources;\n                if (levelSourceColumns && levelSourceColumns.length >= 2) {\n                    // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\n                    var columnsForHierarchyRoleOrderedByLevelSourceIndex = data.utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(levelSourceColumns, projection, hierarchyRole);\n                    if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\n                        // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\n                        var columnsForHierarchyRoleOrderedByProjection = _.sortBy(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.projectionOrderIndex; });\n                        newToOldLevelSourceIndicesMapping = createOrderMapping(_.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.sourceIndex; }), _.map(columnsForHierarchyRoleOrderedByProjection, function (columnInfo) { return columnInfo.sourceIndex; }));\n                    }\n                }\n                return newToOldLevelSourceIndicesMapping;\n            }\n            /**\n             * Applies re-ordering on the specified transformingHierarchyLevel's sources.\n             * Returns the same object as the specified transformingHierarchyLevel.\n             */\n            function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var originalLevelSources = transformingHierarchyLevel.sources;\n                transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\n                var newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\n                for (var i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\n                    var newLevelSourceIndex = newLevelSourceIndices[i];\n                    var oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\n                    debug.assert(oldLevelSourceIndex < originalLevelSources.length, 'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\n                    transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\n                }\n                return transformingHierarchyLevel;\n            }\n            /**\n             * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\n             * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\n             *\n             * Returns the same object as the specified transformingHierarchyRootNode.\n             */\n            function reorderMatrixHierarchyLevelValues(transformingHierarchyRootNode, transformingHierarchyLevelIndex, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var oldToNewLevelSourceIndicesMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\n                forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, function (transformingMatrixNode) {\n                    var originalLevelValues = transformingMatrixNode.levelValues;\n                    // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\n                    // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\n                    // The following code isn't correct in the special case where a column is projected twice in this composite group,\n                    // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\n                    // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\n                    if (!_.isEmpty(originalLevelValues)) {\n                        // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\n                        // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\n                        // because we don't want to accidentally modify the array AND its value references in Query DataView\n                        var newlyOrderedLevelValues = _.sortBy(originalLevelValues, function (levelValue) { return oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]; });\n                        for (var i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\n                            var transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\n                            transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\n                            newlyOrderedLevelValues[i] = transformingLevelValue;\n                        }\n                        transformingMatrixNode.levelValues = newlyOrderedLevelValues;\n                        // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\n                        // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\n                        var newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\n                        if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\n                            transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\n                        }\n                        if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\n                            transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\n                        }\n                    }\n                });\n                return transformingHierarchyRootNode;\n            }\n            /**\n             * Creates a mapping of new position to original position.\n             *\n             * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\n             * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\n             * - the value in the key-value pair is the index of the particular column in the original order\n             */\n            function createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites) {\n                var role = matrixValues.for.in;\n                var newOrder = projectionOrdering[role];\n                var originalOrder = _.chain(columnRewrites)\n                    .filter(function (rewrite) { return _.contains(valueSources, rewrite.to); })\n                    .map(function (rewrite) { return rewrite.from.index; })\n                    .value();\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            /**\n             * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\n             * originalOrder array.\n             * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\n             * under the context of the caller code), e.g. the Select Index in projection ordering array.\n             * Also, the specified originalOrder must contain every value that exists in newOrder.\n             *\n             * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\n             * key-value pair, each of which represents the new and old indices of a particular column:\n             * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\n             * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\n             *\n             * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\n             *\n             * If the specified originalOrder and newOrder are same, then this function returns undefined.\n             *\n             * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\n             * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\n             */\n            function createOrderMapping(originalOrder, newOrder) {\n                // Optimization: avoid rewriting if the current order is correct\n                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function (x, y) { return x === y; }))\n                    return;\n                var mapping = {};\n                for (var i = 0, len = newOrder.length; i < len; ++i) {\n                    var newPosition = newOrder[i];\n                    mapping[i] = originalOrder.indexOf(newPosition);\n                }\n                return mapping;\n            }\n            function createReversedMapping(mapping) {\n                debug.assertValue(mapping, 'mapping');\n                var reversed = {};\n                for (var key in mapping) {\n                    // Note: key is a string after we get it out from mapping, thus we need to parse it\n                    // back into a number before putting it as the value in the reversed mapping\n                    var value = mapping[key];\n                    var keyAsNumber = parseInt(key, 10);\n                    reversed[value] = keyAsNumber;\n                }\n                debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length, 'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\n                return reversed;\n            }\n            function forEachNodeAtLevel(node, targetLevel, callback) {\n                debug.assertValue(node, 'node');\n                debug.assert(targetLevel >= 0, 'argetLevel >= 0');\n                debug.assertValue(callback, 'callback');\n                if (node.level === targetLevel) {\n                    callback(node);\n                    return;\n                }\n                var children = node.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachNodeAtLevel(children[i], targetLevel, callback);\n                }\n            }\n            DataViewTransform.forEachNodeAtLevel = forEachNodeAtLevel;\n            function findOverride(source, columnRewrites) {\n                for (var i = 0, len = columnRewrites.length; i < len; i++) {\n                    var columnRewrite = columnRewrites[i];\n                    if (columnRewrite.from === source)\n                        return columnRewrite.to;\n                }\n            }\n            function ensureRewritten(rewritten, prototype, callback) {\n                if (!rewritten)\n                    rewritten = inherit(prototype);\n                if (callback)\n                    callback(rewritten);\n                return rewritten;\n            }\n            function transformObjects(dataView, targetDataViewKinds, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!objectDescriptors)\n                    return;\n                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\n                data.DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\n                var metadataOnce = objectsForAllSelectors.metadataOnce;\n                var dataObjects = objectsForAllSelectors.data;\n                if (metadataOnce)\n                    evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\n                var metadataObjects = objectsForAllSelectors.metadata;\n                if (metadataObjects) {\n                    for (var i = 0, len = metadataObjects.length; i < len; i++) {\n                        var metadataObject = metadataObjects[i];\n                        var objectDefns = metadataObject.objects;\n                        var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                        evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\n                    }\n                }\n                for (var i = 0, len = dataObjects.length; i < len; i++) {\n                    var dataObject = dataObjects[i];\n                    var objectDefns = dataObject.objects;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                    evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\n                }\n                var userDefined = objectsForAllSelectors.userDefined;\n                if (userDefined) {\n                    // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\n                    evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\n                }\n            }\n            DataViewTransform.transformObjects = transformObjects;\n            function evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var dataViewObjects = dataView.metadata.objects;\n                if (!dataViewObjects) {\n                    dataViewObjects = dataView.metadata.objects = {};\n                }\n                for (var _i = 0, objectDefns_1 = objectDefns; _i < objectDefns_1.length; _i++) {\n                    var objectDefn = objectDefns_1[_i];\n                    var id = objectDefn.selector.id;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\n                    var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                    var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\n                    for (var objectName in objects) {\n                        var object = objects[objectName];\n                        var map = dataViewObjects[objectName];\n                        if (!map)\n                            map = dataViewObjects[objectName] = [];\n                        debug.assert(powerbi.DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\n                        // NOTE: We do not check for duplicate ids.\n                        map.push({ id: id, object: object });\n                    }\n                }\n            }\n            /** Evaluates and sets properties on the DataView metadata. */\n            function evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, objectDefns, dataObjects, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(dataObjects, 'dataObjects');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                if (objects) {\n                    dataView.metadata.objects = objects;\n                    for (var objectName in objects) {\n                        var object = objects[objectName], objectDesc = objectDescriptors[objectName];\n                        for (var propertyName in object) {\n                            var propertyDesc = objectDesc.properties[propertyName], ruleDesc = propertyDesc.rule;\n                            if (!ruleDesc)\n                                continue;\n                            var definition = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type);\n                            if (!definition)\n                                continue;\n                            dataObjects.push(definition);\n                        }\n                    }\n                }\n            }\n            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(propertyValue, 'propertyValue');\n                debug.assertValue(ruleType, 'ruleType');\n                var ruleOutput = ruleDesc.output;\n                if (!ruleOutput)\n                    return;\n                var selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\n                if (!selectorToCreate)\n                    return;\n                if (ruleType.fillRule) {\n                    return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue);\n                }\n            }\n            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(selectorToCreate, 'selectorToCreate');\n                debug.assertValue(propertyValue, 'propertyValue');\n                var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, 1 /* Role */, propertyValue);\n                if (!colorAllocator)\n                    return;\n                var rule = new data.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\n                var fillRuleProperties = {};\n                fillRuleProperties[ruleDesc.output.property] = {\n                    solid: { color: rule }\n                };\n                return {\n                    selector: selectorToCreate,\n                    rules: [rule],\n                    objects: [{\n                            name: objectName,\n                            properties: fillRuleProperties,\n                        }]\n                };\n            }\n            function tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(propertyValue, 'propertyValue');\n                if (propertyValue.linearGradient2)\n                    return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\n                if (propertyValue.linearGradient3)\n                    return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\n            }\n            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient2) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient2, 'linearGradient2');\n                linearGradient2 = propertyValueFillRule.linearGradient2;\n                if (linearGradient2.min.value === undefined ||\n                    linearGradient2.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    if (linearGradient2.min.value === undefined)\n                        linearGradient2.min.value = inputRange.min;\n                    if (linearGradient2.max.value === undefined)\n                        linearGradient2.max.value = inputRange.max;\n                }\n                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\n            }\n            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient3) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient3, 'linearGradient3');\n                var splitScales;\n                linearGradient3 = propertyValueFillRule.linearGradient3;\n                if (linearGradient3.min.value === undefined ||\n                    linearGradient3.mid.value === undefined ||\n                    linearGradient3.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    splitScales =\n                        linearGradient3.min.value === undefined &&\n                            linearGradient3.max.value === undefined &&\n                            linearGradient3.mid.value !== undefined;\n                    if (linearGradient3.min.value === undefined) {\n                        linearGradient3.min.value = inputRange.min;\n                    }\n                    if (linearGradient3.max.value === undefined) {\n                        linearGradient3.max.value = inputRange.max;\n                    }\n                    if (linearGradient3.mid.value === undefined) {\n                        var midValue = (linearGradient3.max.value + linearGradient3.min.value) / 2;\n                        linearGradient3.mid.value = midValue;\n                    }\n                }\n                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\n            }\n            function populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var cache = data.createColorAllocatorCache();\n                var staticEvalContext = data.createStaticEvalContext();\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefnProperties = objectDefns[i].properties;\n                    for (var propertyName in objectDefnProperties) {\n                        var fillProperty = objectDefnProperties[propertyName];\n                        if (fillProperty &&\n                            fillProperty.solid &&\n                            fillProperty.solid.color &&\n                            fillProperty.solid.color.kind === 23 /* FillRule */) {\n                            var fillRuleExpr = fillProperty.solid.color;\n                            var inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\n                            if (!inputExprQueryName)\n                                continue;\n                            var fillRule = data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, fillRulePropertyDescriptor, fillRuleExpr.rule);\n                            var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, 0 /* QueryName */, fillRule);\n                            if (colorAllocator)\n                                cache.register(fillRuleExpr, colorAllocator);\n                        }\n                    }\n                }\n                return cache;\n            }\n            function evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, selector, rules, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\n                var containsWildcard = data.Selector.containsWildcard(selector);\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    // 1) Match against categories\n                    evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    // 2) Match against valueGrouping\n                    evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                }\n                var dataViewMatrix = dataView.matrix;\n                if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenMatrix) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.matrix = rewrittenMatrix;\n                    }\n                }\n                var dataViewTable = dataView.table;\n                if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    var rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\n                    var rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenTable) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.table = rewrittenTable;\n                    }\n                }\n            }\n            function rewriteTableRoleSelector(dataViewTable, selector) {\n                if (data.Selector.hasRoleWildcard(selector)) {\n                    selector = findSelectorForRoleWildcard(dataViewTable, selector);\n                }\n                return selector;\n            }\n            function findSelectorForRoleWildcard(dataViewTable, selector) {\n                var resultingSelector = {\n                    data: [],\n                    id: selector.id,\n                    metadata: selector.metadata\n                };\n                for (var _i = 0, _a = selector.data; _i < _a.length; _i++) {\n                    var dataSelector = _a[_i];\n                    if (data.Selector.isRoleWildcard(dataSelector)) {\n                        var selectorRoles = dataSelector.roles;\n                        var allColumnsBelongToSelectorRole = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\n                        var exprs = dataViewTable.identityFields;\n                        if (allColumnsBelongToSelectorRole && exprs) {\n                            resultingSelector.data.push(data.DataViewScopeWildcard.fromExprs(exprs));\n                            continue;\n                        }\n                    }\n                    if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\n                        resultingSelector.data.push(dataSelector);\n                    }\n                }\n                return resultingSelector;\n            }\n            function isUniqueDataSelector(dataSelectors, newSelector) {\n                if (_.isEmpty(dataSelectors))\n                    return true;\n                return !_.any(dataSelectors, function (dataSelector) { return dataSelector.key === newSelector.key; });\n            }\n            function allColumnsBelongToRole(columns, selectorRoles) {\n                for (var _i = 0, columns_6 = columns; _i < columns_6.length; _i++) {\n                    var column = columns_6[_i];\n                    var roles = column.roles;\n                    if (!roles || !_.any(selectorRoles, function (selectorRole) { return roles[selectorRole]; }))\n                        return false;\n                }\n                return true;\n            }\n            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\n                    return;\n                var targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\n                if (!targetColumn)\n                    return;\n                var identities = targetColumn.identities, foundMatch, evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                if (!identities)\n                    return;\n                debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\n                for (var i = 0, len = identities.length; i < len; i++) {\n                    var identity = identities[i];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(i);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (!targetColumn.column.objects) {\n                                targetColumn.column.objects = [];\n                                targetColumn.column.objects.length = len;\n                            }\n                            targetColumn.column.objects[i] = objects;\n                        }\n                        if (!containsWildcard)\n                            return true;\n                        foundMatch = true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var dataViewCategoricalValues = dataViewCategorical.values;\n                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [dataViewCategoricalValues.identityFields]))\n                    return;\n                var valuesGrouped = dataViewCategoricalValues.grouped();\n                if (!valuesGrouped)\n                    return;\n                // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\n                // This should be enhanced in the future.\n                var evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                var foundMatch;\n                for (var i = 0, len = valuesGrouped.length; i < len; i++) {\n                    var valueGroup = valuesGrouped[i];\n                    var selectorMetadata = selector.metadata;\n                    var valuesInGroup = valueGroup.values;\n                    if (containsWildcard || data.Selector.matchesData(selector, [valueGroup.identity])) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (selectorMetadata) {\n                                for (var j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\n                                    var valueColumn = valuesInGroup[j], valueSource = valueColumn.source;\n                                    if (valueSource.queryName === selectorMetadata) {\n                                        var valueSourceOverwrite = powerbi.Prototype.inherit(valueSource);\n                                        valueSourceOverwrite.objects = objects;\n                                        valueColumn.source = valueSourceOverwrite;\n                                        foundMatch = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            else {\n                                valueGroup.objects = objects;\n                                setGrouped(dataViewCategoricalValues, valuesGrouped);\n                                foundMatch = true;\n                            }\n                        }\n                        if (!containsWildcard)\n                            return true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                var evalContext = data.createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\n                var rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                var rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows || rewrittenCols) {\n                    var rewrittenMatrix = inheritSingle(dataViewMatrix);\n                    if (rewrittenRows)\n                        rewrittenMatrix.rows = rewrittenRows;\n                    if (rewrittenCols)\n                        rewrittenMatrix.columns = rewrittenCols;\n                    return rewrittenMatrix;\n                }\n            }\n            function evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrixHierarchy, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (!dataViewMatrixHierarchy)\n                    return;\n                var root = dataViewMatrixHierarchy.root;\n                if (!root)\n                    return;\n                var rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRoot) {\n                    var rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\n                    rewrittenHierarchy.root = rewrittenRoot;\n                    return rewrittenHierarchy;\n                }\n            }\n            function evaluateDataRepetitionMatrixNode(evalContext, dataViewNode, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(dataViewNode, 'dataViewNode');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var childNodes = dataViewNode.children;\n                if (!childNodes)\n                    return;\n                var rewrittenNode;\n                var shouldSearchChildren;\n                var childIdentityFields = dataViewNode.childIdentityFields;\n                if (childIdentityFields) {\n                    // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\n                    shouldSearchChildren = data.Selector.matchesKeys(selector, [childIdentityFields]);\n                }\n                for (var i = 0, len = childNodes.length; i < len; i++) {\n                    var childNode = childNodes[i], identity = childNode.identity, rewrittenChildNode = null;\n                    if (shouldSearchChildren) {\n                        if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                            // TODO: Need to initialize context for rule-based properties.  Rule-based properties\n                            // (such as fillRule/gradients) are not currently implemented.\n                            var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                            if (objects) {\n                                rewrittenChildNode = inheritSingle(childNode);\n                                rewrittenChildNode.objects = objects;\n                            }\n                        }\n                    }\n                    else {\n                        rewrittenChildNode = evaluateDataRepetitionMatrixNode(evalContext, childNode, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    }\n                    if (rewrittenChildNode) {\n                        if (!rewrittenNode)\n                            rewrittenNode = inheritNodeAndChildren(dataViewNode);\n                        rewrittenNode.children[i] = rewrittenChildNode;\n                        if (!containsWildcard) {\n                            // NOTE: once we find a match for a non-wildcard selector, stop looking.\n                            break;\n                        }\n                    }\n                }\n                return rewrittenNode;\n            }\n            function inheritNodeAndChildren(node) {\n                if (Object.getPrototypeOf(node) !== Object.prototype) {\n                    return node;\n                }\n                var inherited = inheritSingle(node);\n                inherited.children = inherit(node.children);\n                return inherited;\n            }\n            function evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewTable, 'dataViewTable');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var evalContext = data.createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\n                var rewrittenRows = evaluateDataRepetitionTableRows(evalContext, dataViewTable.columns, dataViewTable.rows, dataViewTable.identity, dataViewTable.identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows) {\n                    var rewrittenTable = inheritSingle(dataViewTable);\n                    rewrittenTable.rows = rewrittenRows;\n                    return rewrittenTable;\n                }\n            }\n            function evaluateDataRepetitionTableRows(evalContext, columns, rows, identities, identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(rows, 'rows');\n                debug.assertAnyValue(identities, 'identities');\n                debug.assertAnyValue(identityFields, 'identityFields');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (_.isEmpty(identities) || _.isEmpty(identityFields))\n                    return;\n                if (!selector.metadata ||\n                    !data.Selector.matchesKeys(selector, [identityFields]))\n                    return;\n                var colIdx = _.findIndex(columns, function (col) { return col.queryName === selector.metadata; });\n                if (colIdx < 0)\n                    return;\n                debug.assert(rows.length === identities.length, 'row length mismatch');\n                var colLen = columns.length;\n                var inheritedRows;\n                for (var rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\n                    var identity = identities[rowIdx];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(rowIdx);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            if (!inheritedRows)\n                                inheritedRows = inheritSingle(rows);\n                            var inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\n                            var objectsForColumns = inheritedRow.objects;\n                            if (!objectsForColumns)\n                                inheritedRow.objects = objectsForColumns = new Array(colLen);\n                            objectsForColumns[colIdx] = objects;\n                        }\n                        if (!containsWildcard)\n                            break;\n                    }\n                }\n                return inheritedRows;\n            }\n            function evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, selector, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                // revisit this, likely when we do lazy evaluation of DataView.\n                var columns = dataView.metadata.columns, metadataId = selector.metadata, evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (column.queryName === metadataId) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects)\n                            column.objects = objects;\n                    }\n                }\n            }\n            /** Attempts to find a column that can possibly match the selector. */\n            function findSelectedCategoricalColumn(dataViewCategorical, selector) {\n                debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\n                var categoricalColumn = dataViewCategorical.categories[0];\n                if (!categoricalColumn.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [categoricalColumn.identityFields]))\n                    return;\n                var identities = categoricalColumn.identity, targetColumn = categoricalColumn;\n                var selectedMetadataId = selector.metadata;\n                if (selectedMetadataId) {\n                    var valueColumns = dataViewCategorical.values;\n                    if (valueColumns) {\n                        for (var i = 0, len = valueColumns.length; i < len; i++) {\n                            var valueColumn = valueColumns[i];\n                            if (valueColumn.source.queryName === selectedMetadataId) {\n                                targetColumn = valueColumn;\n                                break;\n                            }\n                        }\n                    }\n                }\n                return {\n                    column: targetColumn,\n                    identities: identities,\n                };\n            }\n            function findSelectorForRuleInput(dataView, selectorRoles) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectorRoles, 'selectorRoles');\n                if (selectorRoles.length !== 1)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var categories = dataViewCategorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var categoryColumn = categories[0], categoryRoles = categoryColumn.source.roles, categoryIdentityFields = categoryColumn.identityFields;\n                if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\n                    return;\n                return { data: [data.DataViewScopeWildcard.fromExprs(categoryIdentityFields)] };\n            }\n            function findFirstQueryNameForExpr(selectTransforms, expr) {\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(expr, 'expr');\n                if (data.SQExpr.isSelectRef(expr))\n                    return expr.expressionName;\n                if (!selectTransforms)\n                    return;\n                for (var i = 0, len = selectTransforms.length; i < len; i++) {\n                    var select = selectTransforms[i], columnExpr = select.expr;\n                    if (!columnExpr || !data.SQExpr.equals(expr, select.expr))\n                        continue;\n                    return select.queryName;\n                }\n            }\n            /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\n            function findRuleInputColumnNumberRange(dataView, identifier, identifierKind) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                var columns = dataView.metadata.columns;\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (identifierKind === 1 /* Role */) {\n                        var valueColRoles = column.roles;\n                        if (!valueColRoles || !valueColRoles[identifier])\n                            continue;\n                    }\n                    else {\n                        debug.assert(identifierKind === 0 /* QueryName */, 'identifierKind === ColumnIdentifierKind.QueryName');\n                        if (column.queryName !== identifier)\n                            continue;\n                    }\n                    var aggregates = column.aggregates;\n                    if (!aggregates)\n                        continue;\n                    var min = aggregates.min;\n                    if (min === undefined)\n                        min = aggregates.minLocal;\n                    if (min === undefined)\n                        continue;\n                    var max = aggregates.max;\n                    if (max === undefined)\n                        max = aggregates.maxLocal;\n                    if (max === undefined)\n                        continue;\n                    return { min: min, max: max };\n                }\n            }\n            // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\n            function createValueColumns(values, valueIdentityFields, source) {\n                if (values === void 0) { values = []; }\n                var result = values;\n                setGrouped(values);\n                if (valueIdentityFields)\n                    result.identityFields = valueIdentityFields;\n                if (source)\n                    result.source = source;\n                return result;\n            }\n            DataViewTransform.createValueColumns = createValueColumns;\n            function setGrouped(values, groupedResult) {\n                values.grouped = groupedResult\n                    ? function () { return groupedResult; }\n                    : function () { return groupValues(values); };\n            }\n            DataViewTransform.setGrouped = setGrouped;\n            /** Group together the values with a common identity. */\n            function groupValues(values) {\n                debug.assertValue(values, 'values');\n                var groups = [], currentGroup;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    if (!currentGroup || currentGroup.identity !== value.identity) {\n                        currentGroup = {\n                            values: []\n                        };\n                        if (value.identity) {\n                            currentGroup.identity = value.identity;\n                            var source = value.source;\n                            // allow null, which will be formatted as (Blank).\n                            if (source.groupName !== undefined)\n                                currentGroup.name = source.groupName;\n                            else if (source.displayName)\n                                currentGroup.name = source.displayName;\n                        }\n                        groups.push(currentGroup);\n                    }\n                    currentGroup.values.push(value);\n                }\n                return groups;\n            }\n            function pivotIfNecessary(dataView, dataViewMappings) {\n                debug.assertValue(dataView, 'dataView');\n                var transformedDataView;\n                switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\n                    case 1 /* Pivot */:\n                        transformedDataView = data.DataViewPivotCategorical.apply(dataView);\n                        break;\n                    case 2 /* SelfCrossJoin */:\n                        transformedDataView = data.DataViewSelfCrossJoin.apply(dataView);\n                        break;\n                }\n                return transformedDataView || dataView;\n            }\n            function determineCategoricalTransformation(categorical, dataViewMappings) {\n                if (!categorical || _.isEmpty(dataViewMappings))\n                    return;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var values = categorical.values;\n                if (_.isEmpty(values))\n                    return;\n                if (values.grouped().some(function (vg) { return !!vg.identity; }))\n                    return;\n                // If we made it here, the DataView has a single category and no valueGrouping.\n                var categoryRoles = categories[0].source.roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingCategorical = dataViewMappings[i].categorical;\n                    if (!roleMappingCategorical)\n                        continue;\n                    if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values))\n                        continue;\n                    // If we made it here, the DataView's single category has the value grouping role.\n                    var categoriesMapping = roleMappingCategorical.categories;\n                    var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) ||\n                        hasRolesFor(categoryRoles, categoriesMapping);\n                    if (hasCategoryRole)\n                        return 2 /* SelfCrossJoin */;\n                    return 1 /* Pivot */;\n                }\n            }\n            function shouldPivotMatrix(matrix, dataViewMappings) {\n                if (!matrix || _.isEmpty(dataViewMappings))\n                    return;\n                var rowLevels = matrix.rows.levels;\n                if (rowLevels.length < 1)\n                    return;\n                var rows = matrix.rows.root.children;\n                if (!rows || rows.length === 0)\n                    return;\n                var rowRoles = rowLevels[0].sources[0].roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingMatrix = dataViewMappings[i].matrix;\n                    if (!roleMappingMatrix)\n                        continue;\n                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) &&\n                        hasRolesFor(rowRoles, roleMappingMatrix.columns)) {\n                        return true;\n                    }\n                }\n            }\n            function hasRolesBind(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.bind)\n                    return roles[roleMapping.bind.to];\n            }\n            function hasRolesFor(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.for)\n                    return roles[roleMapping.for.in];\n            }\n            function hasRolesGrouped(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.group)\n                    return roles[roleMapping.group.by];\n            }\n        })(DataViewTransform = data.DataViewTransform || (data.DataViewTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createDisplayNameGetter(displayNameKey) {\n            return function (resourceProvider) { return resourceProvider.get(displayNameKey); };\n        }\n        data.createDisplayNameGetter = createDisplayNameGetter;\n        function getDisplayName(displayNameGetter, resourceProvider) {\n            if (typeof displayNameGetter === 'function')\n                return displayNameGetter(resourceProvider);\n            if (typeof displayNameGetter === 'string')\n                return displayNameGetter;\n        }\n        data.getDisplayName = getDisplayName;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Enumeration of DateTimeUnits */\n    (function (DateTimeUnit) {\n        DateTimeUnit[DateTimeUnit[\"Year\"] = 0] = \"Year\";\n        DateTimeUnit[DateTimeUnit[\"Month\"] = 1] = \"Month\";\n        DateTimeUnit[DateTimeUnit[\"Week\"] = 2] = \"Week\";\n        DateTimeUnit[DateTimeUnit[\"Day\"] = 3] = \"Day\";\n        DateTimeUnit[DateTimeUnit[\"Hour\"] = 4] = \"Hour\";\n        DateTimeUnit[DateTimeUnit[\"Minute\"] = 5] = \"Minute\";\n        DateTimeUnit[DateTimeUnit[\"Second\"] = 6] = \"Second\";\n        DateTimeUnit[DateTimeUnit[\"Millisecond\"] = 7] = \"Millisecond\";\n    })(powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));\n    var DateTimeUnit = powerbi.DateTimeUnit;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function fieldExpr(fieldExpr) {\n                var sqExpr = FieldExprPattern.visit(fieldExpr, FieldExprToSQExprVisitor.instance);\n                debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\n                return sqExpr;\n            }\n            SQExprBuilder.fieldExpr = fieldExpr;\n            function fromColumnAggr(columnAggr) {\n                return SQExprBuilder.aggregate(fromColumn(columnAggr), columnAggr.aggregate);\n            }\n            SQExprBuilder.fromColumnAggr = fromColumnAggr;\n            function fromColumn(column) {\n                return SQExprBuilder.columnRef(fromEntity(column), column.name);\n            }\n            SQExprBuilder.fromColumn = fromColumn;\n            function fromEntity(entityPattern) {\n                return SQExprBuilder.entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\n            }\n            SQExprBuilder.fromEntity = fromEntity;\n            function fromEntityAggr(entityAggr) {\n                return SQExprBuilder.aggregate(fromEntity(entityAggr), entityAggr.aggregate);\n            }\n            SQExprBuilder.fromEntityAggr = fromEntityAggr;\n            function fromHierarchyLevelAggr(hierarchyLevelAggr) {\n                return SQExprBuilder.aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\n            }\n            SQExprBuilder.fromHierarchyLevelAggr = fromHierarchyLevelAggr;\n            function fromHierarchyLevel(hierarchyLevelPattern) {\n                return SQExprBuilder.hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\n            }\n            SQExprBuilder.fromHierarchyLevel = fromHierarchyLevel;\n            function fromHierarchy(hierarchyPattern) {\n                return SQExprBuilder.hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\n            }\n            SQExprBuilder.fromHierarchy = fromHierarchy;\n            var FieldExprToSQExprVisitor = (function () {\n                function FieldExprToSQExprVisitor() {\n                }\n                FieldExprToSQExprVisitor.prototype.visitColumn = function (column) {\n                    return fromColumn(column);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return fromColumnAggr(columnAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariationPattern) {\n                    return SQExprBuilder.propertyVariationSource(this.visitEntity(columnHierarchyLevelVariationPattern.source), columnHierarchyLevelVariationPattern.source.name, columnHierarchyLevelVariationPattern.level.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntity = function (entityPattern) {\n                    return fromEntity(entityPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return fromEntityAggr(entityAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchy = function (hierarchyPattern) {\n                    return fromHierarchy(hierarchyPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevel = function (level) {\n                    return fromHierarchyLevel(level);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return fromHierarchyLevelAggr(hierarchyLevelAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitMeasure = function (measure) {\n                    return SQExprBuilder.measureRef(this.visitEntity(measure), measure.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitPercentile = function (percentile) {\n                    var arg = SQExprBuilder.fieldExpr(percentile.arg);\n                    return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);\n                };\n                FieldExprToSQExprVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    var baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);\n                    return SQExprBuilder.arithmetic(baseSQExpr, SQExprBuilder.scopedEval(baseSQExpr, []), 3 /* Divide */);\n                };\n                FieldExprToSQExprVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return SQExprBuilder.selectRef(selectRef.expressionName);\n                };\n                FieldExprToSQExprVisitor.instance = new FieldExprToSQExprVisitor();\n                return FieldExprToSQExprVisitor;\n            }());\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asFieldPattern(sqExpr) {\n                return sqExpr.accept(FieldExprPatternBuilder.instance);\n            }\n            SQExprConverter.asFieldPattern = asFieldPattern;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        var FieldExprPatternBuilder = (function (_super) {\n            __extends(FieldExprPatternBuilder, _super);\n            function FieldExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            FieldExprPatternBuilder.prototype.visitColumnRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var columnRef = sourceRef.entity;\n                    columnRef.name = expr.ref;\n                    return { column: columnRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitMeasureRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var measureRef = sourceRef.entity;\n                    measureRef.name = expr.ref;\n                    return { measure: measureRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            FieldExprPatternBuilder.prototype.visitAggr = function (expr) {\n                var fieldPattern = expr.arg.accept(this);\n                if (fieldPattern && fieldPattern.column) {\n                    var argAggr = fieldPattern.column;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.columnAggr) {\n                    var argAggr = fieldPattern.columnAggr;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.hierarchyLevel) {\n                    var argAggr = fieldPattern.hierarchyLevel;\n                    argAggr.aggregate = expr.func;\n                    return { hierarchyLevelAggr: argAggr };\n                }\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var argAggr = sourcePattern.entity;\n                    argAggr.aggregate = expr.func;\n                    return { entityAggr: argAggr };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitPercentile = function (expr) {\n                return {\n                    percentile: {\n                        arg: expr.arg.accept(this),\n                        k: expr.k,\n                        exclusive: expr.exclusive,\n                    }\n                };\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchy = function (expr) {\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var hierarchyRef = (sourcePattern.entity);\n                    hierarchyRef.name = expr.hierarchy;\n                    return { hierarchy: hierarchyRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchyLevel = function (expr) {\n                var hierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\n                if (!hierarchySourceExprPattern)\n                    return;\n                var hierarchyLevel;\n                if (hierarchySourceExprPattern.hierarchy) {\n                    hierarchyLevel = {\n                        entity: hierarchySourceExprPattern.hierarchy.entity,\n                        schema: hierarchySourceExprPattern.hierarchy.schema,\n                        name: hierarchySourceExprPattern.hierarchy.name,\n                        level: expr.level,\n                    };\n                }\n                if (hierarchySourceExprPattern.variation) {\n                    return {\n                        columnHierarchyLevelVariation: {\n                            source: {\n                                entity: hierarchySourceExprPattern.variation.column.entity,\n                                schema: hierarchySourceExprPattern.variation.column.schema,\n                                name: hierarchySourceExprPattern.variation.column.name,\n                            },\n                            level: hierarchyLevel,\n                            variationName: hierarchySourceExprPattern.variation.variationName,\n                        }\n                    };\n                }\n                return { hierarchyLevel: hierarchyLevel };\n            };\n            FieldExprPatternBuilder.prototype.visitArithmetic = function (expr) {\n                var percentOfGrandTotalPattern = {\n                    percentOfGrandTotal: {\n                        baseExpr: expr.left.accept(this)\n                    }\n                };\n                if (data.SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern))) {\n                    return percentOfGrandTotalPattern;\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitSelectRef = function (expr) {\n                return {\n                    selectRef: {\n                        expressionName: expr.expressionName,\n                    }\n                };\n            };\n            FieldExprPatternBuilder.instance = new FieldExprPatternBuilder();\n            return FieldExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var SourceExprPatternBuilder = (function (_super) {\n            __extends(SourceExprPatternBuilder, _super);\n            function SourceExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            SourceExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            SourceExprPatternBuilder.prototype.visitPropertyVariationSource = function (expr) {\n                var entityExpr = expr.arg;\n                if (entityExpr instanceof data.SQEntityExpr) {\n                    var propertyVariationSource = {\n                        schema: entityExpr.schema,\n                        entity: entityExpr.entity,\n                        name: expr.property,\n                    };\n                    if (entityExpr.variable)\n                        propertyVariationSource.entityVar = entityExpr.variable;\n                    return {\n                        variation: {\n                            column: propertyVariationSource,\n                            variationName: expr.name,\n                        }\n                    };\n                }\n            };\n            SourceExprPatternBuilder.instance = new SourceExprPatternBuilder();\n            return SourceExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var HierarchyExprPatternBuiler = (function (_super) {\n            __extends(HierarchyExprPatternBuiler, _super);\n            function HierarchyExprPatternBuiler() {\n                _super.apply(this, arguments);\n            }\n            HierarchyExprPatternBuiler.prototype.visitHierarchy = function (expr) {\n                var exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                var hierarchyRef;\n                var variationRef;\n                if (exprPattern.variation) {\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.variation.column.schema,\n                        entity: exprPattern.variation.column.entity,\n                    };\n                    variationRef = exprPattern.variation;\n                }\n                else\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.entity.schema,\n                        entity: exprPattern.entity.entity,\n                    };\n                return {\n                    hierarchy: hierarchyRef,\n                    variation: variationRef\n                };\n            };\n            HierarchyExprPatternBuiler.instance = new HierarchyExprPatternBuiler();\n            return HierarchyExprPatternBuiler;\n        }(data.DefaultSQExprVisitor));\n        var FieldExprPattern;\n        (function (FieldExprPattern) {\n            function visit(expr, visitor) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(visitor, 'visitor');\n                var fieldExprPattern = expr instanceof data.SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\n                debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\n                if (fieldExprPattern.column)\n                    return visitColumn(fieldExprPattern.column, visitor);\n                if (fieldExprPattern.columnAggr)\n                    return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\n                if (fieldExprPattern.columnHierarchyLevelVariation)\n                    return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\n                if (fieldExprPattern.entity)\n                    return visitEntity(fieldExprPattern.entity, visitor);\n                if (fieldExprPattern.entityAggr)\n                    return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\n                if (fieldExprPattern.hierarchy)\n                    return visitHierarchy(fieldExprPattern.hierarchy, visitor);\n                if (fieldExprPattern.hierarchyLevel)\n                    return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\n                if (fieldExprPattern.hierarchyLevelAggr)\n                    return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\n                if (fieldExprPattern.measure)\n                    return visitMeasure(fieldExprPattern.measure, visitor);\n                if (fieldExprPattern.percentile)\n                    return visitPercentile(fieldExprPattern.percentile, visitor);\n                if (fieldExprPattern.percentOfGrandTotal)\n                    return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);\n                if (fieldExprPattern.selectRef)\n                    return visitSelectRef(fieldExprPattern.selectRef, visitor);\n                debug.assertFail('failed to visit a fieldExprPattern.');\n                return;\n            }\n            FieldExprPattern.visit = visit;\n            function visitColumn(column, visitor) {\n                debug.assertValue(column, 'column');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumn(column);\n            }\n            function visitColumnAggr(columnAggr, visitor) {\n                debug.assertValue(columnAggr, 'columnAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnAggr(columnAggr);\n            }\n            function visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation, visitor) {\n                debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\n            }\n            function visitEntity(entity, visitor) {\n                debug.assertValue(entity, 'entity');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntity(entity);\n            }\n            function visitEntityAggr(entityAggr, visitor) {\n                debug.assertValue(entityAggr, 'entityAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntityAggr(entityAggr);\n            }\n            function visitHierarchy(hierarchy, visitor) {\n                debug.assertValue(hierarchy, 'hierarchy');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchy(hierarchy);\n            }\n            function visitHierarchyLevel(hierarchyLevel, visitor) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevel(hierarchyLevel);\n            }\n            function visitHierarchyLevelAggr(hierarchyLevelAggr, visitor) {\n                debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\n            }\n            function visitMeasure(measure, visitor) {\n                debug.assertValue(measure, 'measure');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitMeasure(measure);\n            }\n            function visitSelectRef(selectRef, visitor) {\n                debug.assertValue(selectRef, 'selectRef');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitSelectRef(selectRef);\n            }\n            function visitPercentile(percentile, visitor) {\n                debug.assertValue(percentile, 'percentile');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitPercentile(percentile);\n            }\n            function visitPercentOfGrandTotal(percentOfGrandTotal, visitor) {\n                debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);\n            }\n            function toColumnRefSQExpr(columnPattern) {\n                return SQExprBuilder.columnRef(SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar), columnPattern.name);\n            }\n            FieldExprPattern.toColumnRefSQExpr = toColumnRefSQExpr;\n            function getAggregate(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\n            }\n            FieldExprPattern.getAggregate = getAggregate;\n            function isAggregation(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternIsAggregationVisitor.instance);\n            }\n            FieldExprPattern.isAggregation = isAggregation;\n            function hasFieldExprName(fieldExpr) {\n                return (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure) !== undefined;\n            }\n            FieldExprPattern.hasFieldExprName = hasFieldExprName;\n            function getPropertyName(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprPropertyNameVisitor.instance);\n            }\n            FieldExprPattern.getPropertyName = getPropertyName;\n            function getHierarchyName(fieldExpr) {\n                var hierarchy = fieldExpr.hierarchy;\n                if (hierarchy)\n                    return hierarchy.name;\n            }\n            FieldExprPattern.getHierarchyName = getHierarchyName;\n            function getColumnRef(fieldExpr) {\n                if (fieldExpr.columnHierarchyLevelVariation)\n                    return fieldExpr.columnHierarchyLevelVariation.source;\n                return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\n            }\n            FieldExprPattern.getColumnRef = getColumnRef;\n            function getFieldExprName(fieldExpr) {\n                var name = getPropertyName(fieldExpr);\n                if (name)\n                    return name;\n                // In case it is an entity\n                return toFieldExprEntityPattern(fieldExpr).entity;\n            }\n            FieldExprPattern.getFieldExprName = getFieldExprName;\n            function getSchema(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                var item = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                debug.assertAnyValue(item, 'expected fieldExpr to be an entity item');\n                return item.schema;\n            }\n            FieldExprPattern.getSchema = getSchema;\n            function toFieldExprEntityPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityPattern = toFieldExprEntityPattern;\n            function toFieldExprEntityItemPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityItemPattern = toFieldExprEntityItemPattern;\n            var FieldExprPatternAggregateVisitor = (function () {\n                function FieldExprPatternAggregateVisitor() {\n                }\n                FieldExprPatternAggregateVisitor.prototype.visitColumn = function (column) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return columnAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntity = function (entity) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return entityAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return hierarchyLevelAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitMeasure = function (measure) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitPercentile = function (percentile) {\n                    // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but\n                    // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.\n                    // This should be revisited when we have UI support for the Percentile aggregate.\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return data.SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));\n                };\n                FieldExprPatternAggregateVisitor.instance = new FieldExprPatternAggregateVisitor();\n                return FieldExprPatternAggregateVisitor;\n            }());\n            var FieldExprPatternIsAggregationVisitor = (function () {\n                function FieldExprPatternIsAggregationVisitor() {\n                }\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumn = function (column) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitEntity = function (entity) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitMeasure = function (measure) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitPercentile = function (percentile) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.instance = new FieldExprPatternIsAggregationVisitor();\n                return FieldExprPatternIsAggregationVisitor;\n            }());\n            var FieldExprToEntityExprPatternBuilder = (function () {\n                function FieldExprToEntityExprPatternBuilder() {\n                }\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumn = function (column) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnAggr = function (columnAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntity = function (entity) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntityAggr = function (entityAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchy = function (hierarchy) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitMeasure = function (measure) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitPercentile = function (percentile) {\n                    return FieldExprPattern.visit(percentile.arg, this);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n                };\n                FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern = function (exprPattern) {\n                    debug.assertValue(exprPattern, 'exprPattern');\n                    var pattern = { schema: exprPattern.schema, entity: exprPattern.entity };\n                    if (exprPattern.entityVar) {\n                        pattern.entityVar = exprPattern.entityVar;\n                    }\n                    return pattern;\n                };\n                FieldExprToEntityExprPatternBuilder.instance = new FieldExprToEntityExprPatternBuilder();\n                return FieldExprToEntityExprPatternBuilder;\n            }());\n            var FieldExprPropertyNameVisitor = (function () {\n                function FieldExprPropertyNameVisitor() {\n                }\n                FieldExprPropertyNameVisitor.prototype.visitColumn = function (column) {\n                    return column.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return columnAggr.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitEntity = function (entity) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitMeasure = function (measure) {\n                    return measure.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitPercentile = function (percentile) {\n                    return FieldExprPattern.visit(percentile.arg, this);\n                };\n                FieldExprPropertyNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n                };\n                FieldExprPropertyNameVisitor.instance = new FieldExprPropertyNameVisitor();\n                return FieldExprPropertyNameVisitor;\n            }());\n        })(FieldExprPattern = data.FieldExprPattern || (data.FieldExprPattern = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewAnalysis;\n    (function (DataViewAnalysis) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\n        (function (DataViewMappingMatchErrorCode) {\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooLarge\"] = 0] = \"conditionRangeTooLarge\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooSmall\"] = 1] = \"conditionRangeTooSmall\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedMeasure\"] = 2] = \"conditionKindExpectedMeasure\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGrouping\"] = 3] = \"conditionKindExpectedGrouping\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGroupingOrMeasure\"] = 4] = \"conditionKindExpectedGroupingOrMeasure\";\n        })(DataViewAnalysis.DataViewMappingMatchErrorCode || (DataViewAnalysis.DataViewMappingMatchErrorCode = {}));\n        var DataViewMappingMatchErrorCode = DataViewAnalysis.DataViewMappingMatchErrorCode;\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\n        function validateAndReshape(dataView, dataViewMappings) {\n            if (!dataViewMappings || dataViewMappings.length === 0)\n                return { dataView: dataView, isValid: true };\n            if (dataView) {\n                for (var _i = 0, dataViewMappings_3 = dataViewMappings; _i < dataViewMappings_3.length; _i++) {\n                    var dataViewMapping = dataViewMappings_3[_i];\n                    // Keep the original when possible.\n                    if (supports(dataView, dataViewMapping))\n                        return { dataView: dataView, isValid: true };\n                    if (dataViewMapping.categorical && dataView.categorical)\n                        return reshapeCategorical(dataView, dataViewMapping);\n                    if (dataViewMapping.tree && dataView.tree)\n                        return reshapeTree(dataView, dataViewMapping.tree);\n                    if (dataViewMapping.single && dataView.single)\n                        return reshapeSingle(dataView, dataViewMapping.single);\n                    if (dataViewMapping.table && dataView.table)\n                        return reshapeTable(dataView, dataViewMapping.table);\n                }\n            }\n            else if (powerbi.ScriptResultUtil.findScriptResult(dataViewMappings)) {\n                // Currently, PBI Service treats R Script Visuals as static images.\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\n                // to support the PBI Desktop scenario.\n                // This code will be removed once PBI Service fully supports R Script Visuals.\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\n                return { dataView: dataView, isValid: true };\n            }\n            return { isValid: false };\n        }\n        DataViewAnalysis.validateAndReshape = validateAndReshape;\n        function reshapeCategorical(dataView, dataViewMapping) {\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\n            var categoryRoleMapping = dataViewMapping.categorical;\n            var categorical = dataView.categorical;\n            if (!categorical)\n                return { isValid: false };\n            var rowCount;\n            if (categoryRoleMapping.rowCount) {\n                rowCount = categoryRoleMapping.rowCount.supported;\n                if (rowCount && rowCount.max) {\n                    var updated = void 0;\n                    var categories = categorical.categories;\n                    var maxRowCount = rowCount.max;\n                    var originalLength = undefined;\n                    if (categories) {\n                        for (var i = 0, len = categories.length; i < len; i++) {\n                            var category = categories[i];\n                            originalLength = category.values.length;\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                                // Row count too large: Trim it to fit.\n                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\n                                updated = updated || { categories: [] };\n                                updated.categories.push({\n                                    source: category.source,\n                                    values: updatedCategories\n                                });\n                            }\n                        }\n                    }\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\n                        if (!originalLength)\n                            originalLength = categorical.values[0].values.length;\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                            updated = updated || {};\n                            updated.values = powerbi.data.DataViewTransform.createValueColumns();\n                            for (var i = 0, len = categorical.values.length; i < len; i++) {\n                                var column = categorical.values[i], updatedColumn = {\n                                    source: column.source,\n                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\n                                };\n                                if (column.min !== undefined)\n                                    updatedColumn.min = column.min;\n                                if (column.max !== undefined)\n                                    updatedColumn.max = column.max;\n                                if (column.subtotal !== undefined)\n                                    updatedColumn.subtotal = column.subtotal;\n                                updated.values.push(updatedColumn);\n                            }\n                        }\n                    }\n                    if (updated) {\n                        dataView = {\n                            metadata: dataView.metadata,\n                            categorical: updated,\n                        };\n                    }\n                }\n            }\n            if (supportsCategorical(dataView, dataViewMapping))\n                return { dataView: dataView, isValid: true };\n            return null;\n        }\n        function reshapeSingle(dataView, singleRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (dataView.single)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTree(dataView, treeRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            // TODO: Need to implement the reshaping of Tree\n            var metadata = dataView.metadata;\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTable(dataView, tableRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (dataView.table)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function countGroups(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (!columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countGroups = countGroups;\n        function countMeasures(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countMeasures = countMeasures;\n        /** Indicates whether the dataView conforms to the specified schema. */\n        function supports(dataView, roleMapping, usePreferredDataViewSchema) {\n            if (!roleMapping || !dataView)\n                return false;\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\n                return false;\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\n                return false;\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\n                return false;\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\n                return false;\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\n                return false;\n            return true;\n        }\n        DataViewAnalysis.supports = supports;\n        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\n            var dataViewCategorical = dataView.categorical;\n            if (!dataViewCategorical)\n                return false;\n            // TODO: Disabling this implementation isn't right.\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\n            //    return false;\n            if (categoryRoleMapping.rowCount) {\n                var rowCount = categoryRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\n                    rowCount = categoryRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\n                        len = dataViewCategorical.values[0].values.length;\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\n                        len = dataViewCategorical.categories[0].values.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsSingle(dataViewSingle, singleRoleMapping) {\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (!dataViewSingle)\n                return false;\n            return true;\n        }\n        function supportsTree(dataView, treeRoleMapping) {\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            var metadata = dataView.metadata;\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\n        }\n        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (!dataViewTable)\n                return false;\n            if (tableRoleMapping.rowCount) {\n                var rowCount = tableRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\n                    rowCount = tableRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewTable.rows && dataViewTable.rows.length)\n                        len = dataViewTable.rows.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsScriptResult(dataView, scriptResultRoleMapping) {\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\n            if (!dataView)\n                return false;\n            if (!dataView.imageBase64)\n                return false;\n            return true;\n        }\n        /**\n         * Determines whether the value conforms to the range in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateRange(value, roleCondition, ignoreMin) {\n            debug.assertValue(value, 'value');\n            if (!roleCondition)\n                return;\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\n            if (roleCondition.max !== undefined && roleCondition.max < value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\n        }\n        DataViewAnalysis.validateRange = validateRange;\n        /**\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateKind(roleCondition, roleName, projections, roleKindByQueryRef) {\n            if (!roleCondition || roleCondition.kind === undefined) {\n                return;\n            }\n            var expectedKind = roleCondition.kind;\n            var roleCollection = projections[roleName];\n            if (roleCollection) {\n                var roleProjections = roleCollection.all();\n                for (var _i = 0, roleProjections_1 = roleProjections; _i < roleProjections_1.length; _i++) {\n                    var roleProjection = roleProjections_1[_i];\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\n                        switch (expectedKind) {\n                            case powerbi.VisualDataRoleKind.Measure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\n                            case powerbi.VisualDataRoleKind.Grouping:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\n                            case powerbi.VisualDataRoleKind.GroupingOrMeasure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\n                        }\n                    }\n                }\n            }\n        }\n        /** Determines the appropriate DataViewMappings for the projections. */\n        function chooseDataViewMappings(projections, mappings, roleKindByQueryRef, objectDescriptors, objectDefinitions) {\n            debug.assertValue(projections, 'projections');\n            debug.assertAnyValue(mappings, 'mappings');\n            var supportedMappings = [];\n            var errors = [];\n            if (!_.isEmpty(mappings)) {\n                for (var mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\n                    var mapping = mappings[mappingIndex], mappingConditions = mapping.conditions, requiredProperties = mapping.requiredProperties;\n                    var allPropertiesValid = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\n                    var conditionsMet = [];\n                    if (!_.isEmpty(mappingConditions)) {\n                        for (var conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\n                            var condition = mappingConditions[conditionIndex];\n                            var currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\n                            if (!_.isEmpty(currentConditionErrors)) {\n                                for (var _i = 0, currentConditionErrors_1 = currentConditionErrors; _i < currentConditionErrors_1.length; _i++) {\n                                    var error = currentConditionErrors_1[_i];\n                                    error.mappingIndex = mappingIndex;\n                                    error.conditionIndex = conditionIndex;\n                                    errors.push(error);\n                                }\n                            }\n                            else\n                                conditionsMet.push(condition);\n                        }\n                    }\n                    else {\n                        conditionsMet.push({});\n                    }\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\n                        var supportedMapping = _.cloneDeep(mapping);\n                        var updatedConditions = _.filter(conditionsMet, function (condition) { return Object.keys(condition).length > 0; });\n                        if (!_.isEmpty(updatedConditions))\n                            supportedMapping.conditions = updatedConditions;\n                        supportedMappings.push(supportedMapping);\n                    }\n                }\n            }\n            return {\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\n            };\n        }\n        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;\n        function checkForConditionErrors(projections, condition, roleKindByQueryRef) {\n            debug.assertValue(projections, 'projections');\n            debug.assertValue(condition, 'condition');\n            var conditionRoles = Object.keys(condition);\n            var errors = [];\n            for (var i = 0, len = conditionRoles.length; i < len; i++) {\n                var roleName = conditionRoles[i], isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs), roleCondition = condition[roleName];\n                var roleCount = getPropertyCount(roleName, projections, isDrillable);\n                var rangeError = validateRange(roleCount, roleCondition);\n                if (rangeError != null) {\n                    errors.push({\n                        code: rangeError,\n                        roleName: roleName,\n                    });\n                }\n                var kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\n                if (kindError != null) {\n                    errors.push({\n                        code: kindError,\n                        roleName: roleName,\n                    });\n                }\n            }\n            return errors;\n        }\n        function areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions) {\n            if (_.isEmpty(requiredProperties))\n                return true;\n            if (!objectDescriptors || !objectDefinitions)\n                return false;\n            var staticEvalContext = powerbi.data.createStaticEvalContext();\n            return _.every(requiredProperties, function (requiredProperty) {\n                var objectDescriptorValue = null;\n                var objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\n                if (objectDescriptorProperty)\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\n                var objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\n                if (!objectDescriptorValue || !objectDefinitionValue)\n                    return false;\n                return powerbi.data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\n            });\n        }\n        function getPropertyCount(roleName, projections, useActiveIfAvailable) {\n            debug.assertValue(roleName, 'roleName');\n            debug.assertValue(projections, 'projections');\n            var projectionsForRole = projections[roleName];\n            if (projectionsForRole) {\n                if (useActiveIfAvailable)\n                    return 1;\n                return projectionsForRole.all().length;\n            }\n            return 0;\n        }\n        DataViewAnalysis.getPropertyCount = getPropertyCount;\n        function hasSameCategoryIdentity(dataView1, dataView2) {\n            if (dataView1\n                && dataView2\n                && dataView1.categorical\n                && dataView2.categorical) {\n                var dv1Categories = dataView1.categorical.categories;\n                var dv2Categories = dataView2.categorical.categories;\n                if (dv1Categories\n                    && dv2Categories\n                    && dv1Categories.length === dv2Categories.length) {\n                    for (var i = 0, len = dv1Categories.length; i < len; i++) {\n                        var dv1Identity = dv1Categories[i].identity;\n                        var dv2Identity = dv2Categories[i].identity;\n                        var dv1Length = getLengthOptional(dv1Identity);\n                        if (dv1Length !== getLengthOptional(dv2Identity))\n                            return false;\n                        for (var j = 0; j < dv1Length; j++) {\n                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\n                                return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;\n        function getLengthOptional(identity) {\n            if (identity)\n                return identity.length;\n            return 0;\n        }\n        function areMetadataColumnsEquivalent(column1, column2) {\n            if (!column1 && !column2)\n                return true;\n            if (!column1 || !column2)\n                return false;\n            if (column1.displayName !== column2.displayName)\n                return false;\n            if (column1.queryName !== column2.queryName)\n                return false;\n            if (column1.isMeasure !== column2.isMeasure)\n                return false;\n            if (column1.type !== column2.type)\n                return false;\n            if (column1.sort !== column2.sort)\n                return false;\n            return true;\n        }\n        DataViewAnalysis.areMetadataColumnsEquivalent = areMetadataColumnsEquivalent;\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\n        function isMetadataEquivalent(metadata1, metadata2) {\n            if (!metadata1 && !metadata2)\n                return true;\n            if (!metadata1 || !metadata2)\n                return false;\n            var previousColumnsLength = metadata1.columns.length;\n            var newColumnsLength = metadata2.columns.length;\n            if (previousColumnsLength !== newColumnsLength)\n                return false;\n            for (var i = 0; i < newColumnsLength; i++) {\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\n                    return false;\n            }\n            return true;\n        }\n        DataViewAnalysis.isMetadataEquivalent = isMetadataEquivalent;\n    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var Lazy = jsCommon.Lazy;\n        var DataViewRoleWildcard;\n        (function (DataViewRoleWildcard) {\n            function fromRoles(roles) {\n                return new DataViewRoleWildcardImpl(roles);\n            }\n            DataViewRoleWildcard.fromRoles = fromRoles;\n            function equals(firstRoleWildcard, secondRoleWildcard) {\n                return firstRoleWildcard.key &&\n                    secondRoleWildcard.key &&\n                    firstRoleWildcard.key === secondRoleWildcard.key &&\n                    ArrayExtensions.sequenceEqual(firstRoleWildcard.roles, secondRoleWildcard.roles, function (role1, role2) { return role1 === role2; });\n            }\n            DataViewRoleWildcard.equals = equals;\n            var DataViewRoleWildcardImpl = (function () {\n                function DataViewRoleWildcardImpl(roles) {\n                    var _this = this;\n                    debug.assertNonEmpty(roles, 'roles');\n                    this._roles = roles;\n                    this._key = new Lazy(function () { return JSON.stringify(_this.roles); });\n                }\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"roles\", {\n                    get: function () {\n                        return this._roles;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewRoleWildcardImpl;\n            }());\n        })(DataViewRoleWildcard = data.DataViewRoleWildcard || (data.DataViewRoleWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewScopeIdentity;\n    (function (DataViewScopeIdentity) {\n        /** Compares the two DataViewScopeIdentity values for equality. */\n        function equals(x, y, ignoreCase) {\n            // Normalize falsy to null\n            x = x || null;\n            y = y || null;\n            if (x === y)\n                return true;\n            if (!x !== !y)\n                return false;\n            debug.assertValue(x, 'x');\n            debug.assertValue(y, 'y');\n            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);\n        }\n        DataViewScopeIdentity.equals = equals;\n        function filterFromIdentity(identities, isNot) {\n            if (_.isEmpty(identities))\n                return;\n            var exprs = [];\n            for (var _i = 0, identities_1 = identities; _i < identities_1.length; _i++) {\n                var identity = identities_1[_i];\n                exprs.push(identity.expr);\n            }\n            return filterFromExprs(exprs, isNot);\n        }\n        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;\n        function filterFromExprs(orExprs, isNot) {\n            if (_.isEmpty(orExprs))\n                return;\n            var resultExpr;\n            for (var _i = 0, orExprs_1 = orExprs; _i < orExprs_1.length; _i++) {\n                var orExpr = orExprs_1[_i];\n                var inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\n                if (resultExpr)\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\n                else\n                    resultExpr = inExpr || orExpr;\n            }\n            if (resultExpr) {\n                if (isNot)\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\n            }\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\n        }\n        DataViewScopeIdentity.filterFromExprs = filterFromExprs;\n    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        function createDataViewScopeIdentity(expr) {\n            return new DataViewScopeIdentityImpl(expr);\n        }\n        data.createDataViewScopeIdentity = createDataViewScopeIdentity;\n        var DataViewScopeIdentityImpl = (function () {\n            function DataViewScopeIdentityImpl(expr) {\n                debug.assertValue(expr, 'expr');\n                this._expr = expr;\n                this._key = new Lazy(function () { return data.SQExprShortSerializer.serialize(expr); });\n            }\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"expr\", {\n                get: function () {\n                    return this._expr;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"key\", {\n                get: function () {\n                    return this._key.getValue();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return DataViewScopeIdentityImpl;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        var DataViewScopeWildcard;\n        (function (DataViewScopeWildcard) {\n            function matches(wildcard, instance) {\n                var instanceExprs = data.ScopeIdentityExtractor.getKeys(instance.expr);\n                if (!instanceExprs)\n                    return false;\n                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);\n            }\n            DataViewScopeWildcard.matches = matches;\n            function equals(firstScopeWildcard, secondScopeWildcard) {\n                return firstScopeWildcard.key === secondScopeWildcard.key &&\n                    data.SQExprUtils.sequenceEqual(firstScopeWildcard.exprs, secondScopeWildcard.exprs);\n            }\n            DataViewScopeWildcard.equals = equals;\n            function fromExprs(exprs) {\n                return new DataViewScopeWildcardImpl(exprs);\n            }\n            DataViewScopeWildcard.fromExprs = fromExprs;\n            var DataViewScopeWildcardImpl = (function () {\n                function DataViewScopeWildcardImpl(exprs) {\n                    debug.assertValue(exprs, 'exprs');\n                    this._exprs = exprs;\n                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });\n                }\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"exprs\", {\n                    get: function () {\n                        return this._exprs;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewScopeWildcardImpl;\n            }());\n        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createColorAllocatorCache() {\n            return new ColorAllocatorProvider();\n        }\n        data.createColorAllocatorCache = createColorAllocatorCache;\n        var ColorAllocatorProvider = (function () {\n            function ColorAllocatorProvider() {\n                this.cache = [];\n            }\n            ColorAllocatorProvider.prototype.get = function (key) {\n                debug.assertValue(key, 'key');\n                for (var _i = 0, _a = this.cache; _i < _a.length; _i++) {\n                    var entry = _a[_i];\n                    if (entry.key === key)\n                        return entry.allocator;\n                }\n            };\n            ColorAllocatorProvider.prototype.register = function (key, colorAllocator) {\n                debug.assertValue(key, 'key');\n                debug.assertValue(colorAllocator, 'colorAllocator');\n                debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\n                this.cache.push({\n                    key: key,\n                    allocator: colorAllocator,\n                });\n                return this;\n            };\n            return ColorAllocatorProvider;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewRegression;\n        (function (DataViewRegression) {\n            // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\n            // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\n            var regressionXQueryName = 'RegressionX';\n            var regressionSeriesQueryName = 'RegressionSeries';\n            DataViewRegression.regressionYQueryName = 'RegressionY';\n            function run(options) {\n                debug.assertValue(options, 'options');\n                var dataViewMappings = options.dataViewMappings;\n                var visualDataViews = options.visualDataViews;\n                var dataRoles = options.dataRoles;\n                var objectDescriptors = options.objectDescriptors;\n                var objectDefinitions = options.objectDefinitions;\n                var colorAllocatorFactory = options.colorAllocatorFactory;\n                var transformSelects = options.transformSelects;\n                var projectionActiveItems = options.projectionActiveItems;\n                var metadata = options.metadata;\n                if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\n                    // compute linear regression line if applicable\n                    var roleKindByQueryRef = data.DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\n                    var projections = data.DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\n                    if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\n                        return visualDataViews;\n                    var applicableDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\n                    if (applicableDataViewMappings) {\n                        var regressionDataViewMapping = _.find(applicableDataViewMappings, function (dataViewMapping) {\n                            return dataViewMapping.usage && dataViewMapping.usage.regression;\n                        });\n                        if (regressionDataViewMapping) {\n                            var regressionDataViews = [];\n                            for (var _i = 0, visualDataViews_1 = visualDataViews; _i < visualDataViews_1.length; _i++) {\n                                var visualDataView = visualDataViews_1[_i];\n                                var regressionDataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                                if (regressionDataView)\n                                    regressionDataViews.push(regressionDataView);\n                            }\n                            if (!_.isEmpty(regressionDataViews))\n                                visualDataViews.push.apply(visualDataViews, regressionDataViews);\n                        }\n                    }\n                }\n                return visualDataViews;\n            }\n            DataViewRegression.run = run;\n            /**\n             * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\n             * It works on scalar axis only.\n             * The algorithm is as follows\n             *\n             * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\n             * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\n             * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\n             * If highlights values are present, repeat steps 2 & 3 using highlight values.\n             * 4. Create the new dataView using the points computed above\n             */\n            function linearRegressionTransform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\n                debug.assertValue(dataRoles, 'dataRoles');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!sourceDataView.categorical)\n                    return;\n                // Step 1\n                var xColumns = getColumnsForCartesianRoleKind(0 /* X */, sourceDataView.categorical, dataRoles);\n                var yColumns = getColumnsForCartesianRoleKind(1 /* Y */, sourceDataView.categorical, dataRoles);\n                if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\n                    return;\n                var xColumnSource = xColumns[0].source;\n                var yColumnSource = yColumns[0].source;\n                var combineSeries = true;\n                if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\n                    var regressionUsage = regressionDataViewMapping.usage.regression;\n                    var combineSeriesPropertyId = regressionUsage['combineSeries'];\n                    if (combineSeriesPropertyId) {\n                        combineSeries = powerbi.DataViewObjects.getValue(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\n                    }\n                }\n                // Step 2\n                var dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\n                var lineDefSet = calculateLineDefinitions(dataPointsBySeries);\n                if (!lineDefSet)\n                    return;\n                var xMin = lineDefSet.xMin;\n                var xMax = lineDefSet.xMax;\n                var shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\n                var highlightsLineDefSet;\n                if (shouldComputeHightlights) {\n                    var highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\n                    highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\n                    if (highlightsLineDefSet) {\n                        xMin = _.min([xMin, highlightsLineDefSet.xMin]);\n                        xMax = _.max([xMax, highlightsLineDefSet.xMax]);\n                    }\n                    else {\n                        shouldComputeHightlights = false;\n                    }\n                }\n                // Step 3\n                var valuesByTrend = [];\n                for (var _i = 0, _a = lineDefSet.lineDefs; _i < _a.length; _i++) {\n                    var trend = _a[_i];\n                    valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                }\n                var highlightsByTrend;\n                if (shouldComputeHightlights) {\n                    highlightsByTrend = [];\n                    for (var _b = 0, _c = highlightsLineDefSet.lineDefs; _b < _c.length; _b++) {\n                        var trend = _c[_b];\n                        highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                    }\n                }\n                // Step 4\n                var groupValues;\n                if (combineSeries) {\n                    groupValues = ['combinedRegressionSeries'];\n                }\n                else {\n                    // If we are producing a trend line per series we need to maintain the group identities so that we can map between the\n                    // trend line and the original series (to match the color for example).\n                    if (sourceDataView.categorical.values.source) {\n                        // Source data view has dynamic series.\n                        var groups = sourceDataView.categorical.values.grouped();\n                        groupValues = _.map(groups, function (group) { return group.name; });\n                    }\n                    else {\n                        // Source data view has static or no series.\n                        groupValues = _.map(yColumns, function (column) { return column.source.queryName; });\n                    }\n                }\n                // Step 5\n                var regressionDataView = createRegressionDataView(xColumnSource, yColumnSource, groupValues, [xMin, xMax], valuesByTrend, highlightsByTrend, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                return regressionDataView;\n            }\n            DataViewRegression.linearRegressionTransform = linearRegressionTransform;\n            function calculateLineDefinitions(dataPointsBySeries) {\n                var xMin;\n                var xMax;\n                var lineDefs = [];\n                for (var _i = 0, dataPointsBySeries_1 = dataPointsBySeries; _i < dataPointsBySeries_1.length; _i++) {\n                    var dataPointSet = dataPointsBySeries_1[_i];\n                    var unsortedXValues = dataPointSet.xValues;\n                    var unsortedYValues = dataPointSet.yValues;\n                    if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\n                        return;\n                    // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\n                    var xDataType = getDataType(unsortedXValues);\n                    if (!xDataType)\n                        return;\n                    var yDataType = getDataType(unsortedYValues);\n                    if (!yDataType)\n                        return;\n                    var sortedDataPointSet = sortValues(unsortedXValues, unsortedYValues);\n                    var minCategoryValue = sortedDataPointSet.xValues[0];\n                    var maxCategoryValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\n                    var lineDef = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\n                    xMin = _.min([xMin, minCategoryValue]);\n                    xMax = _.max([xMax, maxCategoryValue]);\n                    lineDefs.push(lineDef);\n                }\n                return {\n                    lineDefs: lineDefs,\n                    xMin: xMin,\n                    xMax: xMax,\n                };\n            }\n            function getColumnsForCartesianRoleKind(roleKind, categorical, roles) {\n                debug.assertValue(roleKind, 'roleKind');\n                debug.assertValue(categorical, 'categorical');\n                var columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n                var categories = categorical.categories;\n                if (_.isEmpty(categories))\n                    return;\n                debug.assert(categories.length === 1, 'composite category columns not supported');\n                var categoryColumn = categories[0];\n                columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n            }\n            function getColumnsWithRoleKind(roleKind, columns, roles) {\n                if (_.isEmpty(columns))\n                    return;\n                return _.filter(columns, function (column) {\n                    var _loop_1 = function(roleName) {\n                        if (!column.source.roles[roleName])\n                            return \"continue\";\n                        var role = _.find(roles, function (role) { return role.name === roleName; });\n                        if (role && role.cartesianKind === roleKind)\n                            return { value: true };\n                    };\n                    for (var roleName in column.source.roles) {\n                        var state_1 = _loop_1(roleName);\n                        if (typeof state_1 === \"object\") return state_1.value;\n                        if (state_1 === \"continue\") continue;\n                    }\n                    return false;\n                });\n            }\n            function getDataType(values) {\n                var firstNonNull = _.find(values, function (value) { return value != null; });\n                if (firstNonNull == null)\n                    return;\n                var dataType = typeof firstNonNull;\n                if (_.some(values, function (value) { return value != null && typeof value !== dataType; }))\n                    return;\n                return dataType;\n            }\n            function sortValues(unsortedXValues, unsortedYValues) {\n                debug.assertValue(unsortedXValues, 'unsortedXValues');\n                debug.assertValue(unsortedYValues, 'unsortedYValues');\n                var zippedValues = _.zip(unsortedXValues, unsortedYValues);\n                var _a = _.chain(zippedValues)\n                    .filter(function (valuePair) { return valuePair[0] != null && valuePair[1] != null; })\n                    .sortBy(function (valuePair) { return valuePair[0]; })\n                    .unzip()\n                    .value(), xValues = _a[0], yValues = _a[1];\n                return {\n                    xValues: xValues,\n                    yValues: yValues\n                };\n            }\n            /**\n             * Computes a line definition using linear regression.\n             *   xBar: average of X values, yBar: average of Y values\n             *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\n             *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\n             *   Slope: ssXY / ssXX\n             *   Intercept: yBar - xBar * slope\n             */\n            function computeRegressionLine(xValues, yValues) {\n                debug.assertValue(xValues, 'xValues');\n                debug.assertValue(yValues, 'yValues');\n                var xBar = _.sum(xValues) / xValues.length;\n                var yBar = _.sum(yValues) / yValues.length;\n                var ssXX = _.chain(xValues)\n                    .map(function (x) {\n                    return Math.pow((x - xBar), 2);\n                })\n                    .sum();\n                var ssXY = _.chain(xValues)\n                    .map(function (x, i) {\n                    return (x - xBar) * (yValues[i] - yBar);\n                })\n                    .sum();\n                var slope = ssXY / ssXX;\n                var intercept = yBar - (xBar * slope);\n                return {\n                    slope: slope,\n                    intercept: intercept\n                };\n            }\n            function computeLineYValues(lineDef, x1, x2) {\n                return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\n            }\n            function getValuesFromColumn(column, preferHighlights) {\n                if (preferHighlights) {\n                    // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\n                    var valueColumn = column;\n                    if (valueColumn.highlights) {\n                        return valueColumn.highlights;\n                    }\n                }\n                return column.values;\n            }\n            function getDataPointsBySeries(xColumns, yColumns, combineSeries, preferHighlights) {\n                var dataPointsBySeries = [];\n                var xValueArray = _.map(xColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var seriesYValues = _.map(yColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var multipleXValueColumns = xColumns.length > 1;\n                for (var i = 0; i < seriesYValues.length; i++) {\n                    var xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\n                    var yValues = seriesYValues[i];\n                    if (combineSeries && dataPointsBySeries.length > 0) {\n                        dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\n                        dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\n                    }\n                    else {\n                        dataPointsBySeries.push({\n                            xValues: xValues,\n                            yValues: yValues,\n                        });\n                    }\n                }\n                return dataPointsBySeries;\n            }\n            function createRegressionDataView(xColumnSource, yColumnSource, groupValues, categories, values, highlights, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(xColumnSource, 'xColumnSource');\n                debug.assertValue(yColumnSource, 'yColumnSource');\n                debug.assertValue(categories, 'categories');\n                debug.assertValue(values, 'values');\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertAnyValue(highlights, 'highlights');\n                debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\n                var xRole = regressionDataViewMapping.categorical.categories.for.in;\n                var grouped = regressionDataViewMapping.categorical.values.group;\n                var yRole;\n                var seriesRole;\n                if (grouped && !_.isEmpty(grouped.select)) {\n                    yRole = grouped.select[0].for ?\n                        grouped.select[0].for.in :\n                        grouped.select[0].bind.to;\n                    seriesRole = grouped.by;\n                }\n                if (!yRole || !seriesRole)\n                    return;\n                var categoricalRoles = (_a = {}, _a[xRole] = true, _a);\n                var valueRoles = (_b = {}, _b[yRole] = true, _b);\n                var seriesRoles = (_c = {}, _c[seriesRole] = true, _c);\n                var valuesBySeries = [];\n                for (var index in values) {\n                    var seriesData = {\n                        values: values[index],\n                    };\n                    if (highlights)\n                        seriesData.highlights = highlights[index];\n                    valuesBySeries.push([seriesData]);\n                }\n                var regressionDataView = data.createCategoricalDataViewBuilder()\n                    .withCategory({\n                    source: {\n                        displayName: xColumnSource.displayName,\n                        queryName: regressionXQueryName,\n                        type: xColumnSource.type,\n                        isMeasure: false,\n                        roles: categoricalRoles\n                    },\n                    values: categories,\n                    identityFrom: {\n                        fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\n                    },\n                })\n                    .withGroupedValues({\n                    groupColumn: {\n                        source: {\n                            displayName: yColumnSource.displayName + 'Regression',\n                            queryName: regressionSeriesQueryName,\n                            type: yColumnSource.type,\n                            isMeasure: yColumnSource.isMeasure,\n                            roles: seriesRoles\n                        },\n                        values: groupValues,\n                        identityFrom: {\n                            fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\n                        }\n                    },\n                    valueColumns: [{\n                            source: {\n                                displayName: yColumnSource.displayName,\n                                queryName: DataViewRegression.regressionYQueryName,\n                                type: yColumnSource.type,\n                                isMeasure: yColumnSource.isMeasure,\n                                roles: valueRoles\n                            },\n                        }],\n                    data: valuesBySeries\n                })\n                    .build();\n                data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\n                return regressionDataView;\n                var _a, _b, _c;\n            }\n            function hasHighlightValues(columns) {\n                return _.any(columns, function (column) {\n                    var valueColumn = column;\n                    return valueColumn.highlights != null;\n                });\n            }\n        })(DataViewRegression = data.DataViewRegression || (data.DataViewRegression = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelectTransform;\n        (function (DataViewSelectTransform) {\n            /** Convert selection info to projections */\n            function projectionsFromSelects(selects, projectionActiveItems) {\n                debug.assertAnyValue(selects, \"selects\");\n                debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\n                var projections = {};\n                for (var _i = 0, selects_1 = selects; _i < selects_1.length; _i++) {\n                    var select = selects_1[_i];\n                    if (!select)\n                        continue;\n                    var roles = select.roles;\n                    if (!roles)\n                        continue;\n                    for (var roleName in roles) {\n                        if (roles[roleName]) {\n                            var qp = projections[roleName];\n                            if (!qp)\n                                qp = projections[roleName] = new data.QueryProjectionCollection([]);\n                            qp.all().push({ queryRef: select.queryName });\n                            if (projectionActiveItems && projectionActiveItems[roleName])\n                                qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], function (activeItem) { return activeItem.queryRef; });\n                        }\n                    }\n                }\n                return projections;\n            }\n            DataViewSelectTransform.projectionsFromSelects = projectionsFromSelects;\n            /** Use selections and metadata to fashion query role kinds */\n            function createRoleKindFromMetadata(selects, metadata) {\n                var roleKindByQueryRef = {};\n                for (var _i = 0, _a = metadata.columns; _i < _a.length; _i++) {\n                    var column = _a[_i];\n                    if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\n                        continue;\n                    var select = selects[column.index];\n                    if (select) {\n                        var queryRef = select.queryName;\n                        if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\n                            roleKindByQueryRef[queryRef] = column.isMeasure ? powerbi.VisualDataRoleKind.Measure : powerbi.VisualDataRoleKind.Grouping;\n                        }\n                    }\n                }\n                return roleKindByQueryRef;\n            }\n            DataViewSelectTransform.createRoleKindFromMetadata = createRoleKindFromMetadata;\n        })(DataViewSelectTransform = data.DataViewSelectTransform || (data.DataViewSelectTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createCategoricalEvalContext(colorAllocatorProvider, dataViewCategorical) {\n            return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\n        }\n        data.createCategoricalEvalContext = createCategoricalEvalContext;\n        var CategoricalEvalContext = (function () {\n            function CategoricalEvalContext(colorAllocatorProvider, dataView) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.columnsByRole = {};\n            }\n            CategoricalEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            CategoricalEvalContext.prototype.getExprValue = function (expr) {\n                return;\n            };\n            CategoricalEvalContext.prototype.getRoleValue = function (roleName) {\n                var columnsByRole = this.columnsByRole;\n                var column = columnsByRole[roleName];\n                if (!column)\n                    column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\n                if (!column)\n                    return;\n                var index = this.index;\n                if (index != null)\n                    return column.values[this.index];\n            };\n            CategoricalEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.index = index;\n            };\n            return CategoricalEvalContext;\n        }());\n        function findRuleInputColumn(dataViewCategorical, inputRole) {\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n            return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\n                findRuleInputInColumns(dataViewCategorical.categories, inputRole);\n        }\n        function findRuleInputInColumns(columns, inputRole) {\n            debug.assertAnyValue(columns, 'columns');\n            if (!columns)\n                return;\n            for (var _i = 0, columns_7 = columns; _i < columns_7.length; _i++) {\n                var column = columns_7[_i];\n                var roles = column.source.roles;\n                if (!roles || !roles[inputRole])\n                    continue;\n                return column;\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createTableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms) {\n            return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\n        }\n        data.createTableEvalContext = createTableEvalContext;\n        var TableEvalContext = (function () {\n            function TableEvalContext(colorAllocatorProvider, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            TableEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            TableEvalContext.prototype.getExprValue = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var rowIdx = this.rowIdx;\n                if (rowIdx == null)\n                    return;\n                return data.getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\n            };\n            TableEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            TableEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.rowIdx = index;\n            };\n            return TableEvalContext;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var RuleEvaluation = (function () {\n            function RuleEvaluation() {\n            }\n            // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\n            RuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\n            };\n            return RuleEvaluation;\n        }());\n        data.RuleEvaluation = RuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ColorRuleEvaluation = (function (_super) {\n            __extends(ColorRuleEvaluation, _super);\n            function ColorRuleEvaluation(inputRole, allocator) {\n                debug.assertValue(inputRole, 'inputRole');\n                debug.assertValue(allocator, 'allocator');\n                _super.call(this);\n                this.inputRole = inputRole;\n                this.allocator = allocator;\n            }\n            ColorRuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertValue(evalContext, 'evalContext');\n                var value = evalContext.getRoleValue(this.inputRole);\n                if (value !== undefined)\n                    return this.allocator.color(value);\n            };\n            return ColorRuleEvaluation;\n        }(data.RuleEvaluation));\n        data.ColorRuleEvaluation = ColorRuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var inherit = powerbi.Prototype.inherit;\n            var inheritSingle = powerbi.Prototype.inheritSingle;\n            var ArrayExtensions = jsCommon.ArrayExtensions;\n            var DataViewMatrixUtils;\n            (function (DataViewMatrixUtils) {\n                /**\n                 * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the\n                 * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the\n                 * particular leaf node in the context of this forEachLeafNode(...) invocation.\n                 *\n                 * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\n                 *\n                 * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified\n                 * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\n                 * then treePath will be an array of length 1 containing that very node.\n                 *\n                 * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\n                 * If your callback needs to retain a copy of the treePath, please clone the array before returning.\n                 */\n                function forEachLeafNode(rootNodes, callback) {\n                    debug.assertAnyValue(rootNodes, 'rootNodes');\n                    debug.assertValue(callback, 'callback');\n                    // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\n                    // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \n                    // for the fact that all the properties on DataViewMatrixNode are optional...\n                    if (rootNodes) {\n                        if (isNodeArray(rootNodes)) {\n                            var index = 0;\n                            for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {\n                                var rootNode = rootNodes_1[_i];\n                                if (rootNode) {\n                                    index = forEachLeafNodeRecursive(rootNode, index, [], callback);\n                                }\n                            }\n                        }\n                        else {\n                            forEachLeafNodeRecursive(rootNodes, 0, [], callback);\n                        }\n                    }\n                }\n                DataViewMatrixUtils.forEachLeafNode = forEachLeafNode;\n                function isNodeArray(nodeOrNodeArray) {\n                    return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\n                }\n                /**\n                 * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\n                 * Returns the index for the next node after the last node that this function invokes callback with.\n                 *\n                 * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\n                 */\n                function forEachLeafNodeRecursive(matrixNode, nextIndex, treePath, callback) {\n                    debug.assertValue(matrixNode, 'matrixNode');\n                    debug.assertValue(treePath, 'treePath');\n                    debug.assertValue(callback, 'callback');\n                    // If treePath already contains matrixNode, then either one of the following errors has happened:\n                    // 1. the caller code mistakenly added matrixNode to treePath, or\n                    // 2. the callback modified treePath by adding a node to it, or\n                    // 3. the matrix hierarchy contains a cyclical node reference.');\n                    debug.assert(!_.contains(treePath, matrixNode), 'pre-condition: treePath must not already contain matrixNode');\n                    treePath.push(matrixNode);\n                    if (_.isEmpty(matrixNode.children)) {\n                        callback(matrixNode, nextIndex, treePath);\n                        nextIndex++;\n                    }\n                    else {\n                        var children = matrixNode.children;\n                        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n                            var nextChild = children_1[_i];\n                            if (nextChild) {\n                                nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\n                            }\n                        }\n                    }\n                    debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\n                    treePath.pop();\n                    return nextIndex;\n                }\n                /**\n                 * Returned an object tree where each node and its children property are inherited from the specified node\n                 * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\n                 *\n                 * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array\n                 * property, i.e. its children property is the same array object referenced in the input node's object tree.\n                 *\n                 * @param node The input node with the hierarchy object tree.\n                 * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\n                 * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is\n                 * not already an inherited object. Same goes for the node's children property.  This is useful for creating\n                 * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for\n                 * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains\n                 * inherited objects.\n                 */\n                function inheritMatrixNodeHierarchy(node, deepestLevelToInherit, useInheritSingle) {\n                    debug.assertValue(node, 'node');\n                    debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\n                    debug.assertValue(useInheritSingle, 'useInheritSingle');\n                    var returnNode = node;\n                    // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\n                    // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\n                    // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\n                    //  {\n                    //    \"level\": 0,\n                    //    \"isSubtotal\": true,\n                    //    \"children\": [\n                    //      { \"level\": 2, \"isSubtotal\": true },\n                    //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\n                    //    ]\n                    //  }\n                    var isRootNode = _.isUndefined(node.level);\n                    var shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\n                    if (shouldInheritCurrentNode) {\n                        var inheritFunc = useInheritSingle ? inheritSingle : inherit;\n                        var inheritedNode = inheritFunc(node);\n                        var shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\n                        if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\n                            inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\n                            for (var i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\n                                inheritedNode.children[i] =\n                                    inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\n                            }\n                        }\n                        returnNode = inheritedNode;\n                    }\n                    return returnNode;\n                }\n                DataViewMatrixUtils.inheritMatrixNodeHierarchy = inheritMatrixNodeHierarchy;\n                /**\n                 * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\n                 * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\n                 * Year === 2016, Quarter === 'Qtr 1', Month === 1.\n                 *\n                 * Returns false if the specified matrixOrHierarchy does not contain any composite group,\n                 * or if matrixOrHierarchy is null or undefined.\n                 */\n                function containsCompositeGroup(matrixOrHierarchy) {\n                    debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\n                    var hasCompositeGroup = false;\n                    if (matrixOrHierarchy) {\n                        if (isMatrix(matrixOrHierarchy)) {\n                            hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\n                                containsCompositeGroup(matrixOrHierarchy.columns);\n                        }\n                        else {\n                            var hierarchyLevels = matrixOrHierarchy.levels;\n                            if (!_.isEmpty(hierarchyLevels)) {\n                                for (var _i = 0, hierarchyLevels_1 = hierarchyLevels; _i < hierarchyLevels_1.length; _i++) {\n                                    var level = hierarchyLevels_1[_i];\n                                    // it takes at least 2 columns at the same hierarchy level to form a composite group...\n                                    if (level.sources && (level.sources.length >= 2)) {\n                                        debug.assert(_.all(level.sources, function (sourceColumn) { return sourceColumn.isMeasure === level.sources[0].isMeasure; }), 'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\n                                        // Measure headers are not group\n                                        var isMeasureHeadersLevel = level.sources[0].isMeasure;\n                                        if (!isMeasureHeadersLevel) {\n                                            hasCompositeGroup = true;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return hasCompositeGroup;\n                }\n                DataViewMatrixUtils.containsCompositeGroup = containsCompositeGroup;\n                function isMatrix(matrixOrHierarchy) {\n                    return 'rows' in matrixOrHierarchy &&\n                        'columns' in matrixOrHierarchy &&\n                        'valueSources' in matrixOrHierarchy;\n                }\n            })(DataViewMatrixUtils = utils.DataViewMatrixUtils || (utils.DataViewMatrixUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var DataViewMetadataColumnUtils;\n            (function (DataViewMetadataColumnUtils) {\n                /**\n                 * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\n                 */\n                function isForRole(metadataColumn, targetRole) {\n                    debug.assertValue(metadataColumn, 'metadataColumn');\n                    debug.assertValue(targetRole, 'targetRole');\n                    var roles = metadataColumn.roles;\n                    return roles && roles[targetRole];\n                }\n                DataViewMetadataColumnUtils.isForRole = isForRole;\n                /**\n                 * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\n                 *\n                 * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the\n                 * specified columnSources must be a non-filtered array of column sources from the DataView, such as\n                 * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\n                 *\n                 * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\n                 * @param projection The projection ordering.  It must contain an ordering for the specified role.\n                 * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\n                 */\n                function joinMetadataColumnsAndProjectionOrder(columnSources, projection, role) {\n                    debug.assertAnyValue(columnSources, 'columnSources');\n                    debug.assert(_.all(columnSources, function (column) { return _.isNumber(column.index); }), 'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\n                    debug.assertNonEmpty(projection[role], 'projection[role]');\n                    debug.assert(_.all(columnSources, function (column) { return !isForRole(column, role) || _.contains(projection[role], column.index); }), 'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\n                    var jointResult = [];\n                    if (!_.isEmpty(columnSources)) {\n                        var projectionOrderSelectIndices = projection[role];\n                        var selectIndexToProjectionIndexMap = {};\n                        for (var i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\n                            var selectIndex = projectionOrderSelectIndices[i];\n                            selectIndexToProjectionIndexMap[selectIndex] = i;\n                        }\n                        for (var j = 0, jlen = columnSources.length; j < jlen; j++) {\n                            var column = columnSources[j];\n                            if (isForRole(column, role)) {\n                                var jointColumnInfo = {\n                                    metadataColumn: column,\n                                    sourceIndex: j,\n                                    projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\n                                };\n                                jointResult.push(jointColumnInfo);\n                            }\n                        }\n                    }\n                    return jointResult;\n                }\n                DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder = joinMetadataColumnsAndProjectionOrder;\n            })(DataViewMetadataColumnUtils = utils.DataViewMetadataColumnUtils || (utils.DataViewMetadataColumnUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ConceptualSchema = (function () {\n            function ConceptualSchema() {\n            }\n            ConceptualSchema.prototype.findProperty = function (entityName, propertyName) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                return entity.properties.withName(propertyName);\n            };\n            ConceptualSchema.prototype.findHierarchy = function (entityName, name) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.hierarchies))\n                    return;\n                return entity.hierarchies.withName(name);\n            };\n            ConceptualSchema.prototype.findHierarchyByVariation = function (variationEntityName, variationColumnName, variationName, hierarchyName) {\n                var variationEntity = this.entities.withName(variationEntityName);\n                if (!variationEntity || _.isEmpty(variationEntity.properties))\n                    return;\n                var variationProperty = variationEntity.properties.withName(variationColumnName);\n                if (!variationProperty)\n                    return;\n                var variationColumn = variationProperty.column;\n                if (!variationColumn || _.isEmpty(variationColumn.variations))\n                    return;\n                var variation = variationColumn.variations.withName(variationName);\n                if (variation) {\n                    var targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\n                    if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\n                        return;\n                    return targetEntity.hierarchies.withName(hierarchyName);\n                }\n            };\n            /**\n            * Returns the first property of the entity whose kpi is tied to kpiProperty\n            */\n            ConceptualSchema.prototype.findPropertyWithKpi = function (entityName, kpiProperty) {\n                debug.assertValue(kpiProperty, 'kpiProperty');\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {\n                    var prop = _a[_i];\n                    if (prop &&\n                        prop.measure &&\n                        prop.measure.kpi &&\n                        (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\n                        return prop;\n                }\n                return;\n            };\n            return ConceptualSchema;\n        }());\n        data.ConceptualSchema = ConceptualSchema;\n        // TODO: Remove this (replaced by ValueType)\n        (function (ConceptualDataCategory) {\n            ConceptualDataCategory[ConceptualDataCategory[\"None\"] = 0] = \"None\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Address\"] = 1] = \"Address\";\n            ConceptualDataCategory[ConceptualDataCategory[\"City\"] = 2] = \"City\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Company\"] = 3] = \"Company\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Continent\"] = 4] = \"Continent\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Country\"] = 5] = \"Country\";\n            ConceptualDataCategory[ConceptualDataCategory[\"County\"] = 6] = \"County\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Date\"] = 7] = \"Date\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Image\"] = 8] = \"Image\";\n            ConceptualDataCategory[ConceptualDataCategory[\"ImageUrl\"] = 9] = \"ImageUrl\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Latitude\"] = 10] = \"Latitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Longitude\"] = 11] = \"Longitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Organization\"] = 12] = \"Organization\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Place\"] = 13] = \"Place\";\n            ConceptualDataCategory[ConceptualDataCategory[\"PostalCode\"] = 14] = \"PostalCode\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Product\"] = 15] = \"Product\";\n            ConceptualDataCategory[ConceptualDataCategory[\"StateOrProvince\"] = 16] = \"StateOrProvince\";\n            ConceptualDataCategory[ConceptualDataCategory[\"WebUrl\"] = 17] = \"WebUrl\";\n        })(data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));\n        var ConceptualDataCategory = data.ConceptualDataCategory;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var FieldExprPattern = powerbi.data.FieldExprPattern;\n    var ScriptResultUtil;\n    (function (ScriptResultUtil) {\n        function findScriptResult(dataViewMappings) {\n            if (dataViewMappings && dataViewMappings.length === 1) {\n                return dataViewMappings[0].scriptResult;\n            }\n            return undefined;\n        }\n        ScriptResultUtil.findScriptResult = findScriptResult;\n        function extractScriptResult(dataViewMappings) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult) {\n                var objects = dataViewMappings[0].metadata.objects;\n                var source = powerbi.DataViewObjects.getValue(objects, scriptResult.script.source);\n                var provider = powerbi.DataViewObjects.getValue(objects, scriptResult.script.provider);\n                return {\n                    source: source,\n                    provider: provider\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResult = extractScriptResult;\n        function extractScriptResultFromVisualConfig(dataViewMappings, objects) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult && objects) {\n                var scriptSource = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\n                var provider = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\n                return {\n                    source: scriptSource ? scriptSource.value : null,\n                    provider: provider ? provider.value : null\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResultFromVisualConfig = extractScriptResultFromVisualConfig;\n        function getScriptInput(projections, selects, schema) {\n            var scriptInput = {\n                VariableName: \"dataset\",\n                Columns: []\n            };\n            // Go over all the projections, and create an input column according to the order\n            // of the projections (including duplicate expressions)\n            if (projections && selects && !_.isEmpty(selects)) {\n                var scriptInputColumnNames = [];\n                var scriptInputColumns = [];\n                for (var role in projections) {\n                    for (var _i = 0, _a = projections[role].all(); _i < _a.length; _i++) {\n                        var projection = _a[_i];\n                        var select = selects.withName(projection.queryRef);\n                        if (select) {\n                            var scriptInputColumn = {\n                                QueryName: select.name,\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\n                            };\n                            scriptInputColumns.push(scriptInputColumn);\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\n                        }\n                    }\n                }\n                // Make sure the names of the columns are unique\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\n                // Update the names of the columns\n                for (var i = 0; i < scriptInputColumnNames.length; i++) {\n                    var scriptInputColumn = scriptInputColumns[i];\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\n                }\n                scriptInput.Columns = scriptInputColumns;\n            }\n            return scriptInput;\n        }\n        ScriptResultUtil.getScriptInput = getScriptInput;\n        var ScriptInputColumnNameVisitor = (function () {\n            function ScriptInputColumnNameVisitor(federatedSchema) {\n                this.federatedSchema = federatedSchema;\n            }\n            ScriptInputColumnNameVisitor.prototype.visitColumn = function (column) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntity = function (entity) {\n                return entity.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                return entityAggr.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchy = function (hierarchy) {\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                /*Hierarchy levels are not supported yet*/\n                return;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitMeasure = function (measure) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitSelectRef = function (selectRef) {\n                return FieldExprPattern.visit(selectRef, this);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitPercentile = function (percentile) {\n                return FieldExprPattern.visit(percentile.arg, this);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n            };\n            ScriptInputColumnNameVisitor.getNameForHierarchy = function (pattern, federatedScheam) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedScheam.schema(pattern.schema), hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\n                if (hierarchy)\n                    return hierarchy.name;\n            };\n            ScriptInputColumnNameVisitor.getNameForProperty = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedSchema.schema(pattern.schema), property = schema.findProperty(pattern.entity, pattern.name);\n                if (property)\n                    return property.name;\n            };\n            ScriptInputColumnNameVisitor.getVariationLevelName = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var source = pattern.source;\n                var prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\n                if (!prop)\n                    return;\n                var variations = prop.column.variations;\n                for (var _i = 0, variations_1 = variations; _i < variations_1.length; _i++) {\n                    var variation = variations_1[_i];\n                    if (variation.name === pattern.variationName)\n                        for (var _a = 0, _b = variation.defaultHierarchy.levels; _a < _b.length; _a++) {\n                            var level = _b[_a];\n                            if (level.name === pattern.level.level)\n                                return level.column.name;\n                        }\n                }\n            };\n            return ScriptInputColumnNameVisitor;\n        }());\n    })(ScriptResultUtil = powerbi.ScriptResultUtil || (powerbi.ScriptResultUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var segmentation;\n        (function (segmentation) {\n            var DataViewMerger;\n            (function (DataViewMerger) {\n                function mergeDataViews(source, segment) {\n                    if (!powerbi.DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\n                        debug.assertFail(\"Cannot merge data views with different metadata columns\");\n                    }\n                    // The last segment is complete. We mark the source as complete.\n                    if (!segment.metadata.segment)\n                        delete source.metadata.segment;\n                    if (source.table && segment.table)\n                        mergeTables(source.table, segment.table);\n                    if (source.categorical && segment.categorical)\n                        mergeCategorical(source.categorical, segment.categorical);\n                    // Tree cannot support subtotals hence we can get into situations\n                    // where a node has no children in one segment and more than 1 child\n                    // in another segment.\n                    if (source.tree && segment.tree)\n                        mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\n                    if (source.matrix && segment.matrix)\n                        mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\n                }\n                DataViewMerger.mergeDataViews = mergeDataViews;\n                /** Note: Public for testability */\n                function mergeTables(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    if (_.isEmpty(segment.rows))\n                        return;\n                    var mergeIndex = segment.lastMergeIndex + 1;\n                    merge(source.rows, segment.rows, mergeIndex);\n                    debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');\n                    if (segment.identity)\n                        merge(source.identity, segment.identity, mergeIndex);\n                }\n                DataViewMerger.mergeTables = mergeTables;\n                /**\n                 * Merge categories values and identities\n                 *\n                 * Note: Public for testability\n                 */\n                function mergeCategorical(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    // Merge categories values and identities\n                    if (source.categories && segment.categories) {\n                        var segmentCategoriesLength = segment.categories.length;\n                        debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\n                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\n                            var segmentCategory = segment.categories[categoryIndex];\n                            var sourceCategory = source.categories[categoryIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\n                            debug.assert(_.isUndefined(sourceCategory.values) ? _.isUndefined(sourceCategory.identity) : true, 'Source category is missing values but has identities.');\n                            var mergeIndex = segment.lastMergeIndex + 1;\n                            if (segmentCategory.values) {\n                                merge(sourceCategory.values, segmentCategory.values, mergeIndex);\n                            }\n                            if (segmentCategory.identity) {\n                                merge(sourceCategory.identity, segmentCategory.identity, mergeIndex);\n                            }\n                        }\n                    }\n                    // Merge values for each value column\n                    if (source.values && segment.values) {\n                        var segmentValuesLength = segment.values.length;\n                        debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\n                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {\n                            var segmentValue = segment.values[valueIndex];\n                            var sourceValue = source.values[valueIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\n                            if (!sourceValue.values && segmentValue.values) {\n                                sourceValue.values = [];\n                            }\n                            var mergeIndex = segment.lastMergeIndex + 1;\n                            if (segmentValue.values) {\n                                merge(sourceValue.values, segmentValue.values, mergeIndex);\n                            }\n                            if (segmentValue.highlights) {\n                                merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);\n                            }\n                        }\n                    }\n                }\n                DataViewMerger.mergeCategorical = mergeCategorical;\n                /**\n                 * Merges the segment array starting at the specified index into the source array\n                 * and returns the segment slice that wasn't merged.\n                 * The segment array is spliced up to specified index in the process.\n                 */\n                function merge(source, segment, index) {\n                    if (index >= segment.length)\n                        return segment;\n                    var result = [];\n                    if (index !== undefined)\n                        result = segment.splice(0, index);\n                    Array.prototype.push.apply(source, segment);\n                    return result;\n                }\n                /** Note: Public for testability */\n                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {\n                    debug.assertValue(sourceRoot, 'sourceRoot');\n                    debug.assertValue(segmentRoot, 'segmentRoot');\n                    if (!segmentRoot.children || segmentRoot.children.length === 0)\n                        return;\n                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\n                        sourceRoot.children = segmentRoot.children;\n                        return;\n                    }\n                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, \"Source tree has different structure than segment.\");\n                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\n                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\n                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\n                    if (mergedChildren.length > 0)\n                        mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\n                }\n                DataViewMerger.mergeTreeNodes = mergeTreeNodes;\n                function findFirstAppendIndex(children) {\n                    if (children.length === 0)\n                        return 0;\n                    var i = 0;\n                    for (; i < children.length; i++) {\n                        var childSegment = children[i];\n                        if (!childSegment.isMerge)\n                            break;\n                    }\n                    return i;\n                }\n            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));\n        })(segmentation = data.segmentation || (data.segmentation = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Rewrites an expression tree, including all descendant nodes. */\n        var SQExprRewriter = (function () {\n            function SQExprRewriter() {\n            }\n            SQExprRewriter.prototype.visitColumnRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitMeasureRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitAggr = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQAggregationExpr(rewrittenArg, expr.func);\n            };\n            SQExprRewriter.prototype.visitSelectRef = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitPercentile = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);\n            };\n            SQExprRewriter.prototype.visitHierarchy = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyExpr(rewrittenArg, expr.hierarchy);\n            };\n            SQExprRewriter.prototype.visitHierarchyLevel = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyLevelExpr(rewrittenArg, expr.level);\n            };\n            SQExprRewriter.prototype.visitPropertyVariationSource = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\n            };\n            SQExprRewriter.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitAnd = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitBetween = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);\n                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\n                    return orig;\n                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\n            };\n            SQExprRewriter.prototype.visitIn = function (orig) {\n                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues;\n                for (var i = 0, len = origValues.length; i < len; i++) {\n                    var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);\n                    if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\n                        rewrittenValues = ArrayExtensions.take(origValues, i);\n                    if (rewrittenValues)\n                        rewrittenValues.push(rewrittenValueTuple);\n                }\n                if (origArgs === rewrittenArgs && !rewrittenValues)\n                    return orig;\n                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues);\n            };\n            SQExprRewriter.prototype.rewriteAll = function (origExprs) {\n                debug.assertValue(origExprs, 'origExprs');\n                var rewrittenResult;\n                for (var i = 0, len = origExprs.length; i < len; i++) {\n                    var origExpr = origExprs[i], rewrittenExpr = origExpr.accept(this);\n                    if (origExpr !== rewrittenExpr && !rewrittenResult)\n                        rewrittenResult = ArrayExtensions.take(origExprs, i);\n                    if (rewrittenResult)\n                        rewrittenResult.push(rewrittenExpr);\n                }\n                return rewrittenResult || origExprs;\n            };\n            SQExprRewriter.prototype.visitOr = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitCompare = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitContains = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitExists = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQExistsExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNot = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQNotExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitStartsWith = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitConstant = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitDateSpan = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitDateAdd = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNow = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitDefaultValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitAnyValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitArithmetic = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\n            };\n            SQExprRewriter.prototype.visitScopedEval = function (orig) {\n                var origExpression = orig.expression, rewrittenExpression = origExpression.accept(this), origScope = orig.scope, rewrittenScope = this.rewriteAll(origScope);\n                if (origExpression === rewrittenExpression && origScope === rewrittenScope)\n                    return orig;\n                return new data.SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\n            };\n            SQExprRewriter.prototype.visitWithRef = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitFillRule = function (orig) {\n                var origInput = orig.input, rewrittenInput = origInput.accept(this);\n                var origRule = orig.rule;\n                var origGradient2 = origRule.linearGradient2, rewrittenGradient2 = origGradient2;\n                if (origGradient2) {\n                    rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\n                }\n                var origGradient3 = origRule.linearGradient3, rewrittenGradient3 = origGradient3;\n                if (origGradient3) {\n                    rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\n                }\n                if (origInput !== rewrittenInput ||\n                    origGradient2 !== rewrittenGradient2 ||\n                    origGradient3 !== rewrittenGradient3) {\n                    var rewrittenRule = {};\n                    if (rewrittenGradient2)\n                        rewrittenRule.linearGradient2 = rewrittenGradient2;\n                    if (rewrittenGradient3)\n                        rewrittenRule.linearGradient3 = rewrittenGradient3;\n                    return new data.SQFillRuleExpr(rewrittenInput, rewrittenRule);\n                }\n                return orig;\n            };\n            SQExprRewriter.prototype.visitLinearGradient2 = function (origGradient2) {\n                debug.assertValue(origGradient2, 'origGradient2');\n                var origMin = origGradient2.min, rewrittenMin = this.visitFillRuleStop(origMin), origMax = origGradient2.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient2;\n            };\n            SQExprRewriter.prototype.visitLinearGradient3 = function (origGradient3) {\n                debug.assertValue(origGradient3, 'origGradient3');\n                var origMin = origGradient3.min, rewrittenMin = this.visitFillRuleStop(origMin), origMid = origGradient3.mid, rewrittenMid = this.visitFillRuleStop(origMid), origMax = origGradient3.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        mid: rewrittenMid,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient3;\n            };\n            SQExprRewriter.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                var origColor = stop.color, rewrittenColor = stop.color.accept(this);\n                var origValue = stop.value, rewrittenValue = origValue;\n                if (origValue)\n                    rewrittenValue = origValue.accept(this);\n                if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\n                    var rewrittenStop = {\n                        color: rewrittenColor\n                    };\n                    if (rewrittenValue)\n                        rewrittenStop.value = rewrittenValue;\n                    return rewrittenStop;\n                }\n                return stop;\n            };\n            SQExprRewriter.prototype.visitResourcePackageItem = function (orig) {\n                return orig;\n            };\n            return SQExprRewriter;\n        }());\n        data.SQExprRewriter = SQExprRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for writing equality comparisons against a field to an SQInExpr. */\n        var EqualsToInRewriter;\n        (function (EqualsToInRewriter) {\n            function run(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(new Rewriter());\n            }\n            EqualsToInRewriter.run = run;\n            var Rewriter = (function (_super) {\n                __extends(Rewriter, _super);\n                function Rewriter() {\n                    _super.call(this);\n                }\n                Rewriter.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return this.visitUnsupported(expr);\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var leftIsComparand = this.isComparand(expr.left);\n                    var rightIsComparand = this.isComparand(expr.right);\n                    if (leftIsComparand === rightIsComparand)\n                        return this.visitUnsupported(expr);\n                    var operand = leftIsComparand\n                        ? expr.left\n                        : expr.right;\n                    var value = leftIsComparand\n                        ? expr.right\n                        : expr.left;\n                    var current = this.current;\n                    if (!current) {\n                        return data.SQExprBuilder.inExpr([operand], [[value]]);\n                    }\n                    current.add(operand, value);\n                    return expr;\n                };\n                Rewriter.prototype.visitOr = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current;\n                    if (!this.current) {\n                        current = this.current = new InBuilder();\n                    }\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                    if (current) {\n                        this.current = null;\n                        return current.complete() || expr;\n                    }\n                    return expr;\n                };\n                Rewriter.prototype.visitAnd = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current = this.current;\n                    if (current) {\n                        // NOTE: Composite keys are not supported by this algorithm.\n                        current.cancel();\n                        return expr;\n                    }\n                    return _super.prototype.visitAnd.call(this, expr);\n                };\n                Rewriter.prototype.visitUnsupported = function (expr) {\n                    var current = this.current;\n                    if (current)\n                        current.cancel();\n                    return expr;\n                };\n                Rewriter.prototype.isSupported = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return expr instanceof data.SQCompareExpr\n                        || expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQConstantExpr\n                        || expr instanceof data.SQHierarchyLevelExpr\n                        || expr instanceof data.SQOrExpr\n                        || expr instanceof data.SQAndExpr;\n                };\n                Rewriter.prototype.isComparand = function (expr) {\n                    return expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQHierarchyLevelExpr;\n                };\n                return Rewriter;\n            }(data.SQExprRewriter));\n            var InBuilder = (function () {\n                function InBuilder() {\n                }\n                InBuilder.prototype.add = function (operand, value) {\n                    debug.assertValue(operand, 'operand');\n                    debug.assertValue(value, 'value');\n                    if (this.cancelled)\n                        return;\n                    if (this.operand && !data.SQExpr.equals(operand, this.operand)) {\n                        this.cancel();\n                        return;\n                    }\n                    this.operand = operand;\n                    var values = this.values;\n                    if (!values)\n                        values = this.values = [];\n                    values.push(value);\n                };\n                InBuilder.prototype.cancel = function () {\n                    this.cancelled = true;\n                };\n                InBuilder.prototype.complete = function () {\n                    if (this.cancelled || !this.operand)\n                        return;\n                    return data.SQExprBuilder.inExpr([this.operand], _.map(this.values, function (v) { return [v]; }));\n                };\n                return InBuilder;\n            }());\n        })(EqualsToInRewriter = data.EqualsToInRewriter || (data.EqualsToInRewriter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asScopeIdsContainer(filter, fieldSQExprs) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\n                var filterItems = filter.conditions();\n                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\n                var filterItem = filterItems[0];\n                if (filterItem) {\n                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\n                    if (filterItem.accept(visitor))\n                        return visitor.getResult();\n                }\n            }\n            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;\n            /** Gets a comparand value from the given DataViewScopeIdentity. */\n            function getFirstComparandValue(identity) {\n                debug.assertValue(identity, 'identity');\n                var comparandExpr = identity.expr.accept(new FindComparandVisitor());\n                if (comparandExpr)\n                    return comparandExpr.value;\n            }\n            SQExprConverter.getFirstComparandValue = getFirstComparandValue;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\n        var FilterScopeIdsCollectorVisitor = (function (_super) {\n            __extends(FilterScopeIdsCollectorVisitor, _super);\n            function FilterScopeIdsCollectorVisitor(fieldSQExprs) {\n                _super.call(this);\n                this.isRoot = true;\n                this.isNot = false;\n                this.keyExprsCount = null;\n                this.valueExprs = [];\n                // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\n                // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\n                // need to drop it in order to use JsonComparer.\n                this.fieldExprs = [];\n                for (var _i = 0, fieldSQExprs_1 = fieldSQExprs; _i < fieldSQExprs_1.length; _i++) {\n                    var field = fieldSQExprs_1[_i];\n                    this.fieldExprs.push(data.SQExprBuilder.removeEntityVariables(field));\n                }\n            }\n            FilterScopeIdsCollectorVisitor.prototype.getResult = function () {\n                debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');\n                var valueExprs = this.valueExprs, scopeIds = [];\n                var valueCount = this.keyExprsCount || 1;\n                for (var startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\n                    var values = valueExprs.slice(startIndex, endIndex);\n                    var scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\n                    if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, powerbi.DataViewScopeIdentity.equals))\n                        scopeIds.push(scopeId);\n                    startIndex += valueCount;\n                    endIndex += valueCount;\n                }\n                return {\n                    isNot: this.isNot,\n                    scopeIds: scopeIds,\n                };\n            };\n            FilterScopeIdsCollectorVisitor.getScopeIdentity = function (fieldExprs, valueExprs) {\n                debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\n                debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\n                var compoundSQExpr;\n                for (var i = 0, len = fieldExprs.length; i < len; i++) {\n                    var equalsExpr = data.SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\n                    if (!compoundSQExpr)\n                        compoundSQExpr = equalsExpr;\n                    else\n                        compoundSQExpr = data.SQExprBuilder.and(compoundSQExpr, equalsExpr);\n                }\n                return data.createDataViewScopeIdentity(compoundSQExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitOr = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitNot = function (expr) {\n                if (!this.isRoot)\n                    return this.unsupportedSQExpr();\n                this.isNot = true;\n                return expr.arg.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function (expr) {\n                if (this.isRoot && expr.type.primitiveType === powerbi.PrimitiveType.Null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                if (expr.comparison !== data.QueryComparisonKind.Equal)\n                    return this.unsupportedSQExpr();\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitIn = function (expr) {\n                this.keyExprsCount = 0;\n                var result;\n                this.isRoot = false;\n                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {\n                    var arg = _a[_i];\n                    result = arg.accept(this);\n                    if (!result)\n                        return this.unsupportedSQExpr();\n                    this.keyExprsCount++;\n                }\n                if (this.keyExprsCount !== this.fieldExprs.length)\n                    return this.unsupportedSQExpr();\n                var values = expr.values;\n                for (var _b = 0, values_1 = values; _b < values_1.length; _b++) {\n                    var valueTuple = values_1[_b];\n                    var jlen = valueTuple.length;\n                    debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\n                    for (var _c = 0, valueTuple_1 = valueTuple; _c < valueTuple_1.length; _c++) {\n                        var value = valueTuple_1[_c];\n                        result = value.accept(this);\n                        if (!result)\n                            return this.unsupportedSQExpr();\n                    }\n                }\n                return result;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function (expr) {\n                if (this.isRoot)\n                    return this.unsupportedSQExpr();\n                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);\n                if (this.keyExprsCount !== null)\n                    return data.SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\n                return data.SQExpr.equals(this.fieldExprs[0], fixedExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefaultValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitAnyValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function (expr) {\n                return this.unsupportedSQExpr();\n            };\n            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function () {\n                return false;\n            };\n            return FilterScopeIdsCollectorVisitor;\n        }(data.DefaultSQExprVisitor));\n        var FindComparandVisitor = (function (_super) {\n            __extends(FindComparandVisitor, _super);\n            function FindComparandVisitor() {\n                _super.apply(this, arguments);\n            }\n            FindComparandVisitor.prototype.visitAnd = function (expr) {\n                return expr.left.accept(this) || expr.right.accept(this);\n            };\n            FindComparandVisitor.prototype.visitCompare = function (expr) {\n                if (expr.comparison === data.QueryComparisonKind.Equal) {\n                    if (expr.right instanceof data.SQConstantExpr)\n                        return expr.right;\n                    if (expr.left instanceof data.SQConstantExpr)\n                        return expr.left;\n                }\n            };\n            return FindComparandVisitor;\n        }(data.DefaultSQExprVisitor));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\n        var ScopeIdentityExtractor;\n        (function (ScopeIdentityExtractor) {\n            function getKeys(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return null;\n                return ArrayExtensions.emptyToNull(extractor.keys);\n            }\n            ScopeIdentityExtractor.getKeys = getKeys;\n            function getInExpr(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return;\n                var keys = ArrayExtensions.emptyToNull(extractor.keys);\n                var keyValues = ArrayExtensions.emptyToNull(extractor.values);\n                if (keys && keyValues)\n                    return data.SQExprBuilder.inExpr(keys, [keyValues]);\n            }\n            ScopeIdentityExtractor.getInExpr = getInExpr;\n            /**\n             * Recognizes expressions of the form:\n             * 1) Equals(ColRef, Constant)\n             * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\n             * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\n             */\n            var ScopeIdExtractorImpl = (function (_super) {\n                __extends(ScopeIdExtractorImpl, _super);\n                function ScopeIdExtractorImpl() {\n                    _super.apply(this, arguments);\n                    this.keys = [];\n                    this.values = [];\n                }\n                ScopeIdExtractorImpl.prototype.visitAnd = function (expr) {\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal) {\n                        this.visitDefault(expr);\n                        return;\n                    }\n                    debug.assert(expr.left instanceof data.SQExpr && expr.right instanceof data.SQConstantExpr, 'invalid compare expr operands');\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitColumnRef = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitHierarchyLevel = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitConstant = function (expr) {\n                    this.values.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitArithmetic = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitDefault = function (expr) {\n                    this.malformed = true;\n                };\n                return ScopeIdExtractorImpl;\n            }(data.DefaultSQExprVisitor));\n        })(ScopeIdentityExtractor = data.ScopeIdentityExtractor || (data.ScopeIdentityExtractor = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var PrimitiveValueEncoding;\n        (function (PrimitiveValueEncoding) {\n            var SingleQuoteRegex = /'/g;\n            function decimal(value) {\n                debug.assertValue(value, 'value');\n                return value + 'M';\n            }\n            PrimitiveValueEncoding.decimal = decimal;\n            function double(value) {\n                debug.assertValue(value, 'value');\n                return value + 'D';\n            }\n            PrimitiveValueEncoding.double = double;\n            function integer(value) {\n                debug.assertValue(value, 'value');\n                return value + 'L';\n            }\n            PrimitiveValueEncoding.integer = integer;\n            function dateTime(value) {\n                debug.assertValue(value, 'value');\n                // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\n                // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\n                // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\n                var date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\n                var dateTimeString = date.toISOString();\n                // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\n                // we will drop it.\n                // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\n                if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\n                    dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\n                return \"datetime'\" + dateTimeString + \"'\";\n            }\n            PrimitiveValueEncoding.dateTime = dateTime;\n            function text(value) {\n                debug.assertValue(value, 'value');\n                return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\n            }\n            PrimitiveValueEncoding.text = text;\n            function nullEncoding() {\n                return 'null';\n            }\n            PrimitiveValueEncoding.nullEncoding = nullEncoding;\n            function boolean(value) {\n                return value ? 'true' : 'false';\n            }\n            PrimitiveValueEncoding.boolean = boolean;\n        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Agg = powerbi.data.QueryAggregateFunction;\n        function createSQAggregationOperations(datetimeMinMaxSupported) {\n            return new SQAggregationOperations(datetimeMinMaxSupported);\n        }\n        data.createSQAggregationOperations = createSQAggregationOperations;\n        var SQAggregationOperations = (function () {\n            function SQAggregationOperations(datetimeMinMaxSupported) {\n                this.datetimeMinMaxSupported = datetimeMinMaxSupported;\n            }\n            SQAggregationOperations.prototype.getSupportedAggregates = function (expr, schema, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                debug.assertAnyValue(targetTypes, 'targetTypes');\n                var metadata = getMetadataForUnderlyingType(expr, schema);\n                // don't use expr.validate as validate will be using this function and we end up in a recursive loop\n                if (!metadata)\n                    return [];\n                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey;\n                if (!valueType)\n                    return [];\n                // Cannot aggregate on model measures\n                if (fieldKind === 1 /* Measure */)\n                    return [];\n                if (valueType.numeric || valueType.integer) {\n                    var aggregates_1 = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var currentSchema = schema.schema(fieldExprItem.schema);\n                    if (currentSchema.capabilities.supportsMedian)\n                        aggregates_1.push(Agg.Median);\n                    return aggregates_1;\n                }\n                var aggregates = [];\n                // Min/Max of DateTime\n                if (this.datetimeMinMaxSupported &&\n                    valueType.dateTime &&\n                    (_.isEmpty(targetTypes) || powerbi.ValueType.isCompatibleTo(valueType, targetTypes))) {\n                    aggregates.push(Agg.Min);\n                    aggregates.push(Agg.Max);\n                }\n                // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\n                // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\n                var distinctCountAggExists = data.SQExprInfo.getAggregate(expr) === Agg.Count;\n                if (!(isPropertyIdentity && !distinctCountAggExists))\n                    aggregates.push(Agg.Count);\n                aggregates.push(Agg.CountNonNull);\n                return aggregates;\n            };\n            SQAggregationOperations.prototype.isSupportedAggregate = function (expr, schema, aggregate, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\n                return _.contains(supportedAggregates, aggregate);\n            };\n            SQAggregationOperations.prototype.createExprWithAggregate = function (expr, schema, aggregateNonNumericFields, targetTypes, preferredAggregate) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var aggregate;\n                if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\n                    aggregate = preferredAggregate;\n                }\n                else {\n                    aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\n                }\n                if (aggregate !== undefined)\n                    expr = data.SQExprBuilder.aggregate(expr, aggregate);\n                return expr;\n            };\n            return SQAggregationOperations;\n        }());\n        function getMetadataForUnderlyingType(expr, schema) {\n            // Unwrap the aggregate (if the expr has one), and look at the underlying type.\n            var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);\n            if (!metadata)\n                metadata = expr.getMetadata(schema);\n            return metadata;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQHierarchyExprUtils;\n        (function (SQHierarchyExprUtils) {\n            function getConceptualHierarchyLevelFromExpr(conceptualSchema, fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                var hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\n                if (hierarchyLevel)\n                    return SQHierarchyExprUtils.getConceptualHierarchyLevel(conceptualSchema, fieldExprItem.schema, fieldExprItem.entity, hierarchyLevel.name, hierarchyLevel.level);\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr = getConceptualHierarchyLevelFromExpr;\n            function getConceptualHierarchyLevel(conceptualSchema, schemaName, entity, hierarchy, hierarchyLevel) {\n                var schema = conceptualSchema.schema(schemaName);\n                var conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\n                if (conceptualHierarchy) {\n                    return conceptualHierarchy.levels.withName(hierarchyLevel);\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevel = getConceptualHierarchyLevel;\n            function getConceptualHierarchy(sqExpr, federatedSchema) {\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchy = sqExpr;\n                    if (sqExpr.arg instanceof data.SQEntityExpr) {\n                        var entityExpr = sqExpr.arg;\n                        return federatedSchema\n                            .schema(entityExpr.schema)\n                            .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\n                    }\n                    else if (sqExpr.arg instanceof data.SQPropertyVariationSourceExpr) {\n                        var variationExpr = sqExpr.arg;\n                        var sourceEntityExpr = variationExpr.arg;\n                        return federatedSchema\n                            .schema(sourceEntityExpr.schema)\n                            .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\n                    }\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchy = getConceptualHierarchy;\n            function expandExpr(schema, expr, suppressHierarchyLevelExpansion) {\n                return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\n                    SQExprVariationConverter.expand(expr, schema) ||\n                    // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\n                    (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\n                    expr;\n            }\n            SQHierarchyExprUtils.expandExpr = expandExpr;\n            function isHierarchyOrVariation(schema, expr) {\n                if (expr instanceof data.SQHierarchyExpr || expr instanceof data.SQHierarchyLevelExpr)\n                    return true;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0)\n                        return true;\n                }\n                return false;\n            }\n            SQHierarchyExprUtils.isHierarchyOrVariation = isHierarchyOrVariation;\n            // Return column reference expression for hierarchy level expression.\n            function getSourceVariationExpr(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                if (fieldExprPattern.columnHierarchyLevelVariation) {\n                    var entity = data.SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\n                    return data.SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceVariationExpr = getSourceVariationExpr;\n            // Return hierarchy expression for hierarchy level expression.\n            function getSourceHierarchy(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                var hierarchyLevel = fieldExprPattern.hierarchyLevel;\n                if (hierarchyLevel) {\n                    var entity = data.SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\n                    return data.SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceHierarchy = getSourceHierarchy;\n            function getHierarchySourceAsVariationSource(hierarchyLevelExpr) {\n                // Make sure the hierarchy level source is a hierarchy\n                if (!(hierarchyLevelExpr.arg instanceof data.SQHierarchyExpr))\n                    return;\n                // Check if the hierarchy source if a variation\n                var hierarchyRef = hierarchyLevelExpr.arg;\n                if (hierarchyRef.arg instanceof data.SQPropertyVariationSourceExpr)\n                    return hierarchyRef.arg;\n            }\n            SQHierarchyExprUtils.getHierarchySourceAsVariationSource = getHierarchySourceAsVariationSource;\n            /**\n            * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\n            */\n            function areHierarchyLevelsOrdered(allLevels, firstExpr, secondExpr) {\n                // Validate that both items hierarchy levels\n                if (!(firstExpr instanceof data.SQHierarchyLevelExpr) || !(secondExpr instanceof data.SQHierarchyLevelExpr))\n                    return false;\n                var firstLevel = firstExpr;\n                var secondLevel = secondExpr;\n                // Validate that both items belong to the same hierarchy\n                if (!data.SQExpr.equals(firstLevel.arg, secondLevel.arg))\n                    return false;\n                // Determine the order\n                var firstIndex = data.SQExprUtils.indexOfExpr(allLevels, firstLevel);\n                var secondIndex = data.SQExprUtils.indexOfExpr(allLevels, secondLevel);\n                return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\n            }\n            SQHierarchyExprUtils.areHierarchyLevelsOrdered = areHierarchyLevelsOrdered;\n            /**\n             * Given an ordered set of levels and an ordered subset of those levels, returns the index where\n             * expr should be inserted into the subset to maintain the correct order.\n             */\n            function getInsertionIndex(allLevels, orderedSubsetOfLevels, expr) {\n                var insertIndex = 0;\n                // Loop through the supplied levels until the insertion would no longer be in the correct order\n                while (insertIndex < orderedSubsetOfLevels.length &&\n                    areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\n                    insertIndex++;\n                }\n                return insertIndex;\n            }\n            SQHierarchyExprUtils.getInsertionIndex = getInsertionIndex;\n        })(SQHierarchyExprUtils = data.SQHierarchyExprUtils || (data.SQHierarchyExprUtils = {}));\n        var SQExprHierarchyToHierarchyLevelConverter;\n        (function (SQExprHierarchyToHierarchyLevelConverter) {\n            function convert(sqExpr, federatedSchema) {\n                debug.assertValue(sqExpr, 'sqExpr');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchyExpr = sqExpr;\n                    var conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\n                    if (conceptualHierarchy)\n                        return _.map(conceptualHierarchy.levels, function (hierarchyLevel) { return data.SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name); });\n                }\n            }\n            SQExprHierarchyToHierarchyLevelConverter.convert = convert;\n        })(SQExprHierarchyToHierarchyLevelConverter = data.SQExprHierarchyToHierarchyLevelConverter || (data.SQExprHierarchyToHierarchyLevelConverter = {}));\n        var SQExprHierarchyLevelConverter;\n        (function (SQExprHierarchyLevelConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs = [];\n                if (expr instanceof data.SQHierarchyLevelExpr) {\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    if (fieldExpr.hierarchyLevel) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        var hierarchy = schema\n                            .schema(fieldExprItem.schema)\n                            .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\n                        if (hierarchy) {\n                            var hierarchyLevels = hierarchy.levels;\n                            for (var _i = 0, hierarchyLevels_2 = hierarchyLevels; _i < hierarchyLevels_2.length; _i++) {\n                                var hierarchyLevel = hierarchyLevels_2[_i];\n                                if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\n                                    exprs.push(expr);\n                                    break;\n                                }\n                                else\n                                    exprs.push(data.SQExprBuilder.hierarchyLevel(data.SQExprBuilder.hierarchy(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), hierarchy.name), hierarchyLevel.name));\n                            }\n                        }\n                    }\n                }\n                if (!_.isEmpty(exprs))\n                    return exprs;\n            }\n            SQExprHierarchyLevelConverter.expand = expand;\n        })(SQExprHierarchyLevelConverter || (SQExprHierarchyLevelConverter = {}));\n        var SQExprVariationConverter;\n        (function (SQExprVariationConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0) {\n                        var variations = column.variations;\n                        // for SU11, we support only one variation\n                        debug.assert(variations.length === 1, \"variations.length\");\n                        var variation = variations[0];\n                        var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        exprs = [];\n                        if (variation.defaultHierarchy) {\n                            var hierarchyExpr = data.SQExprBuilder.hierarchy(data.SQExprBuilder.propertyVariationSource(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), variation.name, conceptualProperty.name), variation.defaultHierarchy.name);\n                            for (var _i = 0, _a = variation.defaultHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                exprs.push(data.SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\n                            }\n                        }\n                    }\n                }\n                return exprs;\n            }\n            SQExprVariationConverter.expand = expand;\n        })(SQExprVariationConverter || (SQExprVariationConverter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        ;\n        var SQExprGroupUtils;\n        (function (SQExprGroupUtils) {\n            /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\n            function groupExprs(schema, exprs) {\n                var groups = [];\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i];\n                    debug.assertValue(expr, \"Expression not found\");\n                    if (!(expr instanceof data.SQHierarchyLevelExpr)) {\n                        groups.push({ expr: expr, children: null, selectQueryIndex: i });\n                    }\n                    else {\n                        addChildToGroup(schema, groups, expr, i);\n                    }\n                }\n                return groups;\n            }\n            SQExprGroupUtils.groupExprs = groupExprs;\n            function addChildToGroup(schema, groups, expr, selectQueryIndex) {\n                // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \n                // a new Group or to the last Group\n                var shouldAddExpressionToNewGroup = true;\n                var exprSource = data.SQHierarchyExprUtils.getSourceVariationExpr(expr) || data.SQHierarchyExprUtils.getSourceHierarchy(expr);\n                var lastGroup = _.last(groups);\n                // The relevant group is always the last added. If it has the same source hierarchy,\n                // and is properly ordered within that hierarchy, we will need to add to this group.\n                if (lastGroup && lastGroup.children && data.SQExpr.equals(lastGroup.expr, exprSource)) {\n                    var expandedExpr = data.SQHierarchyExprUtils.expandExpr(schema, expr.arg);\n                    if (expandedExpr instanceof Array) {\n                        var allHierarchyLevels = expandedExpr;\n                        shouldAddExpressionToNewGroup = !data.SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\n                    }\n                }\n                if (shouldAddExpressionToNewGroup)\n                    // Use the Sourcevariation as the expression for the group.\n                    groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\n                else {\n                    debug.assertValue(lastGroup, 'There should be a group to add the variation to');\n                    debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\n                    lastGroup.children.push(expr);\n                }\n            }\n        })(SQExprGroupUtils = data.SQExprGroupUtils || (data.SQExprGroupUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var StringExtensions = jsCommon.StringExtensions;\n        /** Represents an immutable expression within a SemanticQuery. */\n        var SQExpr = (function () {\n            function SQExpr(kind) {\n                debug.assertValue(kind, 'kind');\n                this._kind = kind;\n            }\n            SQExpr.equals = function (x, y, ignoreCase) {\n                return SQExprEqualityVisitor.run(x, y, ignoreCase);\n            };\n            SQExpr.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.accept(validator);\n                return validator.errors;\n            };\n            SQExpr.prototype.accept = function (visitor, arg) {\n                debug.assertFail('abstract method');\n                return;\n            };\n            Object.defineProperty(SQExpr.prototype, \"kind\", {\n                get: function () {\n                    return this._kind;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            SQExpr.isArithmetic = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 22 /* Arithmetic */;\n            };\n            SQExpr.isColumn = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 1 /* ColumnRef */;\n            };\n            SQExpr.isConstant = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 16 /* Constant */;\n            };\n            SQExpr.isEntity = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 0 /* Entity */;\n            };\n            SQExpr.isHierarchy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 5 /* Hierarchy */;\n            };\n            SQExpr.isHierarchyLevel = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 6 /* HierarchyLevel */;\n            };\n            SQExpr.isAggregation = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 3 /* Aggregation */;\n            };\n            SQExpr.isMeasure = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 2 /* MeasureRef */;\n            };\n            SQExpr.isSelectRef = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 28 /* SelectRef */;\n            };\n            SQExpr.isScopedEval = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 25 /* ScopedEval */;\n            };\n            SQExpr.isWithRef = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 26 /* WithRef */;\n            };\n            SQExpr.isResourcePackageItem = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 24 /* ResourcePackageItem */;\n            };\n            SQExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                if (field.column || field.columnAggr || field.measure)\n                    return this.getMetadataForProperty(field, federatedSchema);\n                if (field.hierarchyLevel || field.hierarchyLevelAggr)\n                    return this.getMetadataForHierarchyLevel(field, federatedSchema);\n                if (field.columnHierarchyLevelVariation)\n                    return this.getMetadataForVariation(field, federatedSchema);\n                if (field.percentOfGrandTotal)\n                    return this.getMetadataForPercentOfGrandTotal();\n                return SQExpr.getMetadataForEntity(field, federatedSchema);\n            };\n            SQExpr.prototype.getDefaultAggregate = function (federatedSchema, forceAggregation) {\n                if (forceAggregation === void 0) { forceAggregation = false; }\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                var aggregate;\n                if (property && property.kind === 0 /* Column */) {\n                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\n                    if ((property.type.integer || property.type.numeric) &&\n                        propertyDefaultAggregate !== 1 /* None */) {\n                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\n                        if (aggregate === undefined)\n                            aggregate = defaultAggregateForDataType(property.type);\n                    }\n                    // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \n                    // aggregate on CountNonNull.\n                    if (aggregate === undefined && forceAggregation) {\n                        aggregate = data.QueryAggregateFunction.CountNonNull;\n                    }\n                }\n                return aggregate;\n            };\n            /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\n            SQExpr.prototype.getKeyColumns = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keySQExprs = [];\n                var keys = this.getPropertyKeys(schema);\n                if (keys && keys.length > 0) {\n                    for (var i = 0, len = keys.length; i < len; i++) {\n                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\n                    }\n                }\n                else\n                    keySQExprs.push(columnRefExpr);\n                return keySQExprs;\n            };\n            /** Returns a value indicating whether the expression would group on keys other than itself.*/\n            SQExpr.prototype.hasGroupOnKeys = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keys = this.getPropertyKeys(schema);\n                if (!keys || keys.length < 1)\n                    return false;\n                if (keys.length > 1)\n                    return true;\n                var keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\n                return !SQExpr.equals(keySqExpr, this);\n            };\n            SQExpr.prototype.getPropertyKeys = function (schema) {\n                var property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\n                if (!property)\n                    return;\n                return property.column ? property.column.keys : undefined;\n            };\n            SQExpr.prototype.getConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var propertyName = data.FieldExprPattern.getPropertyName(field);\n                if (propertyName)\n                    return federatedSchema\n                        .schema(fieldExprItem.schema)\n                        .findProperty(fieldExprItem.entity, propertyName);\n            };\n            SQExpr.prototype.getTargetEntityForVariation = function (federatedSchema, variationName) {\n                var property = this.getConceptualProperty(federatedSchema);\n                if (property && property.column && !_.isEmpty(property.column.variations)) {\n                    var variations = property.column.variations;\n                    for (var _i = 0, variations_2 = variations; _i < variations_2.length; _i++) {\n                        var variation = variations_2[_i];\n                        if (variation.name === variationName)\n                            return variation.navigationProperty.targetEntity.name;\n                    }\n                }\n            };\n            SQExpr.prototype.getTargetEntity = function (federatedSchema) {\n                return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\n            };\n            SQExpr.prototype.getHierarchyLevelConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\n                if (fieldExprHierachyLevel) {\n                    var fieldExprEntity = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                    var hierarchy = federatedSchema\n                        .schema(fieldExprEntity.schema)\n                        .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\n                    if (hierarchy) {\n                        var hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\n                        if (hierarchyLevel)\n                            return hierarchyLevel.column;\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForVariation = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var sourceProperty = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\n                if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\n                    for (var _i = 0, _a = sourceProperty.column.variations; _i < _a.length; _i++) {\n                        var variation = _a[_i];\n                        if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\n                            for (var _b = 0, _c = variation.defaultHierarchy.levels; _b < _c.length; _b++) {\n                                var level = _c[_b];\n                                if (level.name === columnHierarchyLevelVariation.level.level) {\n                                    var property = level.column;\n                                    return {\n                                        kind: (property.kind === 1 /* Measure */) ? 1 /* Measure */ : 0 /* Column */,\n                                        type: property.type,\n                                        format: property.format,\n                                        idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                                        defaultAggregate: property.column ? property.column.defaultAggregate : null\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForHierarchyLevel = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.prototype.getMetadataForPercentOfGrandTotal = function () {\n                return {\n                    kind: 1 /* Measure */,\n                    format: '#,##0.##%',\n                    type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double)\n                };\n            };\n            SQExpr.prototype.getPropertyMetadata = function (field, property) {\n                var format = property.format;\n                var type = property.type;\n                var columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\n                if (columnAggregate) {\n                    switch (columnAggregate.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer);\n                            format = undefined;\n                            break;\n                        case data.QueryAggregateFunction.Avg:\n                            if (type.integer)\n                                type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double);\n                            break;\n                    }\n                }\n                return {\n                    kind: (property.kind === 1 /* Measure */ || (columnAggregate && columnAggregate.aggregate !== undefined)) ? 1 /* Measure */ : 0 /* Column */,\n                    type: type,\n                    format: format,\n                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                    aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\n                    defaultAggregate: property.column ? property.column.defaultAggregate : null\n                };\n            };\n            SQExpr.prototype.getMetadataForProperty = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.getMetadataForEntity = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var entity = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .entities\n                    .withName(fieldExprItem.entity);\n                if (!entity)\n                    return;\n                // We only support count and countnonnull for entity.\n                if (field.entityAggr) {\n                    switch (field.entityAggr.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            return {\n                                kind: 1 /* Measure */,\n                                type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer),\n                                format: undefined,\n                                idOnEntityKey: false,\n                                aggregate: field.entityAggr.aggregate\n                            };\n                    }\n                }\n            };\n            return SQExpr;\n        }());\n        data.SQExpr = SQExpr;\n        /** Note: Exported for testability */\n        function defaultAggregateForDataType(type) {\n            if (type.integer || type.numeric)\n                return data.QueryAggregateFunction.Sum;\n            return data.QueryAggregateFunction.Count;\n        }\n        data.defaultAggregateForDataType = defaultAggregateForDataType;\n        /** Note: Exported for testability */\n        function defaultAggregateToQueryAggregateFunction(aggregate) {\n            switch (aggregate) {\n                case 6 /* Average */:\n                    return data.QueryAggregateFunction.Avg;\n                case 3 /* Count */:\n                    return data.QueryAggregateFunction.CountNonNull;\n                case 7 /* DistinctCount */:\n                    return data.QueryAggregateFunction.Count;\n                case 5 /* Max */:\n                    return data.QueryAggregateFunction.Max;\n                case 4 /* Min */:\n                    return data.QueryAggregateFunction.Min;\n                case 2 /* Sum */:\n                    return data.QueryAggregateFunction.Sum;\n                default:\n                    return;\n            }\n        }\n        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;\n        var SQEntityExpr = (function (_super) {\n            __extends(SQEntityExpr, _super);\n            function SQEntityExpr(schema, entity, variable) {\n                debug.assertValue(entity, 'entity');\n                _super.call(this, 0 /* Entity */);\n                this.schema = schema;\n                this.entity = entity;\n                if (variable)\n                    this.variable = variable;\n            }\n            SQEntityExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitEntity(this, arg);\n            };\n            return SQEntityExpr;\n        }(SQExpr));\n        data.SQEntityExpr = SQEntityExpr;\n        var SQArithmeticExpr = (function (_super) {\n            __extends(SQArithmeticExpr, _super);\n            function SQArithmeticExpr(left, right, operator) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                debug.assertValue(operator, 'operator');\n                _super.call(this, 22 /* Arithmetic */);\n                this.left = left;\n                this.right = right;\n                this.operator = operator;\n            }\n            SQArithmeticExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitArithmetic(this, arg);\n            };\n            return SQArithmeticExpr;\n        }(SQExpr));\n        data.SQArithmeticExpr = SQArithmeticExpr;\n        var SQScopedEvalExpr = (function (_super) {\n            __extends(SQScopedEvalExpr, _super);\n            function SQScopedEvalExpr(expression, scope) {\n                debug.assertValue(expression, 'expression');\n                debug.assertValue(scope, 'scope');\n                _super.call(this, 25 /* ScopedEval */);\n                this.expression = expression;\n                this.scope = scope;\n            }\n            SQScopedEvalExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitScopedEval(this, arg);\n            };\n            SQScopedEvalExpr.prototype.getMetadata = function (federatedSchema) {\n                return this.expression.getMetadata(federatedSchema);\n            };\n            return SQScopedEvalExpr;\n        }(SQExpr));\n        data.SQScopedEvalExpr = SQScopedEvalExpr;\n        var SQWithRefExpr = (function (_super) {\n            __extends(SQWithRefExpr, _super);\n            function SQWithRefExpr(expressionName) {\n                debug.assertValue(expressionName, 'expressionName');\n                _super.call(this, 26 /* WithRef */);\n                this.expressionName = expressionName;\n            }\n            SQWithRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitWithRef(this, arg);\n            };\n            return SQWithRefExpr;\n        }(SQExpr));\n        data.SQWithRefExpr = SQWithRefExpr;\n        var SQPropRefExpr = (function (_super) {\n            __extends(SQPropRefExpr, _super);\n            function SQPropRefExpr(kind, source, ref) {\n                debug.assertValue(kind, 'kind');\n                debug.assertValue(source, 'source');\n                debug.assertValue(ref, 'ref');\n                _super.call(this, kind);\n                this.source = source;\n                this.ref = ref;\n            }\n            return SQPropRefExpr;\n        }(SQExpr));\n        data.SQPropRefExpr = SQPropRefExpr;\n        var SQColumnRefExpr = (function (_super) {\n            __extends(SQColumnRefExpr, _super);\n            function SQColumnRefExpr(source, ref) {\n                _super.call(this, 1 /* ColumnRef */, source, ref);\n            }\n            SQColumnRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitColumnRef(this, arg);\n            };\n            return SQColumnRefExpr;\n        }(SQPropRefExpr));\n        data.SQColumnRefExpr = SQColumnRefExpr;\n        var SQMeasureRefExpr = (function (_super) {\n            __extends(SQMeasureRefExpr, _super);\n            function SQMeasureRefExpr(source, ref) {\n                _super.call(this, 2 /* MeasureRef */, source, ref);\n            }\n            SQMeasureRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitMeasureRef(this, arg);\n            };\n            return SQMeasureRefExpr;\n        }(SQPropRefExpr));\n        data.SQMeasureRefExpr = SQMeasureRefExpr;\n        var SQAggregationExpr = (function (_super) {\n            __extends(SQAggregationExpr, _super);\n            function SQAggregationExpr(arg, func) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(func, 'func');\n                _super.call(this, 3 /* Aggregation */);\n                this.arg = arg;\n                this.func = func;\n            }\n            SQAggregationExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAggr(this, arg);\n            };\n            return SQAggregationExpr;\n        }(SQExpr));\n        data.SQAggregationExpr = SQAggregationExpr;\n        var SQPercentileExpr = (function (_super) {\n            __extends(SQPercentileExpr, _super);\n            function SQPercentileExpr(arg, k, exclusive) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(k, 'k');\n                debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');\n                debug.assertValue(exclusive, 'exclusive');\n                _super.call(this, 27 /* Percentile */);\n                this.arg = arg;\n                this.k = k;\n                this.exclusive = exclusive;\n            }\n            SQPercentileExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var argMetadata = this.arg.getMetadata(federatedSchema);\n                if (argMetadata) {\n                    return {\n                        kind: 1 /* Measure */,\n                        type: argMetadata.type,\n                    };\n                }\n            };\n            SQPercentileExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPercentile(this, arg);\n            };\n            return SQPercentileExpr;\n        }(SQExpr));\n        data.SQPercentileExpr = SQPercentileExpr;\n        var SQPropertyVariationSourceExpr = (function (_super) {\n            __extends(SQPropertyVariationSourceExpr, _super);\n            function SQPropertyVariationSourceExpr(arg, name, property) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(name, 'name');\n                debug.assertValue(property, 'property');\n                _super.call(this, 4 /* PropertyVariationSource */);\n                this.arg = arg;\n                this.name = name;\n                this.property = property;\n            }\n            SQPropertyVariationSourceExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPropertyVariationSource(this, arg);\n            };\n            return SQPropertyVariationSourceExpr;\n        }(SQExpr));\n        data.SQPropertyVariationSourceExpr = SQPropertyVariationSourceExpr;\n        var SQHierarchyExpr = (function (_super) {\n            __extends(SQHierarchyExpr, _super);\n            function SQHierarchyExpr(arg, hierarchy) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(hierarchy, 'hierarchy');\n                _super.call(this, 5 /* Hierarchy */);\n                this.arg = arg;\n                this.hierarchy = hierarchy;\n            }\n            SQHierarchyExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchy(this, arg);\n            };\n            return SQHierarchyExpr;\n        }(SQExpr));\n        data.SQHierarchyExpr = SQHierarchyExpr;\n        var SQHierarchyLevelExpr = (function (_super) {\n            __extends(SQHierarchyLevelExpr, _super);\n            function SQHierarchyLevelExpr(arg, level) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(level, 'level');\n                _super.call(this, 6 /* HierarchyLevel */);\n                this.arg = arg;\n                this.level = level;\n            }\n            SQHierarchyLevelExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchyLevel(this, arg);\n            };\n            return SQHierarchyLevelExpr;\n        }(SQExpr));\n        data.SQHierarchyLevelExpr = SQHierarchyLevelExpr;\n        var SQSelectRefExpr = (function (_super) {\n            __extends(SQSelectRefExpr, _super);\n            function SQSelectRefExpr(expressionName) {\n                debug.assertValue(expressionName, 'arg');\n                _super.call(this, 28 /* SelectRef */);\n                this.expressionName = expressionName;\n            }\n            SQSelectRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitSelectRef(this, arg);\n            };\n            return SQSelectRefExpr;\n        }(SQExpr));\n        data.SQSelectRefExpr = SQSelectRefExpr;\n        var SQAndExpr = (function (_super) {\n            __extends(SQAndExpr, _super);\n            function SQAndExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 7 /* And */);\n                this.left = left;\n                this.right = right;\n            }\n            SQAndExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnd(this, arg);\n            };\n            return SQAndExpr;\n        }(SQExpr));\n        data.SQAndExpr = SQAndExpr;\n        var SQBetweenExpr = (function (_super) {\n            __extends(SQBetweenExpr, _super);\n            function SQBetweenExpr(arg, lower, upper) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(lower, 'lower');\n                debug.assertValue(upper, 'upper');\n                _super.call(this, 8 /* Between */);\n                this.arg = arg;\n                this.lower = lower;\n                this.upper = upper;\n            }\n            SQBetweenExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitBetween(this, arg);\n            };\n            return SQBetweenExpr;\n        }(SQExpr));\n        data.SQBetweenExpr = SQBetweenExpr;\n        var SQInExpr = (function (_super) {\n            __extends(SQInExpr, _super);\n            function SQInExpr(args, values) {\n                debug.assertValue(args, 'args');\n                debug.assertValue(values, 'values');\n                _super.call(this, 9 /* In */);\n                this.args = args;\n                this.values = values;\n            }\n            SQInExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitIn(this, arg);\n            };\n            return SQInExpr;\n        }(SQExpr));\n        data.SQInExpr = SQInExpr;\n        var SQOrExpr = (function (_super) {\n            __extends(SQOrExpr, _super);\n            function SQOrExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 10 /* Or */);\n                this.left = left;\n                this.right = right;\n            }\n            SQOrExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitOr(this, arg);\n            };\n            return SQOrExpr;\n        }(SQExpr));\n        data.SQOrExpr = SQOrExpr;\n        var SQCompareExpr = (function (_super) {\n            __extends(SQCompareExpr, _super);\n            function SQCompareExpr(comparison, left, right) {\n                debug.assertValue(comparison, 'kind');\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 12 /* Compare */);\n                this.comparison = comparison;\n                this.left = left;\n                this.right = right;\n            }\n            SQCompareExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitCompare(this, arg);\n            };\n            return SQCompareExpr;\n        }(SQExpr));\n        data.SQCompareExpr = SQCompareExpr;\n        var SQContainsExpr = (function (_super) {\n            __extends(SQContainsExpr, _super);\n            function SQContainsExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 11 /* Contains */);\n                this.left = left;\n                this.right = right;\n            }\n            SQContainsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitContains(this, arg);\n            };\n            return SQContainsExpr;\n        }(SQExpr));\n        data.SQContainsExpr = SQContainsExpr;\n        var SQStartsWithExpr = (function (_super) {\n            __extends(SQStartsWithExpr, _super);\n            function SQStartsWithExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 13 /* StartsWith */);\n                this.left = left;\n                this.right = right;\n            }\n            SQStartsWithExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitStartsWith(this, arg);\n            };\n            return SQStartsWithExpr;\n        }(SQExpr));\n        data.SQStartsWithExpr = SQStartsWithExpr;\n        var SQExistsExpr = (function (_super) {\n            __extends(SQExistsExpr, _super);\n            function SQExistsExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 14 /* Exists */);\n                this.arg = arg;\n            }\n            SQExistsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitExists(this, arg);\n            };\n            return SQExistsExpr;\n        }(SQExpr));\n        data.SQExistsExpr = SQExistsExpr;\n        var SQNotExpr = (function (_super) {\n            __extends(SQNotExpr, _super);\n            function SQNotExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 15 /* Not */);\n                this.arg = arg;\n            }\n            SQNotExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNot(this, arg);\n            };\n            return SQNotExpr;\n        }(SQExpr));\n        data.SQNotExpr = SQNotExpr;\n        var SQConstantExpr = (function (_super) {\n            __extends(SQConstantExpr, _super);\n            function SQConstantExpr(type, value, valueEncoded) {\n                debug.assertValue(type, 'type');\n                _super.call(this, 16 /* Constant */);\n                this.type = type;\n                this.value = value;\n                this.valueEncoded = valueEncoded;\n            }\n            SQConstantExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitConstant(this, arg);\n            };\n            SQConstantExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                return {\n                    // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\n                    // A getType or similiar function in the future would be more appropriate. \n                    kind: 1 /* Measure */,\n                    type: this.type,\n                };\n            };\n            return SQConstantExpr;\n        }(SQExpr));\n        data.SQConstantExpr = SQConstantExpr;\n        var SQDateSpanExpr = (function (_super) {\n            __extends(SQDateSpanExpr, _super);\n            function SQDateSpanExpr(unit, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 17 /* DateSpan */);\n                this.unit = unit;\n                this.arg = arg;\n            }\n            SQDateSpanExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateSpan(this, arg);\n            };\n            return SQDateSpanExpr;\n        }(SQExpr));\n        data.SQDateSpanExpr = SQDateSpanExpr;\n        var SQDateAddExpr = (function (_super) {\n            __extends(SQDateAddExpr, _super);\n            function SQDateAddExpr(unit, amount, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(amount, 'amount');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 18 /* DateAdd */);\n                this.unit = unit;\n                this.arg = arg;\n                this.amount = amount;\n            }\n            SQDateAddExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateAdd(this, arg);\n            };\n            return SQDateAddExpr;\n        }(SQExpr));\n        data.SQDateAddExpr = SQDateAddExpr;\n        var SQNowExpr = (function (_super) {\n            __extends(SQNowExpr, _super);\n            function SQNowExpr() {\n                _super.call(this, 19 /* Now */);\n            }\n            SQNowExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNow(this, arg);\n            };\n            return SQNowExpr;\n        }(SQExpr));\n        data.SQNowExpr = SQNowExpr;\n        var SQDefaultValueExpr = (function (_super) {\n            __extends(SQDefaultValueExpr, _super);\n            function SQDefaultValueExpr() {\n                _super.call(this, 21 /* DefaultValue */);\n            }\n            SQDefaultValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDefaultValue(this, arg);\n            };\n            return SQDefaultValueExpr;\n        }(SQExpr));\n        data.SQDefaultValueExpr = SQDefaultValueExpr;\n        var SQAnyValueExpr = (function (_super) {\n            __extends(SQAnyValueExpr, _super);\n            function SQAnyValueExpr() {\n                _super.call(this, 20 /* AnyValue */);\n            }\n            SQAnyValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnyValue(this, arg);\n            };\n            return SQAnyValueExpr;\n        }(SQExpr));\n        data.SQAnyValueExpr = SQAnyValueExpr;\n        var SQFillRuleExpr = (function (_super) {\n            __extends(SQFillRuleExpr, _super);\n            function SQFillRuleExpr(input, fillRule) {\n                debug.assertValue(input, 'input');\n                debug.assertValue(fillRule, 'fillRule');\n                _super.call(this, 23 /* FillRule */);\n                this.input = input;\n                this.rule = fillRule;\n            }\n            SQFillRuleExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitFillRule(this, arg);\n            };\n            return SQFillRuleExpr;\n        }(SQExpr));\n        data.SQFillRuleExpr = SQFillRuleExpr;\n        var SQResourcePackageItemExpr = (function (_super) {\n            __extends(SQResourcePackageItemExpr, _super);\n            function SQResourcePackageItemExpr(packageName, packageType, itemName) {\n                debug.assertValue(packageName, 'packageName');\n                debug.assertValue(itemName, 'itemName');\n                _super.call(this, 24 /* ResourcePackageItem */);\n                this.packageName = packageName;\n                this.packageType = packageType;\n                this.itemName = itemName;\n            }\n            SQResourcePackageItemExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitResourcePackageItem(this, arg);\n            };\n            return SQResourcePackageItemExpr;\n        }(SQExpr));\n        data.SQResourcePackageItemExpr = SQResourcePackageItemExpr;\n        /** Provides utilities for creating & manipulating expressions. */\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function entity(schema, entity, variable) {\n                return new SQEntityExpr(schema, entity, variable);\n            }\n            SQExprBuilder.entity = entity;\n            function columnRef(source, prop) {\n                return new SQColumnRefExpr(source, prop);\n            }\n            SQExprBuilder.columnRef = columnRef;\n            function measureRef(source, prop) {\n                return new SQMeasureRefExpr(source, prop);\n            }\n            SQExprBuilder.measureRef = measureRef;\n            function aggregate(source, aggregate) {\n                return new SQAggregationExpr(source, aggregate);\n            }\n            SQExprBuilder.aggregate = aggregate;\n            function selectRef(expressionName) {\n                return new SQSelectRefExpr(expressionName);\n            }\n            SQExprBuilder.selectRef = selectRef;\n            function percentile(source, k, exclusive) {\n                return new SQPercentileExpr(source, k, exclusive);\n            }\n            SQExprBuilder.percentile = percentile;\n            function arithmetic(left, right, operator) {\n                return new SQArithmeticExpr(left, right, operator);\n            }\n            SQExprBuilder.arithmetic = arithmetic;\n            function scopedEval(expression, scope) {\n                return new SQScopedEvalExpr(expression, scope);\n            }\n            SQExprBuilder.scopedEval = scopedEval;\n            function withRef(expressionName) {\n                return new SQWithRefExpr(expressionName);\n            }\n            SQExprBuilder.withRef = withRef;\n            function hierarchy(source, hierarchy) {\n                return new SQHierarchyExpr(source, hierarchy);\n            }\n            SQExprBuilder.hierarchy = hierarchy;\n            function propertyVariationSource(source, name, property) {\n                return new SQPropertyVariationSourceExpr(source, name, property);\n            }\n            SQExprBuilder.propertyVariationSource = propertyVariationSource;\n            function hierarchyLevel(source, level) {\n                return new SQHierarchyLevelExpr(source, level);\n            }\n            SQExprBuilder.hierarchyLevel = hierarchyLevel;\n            function and(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                return new SQAndExpr(left, right);\n            }\n            SQExprBuilder.and = and;\n            function between(arg, lower, upper) {\n                return new SQBetweenExpr(arg, lower, upper);\n            }\n            SQExprBuilder.between = between;\n            function inExpr(args, values) {\n                return new SQInExpr(args, values);\n            }\n            SQExprBuilder.inExpr = inExpr;\n            function or(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                if (left instanceof SQInExpr && right instanceof SQInExpr) {\n                    var inExpr_1 = tryUseInExprs(left, right);\n                    if (inExpr_1)\n                        return inExpr_1;\n                }\n                return new SQOrExpr(left, right);\n            }\n            SQExprBuilder.or = or;\n            function tryUseInExprs(left, right) {\n                if (!left.args || !right.args)\n                    return;\n                var leftArgLen = left.args.length;\n                var rightArgLen = right.args.length;\n                if (leftArgLen !== rightArgLen)\n                    return;\n                for (var i = 0; i < leftArgLen; ++i) {\n                    if (!SQExpr.equals(left.args[i], right.args[i]))\n                        return;\n                }\n                var combinedValues = left.values.concat(right.values);\n                return SQExprBuilder.inExpr(left.args, combinedValues);\n            }\n            function compare(kind, left, right) {\n                return new SQCompareExpr(kind, left, right);\n            }\n            SQExprBuilder.compare = compare;\n            function contains(left, right) {\n                return new SQContainsExpr(left, right);\n            }\n            SQExprBuilder.contains = contains;\n            function exists(arg) {\n                return new SQExistsExpr(arg);\n            }\n            SQExprBuilder.exists = exists;\n            function equal(left, right) {\n                return compare(data.QueryComparisonKind.Equal, left, right);\n            }\n            SQExprBuilder.equal = equal;\n            function not(arg) {\n                return new SQNotExpr(arg);\n            }\n            SQExprBuilder.not = not;\n            function startsWith(left, right) {\n                return new SQStartsWithExpr(left, right);\n            }\n            SQExprBuilder.startsWith = startsWith;\n            function nullConstant() {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Null), null, data.PrimitiveValueEncoding.nullEncoding());\n            }\n            SQExprBuilder.nullConstant = nullConstant;\n            function now() {\n                return new SQNowExpr();\n            }\n            SQExprBuilder.now = now;\n            function defaultValue() {\n                return new SQDefaultValueExpr();\n            }\n            SQExprBuilder.defaultValue = defaultValue;\n            function anyValue() {\n                return new SQAnyValueExpr();\n            }\n            SQExprBuilder.anyValue = anyValue;\n            function boolean(value) {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Boolean), value, data.PrimitiveValueEncoding.boolean(value));\n            }\n            SQExprBuilder.boolean = boolean;\n            function dateAdd(unit, amount, arg) {\n                return new SQDateAddExpr(unit, amount, arg);\n            }\n            SQExprBuilder.dateAdd = dateAdd;\n            function dateTime(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.dateTime(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.DateTime), value, valueEncoded);\n            }\n            SQExprBuilder.dateTime = dateTime;\n            function dateSpan(unit, arg) {\n                return new SQDateSpanExpr(unit, arg);\n            }\n            SQExprBuilder.dateSpan = dateSpan;\n            function decimal(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.decimal(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Decimal), value, valueEncoded);\n            }\n            SQExprBuilder.decimal = decimal;\n            function double(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.double(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double), value, valueEncoded);\n            }\n            SQExprBuilder.double = double;\n            function integer(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.integer(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer), value, valueEncoded);\n            }\n            SQExprBuilder.integer = integer;\n            function text(value, valueEncoded) {\n                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Text), value, valueEncoded || data.PrimitiveValueEncoding.text(value));\n            }\n            SQExprBuilder.text = text;\n            /** Returns an SQExpr that evaluates to the constant value. */\n            function typedConstant(value, type) {\n                if (value == null)\n                    return nullConstant();\n                if (_.isBoolean(value)) {\n                    return boolean(value);\n                }\n                if (_.isString(value)) {\n                    return text(value);\n                }\n                if (_.isNumber(value)) {\n                    if (type.integer && powerbi.Double.isInteger(value))\n                        return integer(value);\n                    return double(value);\n                }\n                if (value instanceof Date) {\n                    return dateTime(value);\n                }\n            }\n            SQExprBuilder.typedConstant = typedConstant;\n            function setAggregate(expr, aggregate) {\n                return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);\n            }\n            SQExprBuilder.setAggregate = setAggregate;\n            function removeAggregate(expr) {\n                return FieldExprRemoveAggregateRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeAggregate = removeAggregate;\n            function setPercentOfGrandTotal(expr) {\n                return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);\n            }\n            SQExprBuilder.setPercentOfGrandTotal = setPercentOfGrandTotal;\n            function removePercentOfGrandTotal(expr) {\n                return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removePercentOfGrandTotal = removePercentOfGrandTotal;\n            function removeEntityVariables(expr) {\n                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeEntityVariables = removeEntityVariables;\n            function fillRule(expr, rule) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(rule, 'rule');\n                return new SQFillRuleExpr(expr, rule);\n            }\n            SQExprBuilder.fillRule = fillRule;\n            function resourcePackageItem(packageName, packageType, itemName) {\n                return new SQResourcePackageItemExpr(packageName, packageType, itemName);\n            }\n            SQExprBuilder.resourcePackageItem = resourcePackageItem;\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        /** Provides utilities for obtaining information about expressions. */\n        var SQExprInfo;\n        (function (SQExprInfo) {\n            function getAggregate(expr) {\n                return SQExprAggregateInfoVisitor.getAggregate(expr);\n            }\n            SQExprInfo.getAggregate = getAggregate;\n        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));\n        var SQExprEqualityVisitor = (function () {\n            function SQExprEqualityVisitor(ignoreCase) {\n                this.ignoreCase = ignoreCase;\n            }\n            SQExprEqualityVisitor.run = function (x, y, ignoreCase) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (ignoreCase)\n                    return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\n                return x.accept(SQExprEqualityVisitor.instance, y);\n            };\n            SQExprEqualityVisitor.prototype.visitColumnRef = function (expr, comparand) {\n                return comparand instanceof SQColumnRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitMeasureRef = function (expr, comparand) {\n                return comparand instanceof SQMeasureRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitAggr = function (expr, comparand) {\n                return comparand instanceof SQAggregationExpr &&\n                    expr.func === comparand.func &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPercentile = function (expr, comparand) {\n                return comparand instanceof SQPercentileExpr &&\n                    expr.exclusive === comparand.exclusive &&\n                    expr.k === comparand.k &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchy = function (expr, comparand) {\n                return comparand instanceof SQHierarchyExpr &&\n                    expr.hierarchy === comparand.hierarchy &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchyLevel = function (expr, comparand) {\n                return comparand instanceof SQHierarchyLevelExpr &&\n                    expr.level === comparand.level &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPropertyVariationSource = function (expr, comparand) {\n                return comparand instanceof SQPropertyVariationSourceExpr &&\n                    expr.name === comparand.name &&\n                    expr.property === comparand.property &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitSelectRef = function (expr, comparand) {\n                return comparand instanceof SQSelectRefExpr &&\n                    expr.expressionName === comparand.expressionName;\n            };\n            SQExprEqualityVisitor.prototype.visitBetween = function (expr, comparand) {\n                return comparand instanceof SQBetweenExpr &&\n                    this.equals(expr.arg, comparand.arg) &&\n                    this.equals(expr.lower, comparand.lower) &&\n                    this.equals(expr.upper, comparand.upper);\n            };\n            SQExprEqualityVisitor.prototype.visitIn = function (expr, comparand) {\n                if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, comparand.args))\n                    return false;\n                var values = expr.values, compareValues = comparand.values;\n                if (values.length !== compareValues.length)\n                    return false;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    if (!this.equalsAll(values[i], compareValues[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.visitEntity = function (expr, comparand) {\n                return comparand instanceof SQEntityExpr &&\n                    expr.schema === comparand.schema &&\n                    expr.entity === comparand.entity &&\n                    this.optionalEqual(expr.variable, comparand.variable);\n            };\n            SQExprEqualityVisitor.prototype.visitAnd = function (expr, comparand) {\n                return comparand instanceof SQAndExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitOr = function (expr, comparand) {\n                return comparand instanceof SQOrExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitCompare = function (expr, comparand) {\n                return comparand instanceof SQCompareExpr &&\n                    expr.comparison === comparand.comparison &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitContains = function (expr, comparand) {\n                return comparand instanceof SQContainsExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitDateSpan = function (expr, comparand) {\n                return comparand instanceof SQDateSpanExpr &&\n                    expr.unit === comparand.unit &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitDateAdd = function (expr, comparand) {\n                return comparand instanceof SQDateAddExpr &&\n                    expr.unit === comparand.unit &&\n                    expr.amount === comparand.amount &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitExists = function (expr, comparand) {\n                return comparand instanceof SQExistsExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNot = function (expr, comparand) {\n                return comparand instanceof SQNotExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNow = function (expr, comparand) {\n                return comparand instanceof SQNowExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitDefaultValue = function (expr, comparand) {\n                return comparand instanceof SQDefaultValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitAnyValue = function (expr, comparand) {\n                return comparand instanceof SQAnyValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitResourcePackageItem = function (expr, comparand) {\n                return comparand instanceof SQResourcePackageItemExpr &&\n                    expr.packageName === comparand.packageName &&\n                    expr.packageType === comparand.packageType &&\n                    expr.itemName === comparand.itemName;\n            };\n            SQExprEqualityVisitor.prototype.visitStartsWith = function (expr, comparand) {\n                return comparand instanceof SQStartsWithExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitConstant = function (expr, comparand) {\n                if (comparand instanceof SQConstantExpr && expr.type === comparand.type)\n                    return expr.type.text && this.ignoreCase ?\n                        StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) :\n                        expr.valueEncoded === comparand.valueEncoded;\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitFillRule = function (expr, comparand) {\n                if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\n                    var leftRule = expr.rule, rightRule = comparand.rule;\n                    if (leftRule === rightRule)\n                        return true;\n                    var leftLinearGradient2 = leftRule.linearGradient2, rightLinearGradient2 = rightRule.linearGradient2;\n                    if (leftLinearGradient2 && rightLinearGradient2) {\n                        return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\n                    }\n                    var leftLinearGradient3 = leftRule.linearGradient3, rightLinearGradient3 = rightRule.linearGradient3;\n                    if (leftLinearGradient3 && rightLinearGradient3) {\n                        return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\n                    }\n                }\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient2 = function (left2, right2) {\n                debug.assertValue(left2, 'left2');\n                debug.assertValue(right2, 'right2');\n                return this.equalsFillRuleStop(left2.min, right2.min) &&\n                    this.equalsFillRuleStop(left2.max, right2.max);\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient3 = function (left3, right3) {\n                debug.assertValue(left3, 'left3');\n                debug.assertValue(right3, 'right3');\n                return this.equalsFillRuleStop(left3.min, right3.min) &&\n                    this.equalsFillRuleStop(left3.mid, right3.mid) &&\n                    this.equalsFillRuleStop(left3.max, right3.max);\n            };\n            SQExprEqualityVisitor.prototype.equalsFillRuleStop = function (stop1, stop2) {\n                debug.assertValue(stop1, 'stop1');\n                debug.assertValue(stop2, 'stop2');\n                if (!this.equals(stop1.color, stop2.color))\n                    return false;\n                if (!stop1.value)\n                    return stop1.value === stop2.value;\n                return this.equals(stop1.value, stop2.value);\n            };\n            SQExprEqualityVisitor.prototype.visitArithmetic = function (expr, comparand) {\n                return comparand instanceof SQArithmeticExpr &&\n                    expr.operator === comparand.operator &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitScopedEval = function (expr, comparand) {\n                return comparand instanceof SQScopedEvalExpr &&\n                    this.equals(expr.expression, comparand.expression) &&\n                    this.equalsAll(expr.scope, comparand.scope);\n            };\n            SQExprEqualityVisitor.prototype.visitWithRef = function (expr, comparand) {\n                return comparand instanceof SQWithRefExpr &&\n                    expr.expressionName === comparand.expressionName;\n            };\n            SQExprEqualityVisitor.prototype.optionalEqual = function (x, y) {\n                // Only check equality if both values are specified.\n                if (x && y)\n                    return x === y;\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.equals = function (x, y) {\n                return x.accept(this, y);\n            };\n            SQExprEqualityVisitor.prototype.equalsAll = function (x, y) {\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!this.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(/* ignoreCase */ false);\n            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(true);\n            return SQExprEqualityVisitor;\n        }());\n        /** Rewrites a root-level expression. */\n        var SQExprRootRewriter = (function (_super) {\n            __extends(SQExprRootRewriter, _super);\n            function SQExprRootRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRootRewriter.prototype.visitDefault = function (expr) {\n                return expr;\n            };\n            return SQExprRootRewriter;\n        }(data.DefaultSQExprVisitor));\n        var SQExprValidationVisitor = (function (_super) {\n            __extends(SQExprValidationVisitor, _super);\n            function SQExprValidationVisitor(schema, aggrUtils, errors) {\n                debug.assertValue(schema, 'schema');\n                debug.assertValue(aggrUtils, 'aggrUtils');\n                _super.call(this);\n                this.schema = schema;\n                this.aggrUtils = aggrUtils;\n                if (errors)\n                    this.errors = errors;\n            }\n            SQExprValidationVisitor.prototype.visitIn = function (expr) {\n                var inExpr = _super.prototype.visitIn.call(this, expr);\n                var args = inExpr.args;\n                var values = inExpr.values;\n                for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                    var valueTuple = values_2[_i];\n                    debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\n                    for (var i = 0, len = valueTuple.length; i < len; ++i)\n                        this.validateCompatibleType(args[i], valueTuple[i]);\n                }\n                return inExpr;\n            };\n            SQExprValidationVisitor.prototype.visitCompare = function (expr) {\n                var compareExpr = _super.prototype.visitCompare.call(this, expr);\n                this.validateCompatibleType(compareExpr.left, compareExpr.right);\n                return compareExpr;\n            };\n            SQExprValidationVisitor.prototype.visitColumnRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.column.name);\n                        if (!prop ||\n                            prop.kind !== 0 /* Column */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(3 /* invalidColumnReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitMeasureRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.measure.name);\n                        if (!prop ||\n                            prop.kind !== 1 /* Measure */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(4 /* invalidMeasureReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitAggr = function (expr) {\n                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\n                if (columnRefExpr) {\n                    if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/ null))\n                        this.register(0 /* invalidAggregateFunction */);\n                }\n                return aggregateExpr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchy = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = fieldExpr.hierarchy;\n                    if (fieldExprItem) {\n                        this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\n                    }\n                    else {\n                        this.register(5 /* invalidHierarchyReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var hierarchyLevelFieldExprItem = fieldExpr.hierarchyLevel;\n                    if (hierarchyLevelFieldExprItem) {\n                        this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\n                    }\n                    else if (!fieldExpr.columnHierarchyLevelVariation) {\n                        this.register(6 /* invalidHierarchyLevelReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitPercentile = function (expr) {\n                expr.arg.accept(this);\n                if (_.isEmpty(this.errors)) {\n                    var argMetadata = expr.arg.getMetadata(this.schema);\n                    if (!argMetadata ||\n                        argMetadata.kind !== 0 /* Column */ ||\n                        !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {\n                        this.register(10 /* invalidPercentileArgument */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitEntity = function (expr) {\n                this.validateEntity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitContains = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitStartsWith = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitArithmetic = function (expr) {\n                this.validateArithmeticTypes(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitScopedEval = function (expr) {\n                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {\n                    var scopeRef = _a[_i];\n                    if (!(SQExpr.isWithRef(scopeRef) || SQExpr.isColumn(scopeRef))) {\n                        this.register(11 /* invalidScopeArgument */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitWithRef = function (expr) {\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.validateOperandsAndTypeForStartOrContains = function (left, right) {\n                if (left instanceof SQColumnRefExpr) {\n                    this.visitColumnRef(left);\n                }\n                else if (left instanceof SQHierarchyLevelExpr) {\n                    this.visitHierarchyLevel(left);\n                }\n                else {\n                    this.register(7 /* invalidLeftOperandType */);\n                }\n                if (!(right instanceof SQConstantExpr) || !right.type.text)\n                    this.register(8 /* invalidRightOperandType */);\n                else\n                    this.validateCompatibleType(left, right);\n            };\n            SQExprValidationVisitor.prototype.validateArithmeticTypes = function (left, right) {\n                if (!data.SQExprUtils.supportsArithmetic(left, this.schema))\n                    this.register(7 /* invalidLeftOperandType */);\n                if (!data.SQExprUtils.supportsArithmetic(right, this.schema))\n                    this.register(8 /* invalidRightOperandType */);\n            };\n            SQExprValidationVisitor.prototype.validateCompatibleType = function (left, right) {\n                var leftMetadata = left.getMetadata(this.schema), leftType = leftMetadata && leftMetadata.type, rightMetadata = right.getMetadata(this.schema), rightType = rightMetadata && rightMetadata.type;\n                if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\n                    this.register(9 /* invalidValueType */);\n            };\n            SQExprValidationVisitor.prototype.validateEntity = function (schemaName, entityName) {\n                var schema = this.schema.schema(schemaName);\n                if (schema) {\n                    var entity = schema.entities.withName(entityName);\n                    if (entity)\n                        return entity;\n                    this.register(2 /* invalidEntityReference */);\n                }\n                else {\n                    this.register(1 /* invalidSchemaReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchy = function (schemaName, entityName, hierarchyName) {\n                var entity = this.validateEntity(schemaName, entityName);\n                if (entity) {\n                    var hierarchy = entity.hierarchies.withName(hierarchyName);\n                    if (hierarchy)\n                        return hierarchy;\n                    this.register(5 /* invalidHierarchyReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchyLevel = function (schemaName, entityName, hierarchyName, levelName) {\n                var hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\n                if (hierarchy) {\n                    var hierarchyLevel = hierarchy.levels.withName(levelName);\n                    if (hierarchyLevel)\n                        return hierarchyLevel;\n                    this.register(6 /* invalidHierarchyLevelReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.register = function (error) {\n                if (!this.errors)\n                    this.errors = [];\n                this.errors.push(error);\n            };\n            SQExprValidationVisitor.prototype.isQueryable = function (fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\n                    var hierarchyLevelConceptualProperty = data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\n                    return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== 1 /* Error */;\n                }\n                return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, data.FieldExprPattern.getPropertyName(fieldExpr)).queryable !== 1 /* Error */;\n            };\n            return SQExprValidationVisitor;\n        }(data.SQExprRewriter));\n        data.SQExprValidationVisitor = SQExprValidationVisitor;\n        /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\n        var SQExprAggregateInfoVisitor = (function (_super) {\n            __extends(SQExprAggregateInfoVisitor, _super);\n            function SQExprAggregateInfoVisitor() {\n                _super.apply(this, arguments);\n            }\n            SQExprAggregateInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.func;\n            };\n            SQExprAggregateInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprAggregateInfoVisitor.getAggregate = function (expr) {\n                var visitor = new SQExprAggregateInfoVisitor();\n                return expr.accept(visitor);\n            };\n            return SQExprAggregateInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQExprColumnRef expression or undefined.*/\n        var SQExprColumnRefInfoVisitor = (function (_super) {\n            __extends(SQExprColumnRefInfoVisitor, _super);\n            function SQExprColumnRefInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return expr;\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var ref = expr.level;\n                var hierarchy = (expr.arg);\n                var sourceExpr = hierarchy.accept(this);\n                if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\n                    var propertyVariationSource = hierarchy.arg;\n                    var targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\n                    if (sourceExpr && targetEntity) {\n                        var schemaName = (sourceExpr.source).schema;\n                        var targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\n                        var schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\n                        if (schemaHierarchy) {\n                            for (var _i = 0, _a = schemaHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                if (level.name === ref)\n                                    return new SQColumnRefExpr(targetEntityExpr, level.column.name);\n                            }\n                        }\n                    }\n                }\n                else {\n                    var entityExpr = (hierarchy.arg);\n                    var hierarchyLevelRef = data.SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema, entityExpr.schema, entityExpr.entity, hierarchy.hierarchy, expr.level);\n                    if (hierarchyLevelRef)\n                        return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\n                }\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var propertyName = expr.property;\n                return new SQColumnRefExpr(expr.arg, propertyName);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQExprColumnRefInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQEntityExpr expression or undefined.*/\n        var SQEntityExprInfoVisitor = (function (_super) {\n            __extends(SQEntityExprInfoVisitor, _super);\n            function SQEntityExprInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQEntityExprInfoVisitor.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQEntityExprInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return SQEntityExprInfoVisitor.getEntity(expr);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQEntityExprInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitAggr = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitMeasureRef = function (expr) {\n                return expr.source.accept(this);\n            };\n            SQEntityExprInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            SQEntityExprInfoVisitor.getEntity = function (columnRef) {\n                var field = data.SQExprConverter.asFieldPattern(columnRef);\n                var column = field.column;\n                return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\n            };\n            SQEntityExprInfoVisitor.getEntityExpr = function (schema, expr) {\n                var visitor = new SQEntityExprInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQEntityExprInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        var SQExprChangeAggregateRewriter = (function (_super) {\n            __extends(SQExprChangeAggregateRewriter, _super);\n            function SQExprChangeAggregateRewriter(func) {\n                debug.assertValue(func, 'func');\n                _super.call(this);\n                this.func = func;\n            }\n            SQExprChangeAggregateRewriter.prototype.visitAggr = function (expr) {\n                if (expr.func === this.func)\n                    return expr;\n                return new SQAggregationExpr(expr.arg, this.func);\n            };\n            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function (expr) {\n                return new SQAggregationExpr(expr, this.func);\n            };\n            SQExprChangeAggregateRewriter.rewrite = function (expr, func) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(func, 'func');\n                var rewriter = new SQExprChangeAggregateRewriter(func);\n                return expr.accept(rewriter);\n            };\n            return SQExprChangeAggregateRewriter;\n        }(SQExprRootRewriter));\n        var FieldExprChangeAggregateRewriter = (function () {\n            function FieldExprChangeAggregateRewriter(sqExpr, aggregate) {\n                this.sqExpr = sqExpr;\n                this.aggregate = aggregate;\n            }\n            FieldExprChangeAggregateRewriter.rewrite = function (sqExpr, aggregate) {\n                return data.FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {\n                pattern.baseExpr = data.SQExprConverter.asFieldPattern(SQExprChangeAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr), this.aggregate));\n                return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumn = function (column) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitSelectRef = function (selectRef) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitEntity = function (entity) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitMeasure = function (measure) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitPercentile = function (percentile) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.defaultRewrite = function () {\n                return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);\n            };\n            return FieldExprChangeAggregateRewriter;\n        }());\n        var FieldExprRemoveAggregateRewriter = (function () {\n            function FieldExprRemoveAggregateRewriter(sqExpr) {\n                this.sqExpr = sqExpr;\n            }\n            FieldExprRemoveAggregateRewriter.rewrite = function (sqExpr) {\n                return data.FieldExprPattern.visit(sqExpr, new FieldExprRemoveAggregateRewriter(sqExpr));\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {\n                return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr));\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumn = function (column) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitSelectRef = function (selectRef) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitEntity = function (entity) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitMeasure = function (measure) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitPercentile = function (percentile) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.defaultRewrite = function () {\n                return SQExprRemoveAggregateRewriter.rewrite(this.sqExpr);\n            };\n            return FieldExprRemoveAggregateRewriter;\n        }());\n        var SQExprRemoveAggregateRewriter = (function (_super) {\n            __extends(SQExprRemoveAggregateRewriter, _super);\n            function SQExprRemoveAggregateRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveAggregateRewriter.prototype.visitAggr = function (expr) {\n                return expr.arg;\n            };\n            SQExprRemoveAggregateRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveAggregateRewriter.instance);\n            };\n            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();\n            return SQExprRemoveAggregateRewriter;\n        }(SQExprRootRewriter));\n        var SQExprRemoveEntityVariablesRewriter = (function (_super) {\n            __extends(SQExprRemoveEntityVariablesRewriter, _super);\n            function SQExprRemoveEntityVariablesRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function (expr) {\n                if (expr.variable)\n                    return SQExprBuilder.entity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprRemoveEntityVariablesRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\n            };\n            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();\n            return SQExprRemoveEntityVariablesRewriter;\n        }(data.SQExprRewriter));\n        var SQExprRemovePercentOfGrandTotalRewriter = (function (_super) {\n            __extends(SQExprRemovePercentOfGrandTotalRewriter, _super);\n            function SQExprRemovePercentOfGrandTotalRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemovePercentOfGrandTotalRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);\n            };\n            SQExprRemovePercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr && fieldExpr.percentOfGrandTotal)\n                    expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);\n                return expr;\n            };\n            SQExprRemovePercentOfGrandTotalRewriter.instance = new SQExprRemovePercentOfGrandTotalRewriter();\n            return SQExprRemovePercentOfGrandTotalRewriter;\n        }(SQExprRootRewriter));\n        var SQExprSetPercentOfGrandTotalRewriter = (function (_super) {\n            __extends(SQExprSetPercentOfGrandTotalRewriter, _super);\n            function SQExprSetPercentOfGrandTotalRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprSetPercentOfGrandTotalRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);\n            };\n            SQExprSetPercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr && !fieldExpr.percentOfGrandTotal)\n                    expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: data.SQExprConverter.asFieldPattern(expr) } });\n                return expr;\n            };\n            SQExprSetPercentOfGrandTotalRewriter.instance = new SQExprSetPercentOfGrandTotalRewriter();\n            return SQExprSetPercentOfGrandTotalRewriter;\n        }(SQExprRootRewriter));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var StringExtensions = jsCommon.StringExtensions;\n        var SQExprUtils;\n        (function (SQExprUtils) {\n            function supportsArithmetic(expr, schema) {\n                var metadata = expr.getMetadata(schema), type = metadata && metadata.type;\n                if (!metadata || !type) {\n                    return false;\n                }\n                return type.numeric || type.dateTime || type.duration;\n            }\n            SQExprUtils.supportsArithmetic = supportsArithmetic;\n            function indexOfExpr(items, searchElement) {\n                debug.assertValue(items, 'items');\n                debug.assertValue(searchElement, 'searchElement');\n                for (var i = 0, len = items.length; i < len; i++) {\n                    if (data.SQExpr.equals(items[i], searchElement))\n                        return i;\n                }\n                return -1;\n            }\n            SQExprUtils.indexOfExpr = indexOfExpr;\n            function sequenceEqual(x, y) {\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!data.SQExpr.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            SQExprUtils.sequenceEqual = sequenceEqual;\n            function uniqueName(namedItems, expr, exprDefaultName) {\n                debug.assertValue(namedItems, 'namedItems');\n                // Determine all names\n                var names = {};\n                for (var i = 0, len = namedItems.length; i < len; i++)\n                    names[namedItems[i].name] = true;\n                return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\n            }\n            SQExprUtils.uniqueName = uniqueName;\n            /** Generates a default expression name  */\n            function defaultName(expr, fallback) {\n                if (fallback === void 0) { fallback = 'select'; }\n                if (!expr)\n                    return fallback;\n                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\n            }\n            SQExprUtils.defaultName = defaultName;\n            /** Gets a value indicating whether the expr is a model measure or an aggregate. */\n            function isMeasure(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsMeasureVisitor.instance);\n            }\n            SQExprUtils.isMeasure = isMeasure;\n            /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\n            function isAnyValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsAnyValueVisitor.instance);\n            }\n            SQExprUtils.isAnyValue = isAnyValue;\n            /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\n            function isDefaultValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsDefaultValueVisitor.instance);\n            }\n            SQExprUtils.isDefaultValue = isDefaultValue;\n            function discourageAggregation(expr, schema) {\n                var capabilities = getSchemaCapabilities(expr, schema);\n                return capabilities && capabilities.discourageQueryAggregateUsage;\n            }\n            SQExprUtils.discourageAggregation = discourageAggregation;\n            function getAggregateBehavior(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var column = getConceptualColumn(expr, schema);\n                if (column)\n                    return column.aggregateBehavior;\n            }\n            SQExprUtils.getAggregateBehavior = getAggregateBehavior;\n            function getSchemaCapabilities(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var field = data.SQExprConverter.asFieldPattern(expr);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var conceptualSchema = schema.schema(fieldExprItem.schema);\n                if (conceptualSchema)\n                    return conceptualSchema.capabilities;\n            }\n            SQExprUtils.getSchemaCapabilities = getSchemaCapabilities;\n            function getKpiMetadata(expr, schema) {\n                var kpiStatusProperty = getKpiStatusProperty(expr, schema);\n                if (kpiStatusProperty)\n                    return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\n                var kpiTrendProperty = getKpiTrendProperty(expr, schema);\n                if (kpiTrendProperty)\n                    return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\n            }\n            SQExprUtils.getKpiMetadata = getKpiMetadata;\n            function getConceptualEntity(entityExpr, schema) {\n                debug.assertValue(entityExpr, 'entityExpr');\n                var conceptualEntity = schema\n                    .schema(entityExpr.schema)\n                    .entities\n                    .withName(entityExpr.entity);\n                return conceptualEntity;\n            }\n            SQExprUtils.getConceptualEntity = getConceptualEntity;\n            function getKpiStatusProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.status === property)\n                    return property;\n            }\n            function getKpiTrendProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.trend === property)\n                    return property;\n            }\n            function getDefaultValue(fieldSQExpr, schema) {\n                var column = getConceptualColumn(fieldSQExpr, schema);\n                if (column)\n                    return column.defaultValue;\n            }\n            SQExprUtils.getDefaultValue = getDefaultValue;\n            function getConceptualColumn(fieldSQExpr, schema) {\n                if (!fieldSQExpr || !schema)\n                    return;\n                var sqField = data.SQExprConverter.asFieldPattern(fieldSQExpr);\n                if (!sqField)\n                    return;\n                var column = sqField.column;\n                if (column) {\n                    if (schema.schema(column.schema) && sqField.column.name) {\n                        var property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\n                        if (property)\n                            return property.column;\n                    }\n                }\n                else {\n                    var hierarchyLevelField = sqField.hierarchyLevel;\n                    if (hierarchyLevelField) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(sqField);\n                        var schemaName = fieldExprItem.schema;\n                        if (schema.schema(schemaName)) {\n                            var hierarchy = schema.schema(schemaName)\n                                .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\n                            if (hierarchy) {\n                                var hierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\n                                if (hierarchyLevel && hierarchyLevel.column)\n                                    return hierarchyLevel.column.column;\n                            }\n                        }\n                    }\n                }\n            }\n            function getDefaultValues(fieldSQExprs, schema) {\n                if (_.isEmpty(fieldSQExprs) || !schema)\n                    return;\n                var result = [];\n                for (var _i = 0, fieldSQExprs_2 = fieldSQExprs; _i < fieldSQExprs_2.length; _i++) {\n                    var sqExpr = fieldSQExprs_2[_i];\n                    var defaultValue = getDefaultValue(sqExpr, schema);\n                    if (defaultValue)\n                        result.push(defaultValue);\n                }\n                return result;\n            }\n            SQExprUtils.getDefaultValues = getDefaultValues;\n            /** Return compare or and expression for key value pairs. */\n            function getDataViewScopeIdentityComparisonExpr(fieldsExpr, values) {\n                debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\n                var compareExprs = [];\n                for (var i = 0; i < fieldsExpr.length; i++) {\n                    compareExprs.push(data.SQExprBuilder.compare(data.QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\n                }\n                if (_.isEmpty(compareExprs))\n                    return;\n                var resultExpr;\n                for (var _i = 0, compareExprs_1 = compareExprs; _i < compareExprs_1.length; _i++) {\n                    var compareExpr = compareExprs_1[_i];\n                    resultExpr = data.SQExprBuilder.and(resultExpr, compareExpr);\n                }\n                return resultExpr;\n            }\n            SQExprUtils.getDataViewScopeIdentityComparisonExpr = getDataViewScopeIdentityComparisonExpr;\n            function getActiveTablesNames(queryDefn) {\n                var tables = [];\n                if (queryDefn) {\n                    var selectedItems = queryDefn.from();\n                    if (selectedItems !== undefined) {\n                        for (var _i = 0, _a = selectedItems.keys(); _i < _a.length; _i++) {\n                            var key = _a[_i];\n                            var entityObj = selectedItems.entity(key);\n                            if (tables.indexOf(entityObj.entity) < 0)\n                                tables.push(entityObj.entity);\n                        }\n                    }\n                }\n                return tables;\n            }\n            SQExprUtils.getActiveTablesNames = getActiveTablesNames;\n            function isRelatedToMany(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 0 /* ZeroOrOne */, 2 /* Many */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 2 /* Many */, 0 /* ZeroOrOne */);\n            }\n            SQExprUtils.isRelatedToMany = isRelatedToMany;\n            function isRelatedToOne(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 2 /* Many */, 0 /* ZeroOrOne */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 0 /* ZeroOrOne */, 2 /* Many */);\n            }\n            SQExprUtils.isRelatedToOne = isRelatedToOne;\n            function isRelated(schema, sourceExpr, targetExpr, sourceMultiplicity, targetMultiplicity) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                if (_.isEmpty(source.navigationProperties))\n                    return false;\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var queue = [];\n                queue.push(source);\n                // walk the relationship path from source.\n                while (!_.isEmpty(queue)) {\n                    var current = queue.shift();\n                    var navProperties = current.navigationProperties;\n                    if (_.isEmpty(navProperties))\n                        continue;\n                    for (var _i = 0, navProperties_1 = navProperties; _i < navProperties_1.length; _i++) {\n                        var navProperty = navProperties_1[_i];\n                        if (!navProperty.isActive)\n                            continue;\n                        if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\n                            if (navProperty.targetEntity === target)\n                                return true;\n                            queue.push(navProperty.targetEntity);\n                        }\n                    }\n                }\n                return false;\n            }\n            function isRelatedOneToOne(schema, sourceExpr, targetExpr) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var sourceNavigations = source.navigationProperties;\n                var targetNavigations = target.navigationProperties;\n                if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\n                    return false;\n                return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\n            }\n            SQExprUtils.isRelatedOneToOne = isRelatedOneToOne;\n            function hasOneToOneNavigation(navigationProperties, targetEntity) {\n                if (_.isEmpty(navigationProperties))\n                    return false;\n                for (var _i = 0, navigationProperties_1 = navigationProperties; _i < navigationProperties_1.length; _i++) {\n                    var navigationProperty = navigationProperties_1[_i];\n                    if (!navigationProperty.isActive)\n                        continue;\n                    if (navigationProperty.targetEntity !== targetEntity)\n                        continue;\n                    if (navigationProperty.sourceMultiplicity === 0 /* ZeroOrOne */ &&\n                        navigationProperty.targetMultiplicity === 0 /* ZeroOrOne */) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\n                and returns a new array. When available, we should use _.unionWith from lodash. */\n            function concatUnique(leftExprs, rightExprs) {\n                debug.assertValue(leftExprs, 'leftExprs');\n                debug.assertValue(rightExprs, 'rightExprs');\n                var concatExprs = ArrayExtensions.copy(leftExprs);\n                for (var _i = 0, rightExprs_1 = rightExprs; _i < rightExprs_1.length; _i++) {\n                    var expr = rightExprs_1[_i];\n                    if (indexOfExpr(concatExprs, expr) === -1) {\n                        concatExprs.push(expr);\n                    }\n                }\n                return concatExprs;\n            }\n            SQExprUtils.concatUnique = concatUnique;\n            var SQExprDefaultNameGenerator = (function (_super) {\n                __extends(SQExprDefaultNameGenerator, _super);\n                function SQExprDefaultNameGenerator() {\n                    _super.apply(this, arguments);\n                }\n                SQExprDefaultNameGenerator.prototype.visitEntity = function (expr) {\n                    return expr.entity;\n                };\n                SQExprDefaultNameGenerator.prototype.visitColumnRef = function (expr) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function (expr, fallback) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitAggr = function (expr, fallback) {\n                    return data.QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitPercentile = function (expr, fallback) {\n                    var func = expr.exclusive\n                        ? 'Percentile.Exc('\n                        : 'Percentile.Inc(';\n                    return func + expr.arg.accept(this) + ', ' + expr.k + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitArithmetic = function (expr, fallback) {\n                    return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitConstant = function (expr) {\n                    return 'const';\n                };\n                SQExprDefaultNameGenerator.prototype.visitDefault = function (expr, fallback) {\n                    return fallback || 'expr';\n                };\n                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();\n                return SQExprDefaultNameGenerator;\n            }(data.DefaultSQExprVisitorWithArg));\n            var IsMeasureVisitor = (function (_super) {\n                __extends(IsMeasureVisitor, _super);\n                function IsMeasureVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsMeasureVisitor.prototype.visitMeasureRef = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitAggr = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitArithmetic = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsMeasureVisitor.instance = new IsMeasureVisitor();\n                return IsMeasureVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsDefaultValueVisitor = (function (_super) {\n                __extends(IsDefaultValueVisitor, _super);\n                function IsDefaultValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsDefaultValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitDefaultValue = function (expr) {\n                    return true;\n                };\n                IsDefaultValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsDefaultValueVisitor.instance = new IsDefaultValueVisitor();\n                return IsDefaultValueVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsAnyValueVisitor = (function (_super) {\n                __extends(IsAnyValueVisitor, _super);\n                function IsAnyValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsAnyValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnyValue = function (expr) {\n                    return true;\n                };\n                IsAnyValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsAnyValueVisitor.instance = new IsAnyValueVisitor();\n                return IsAnyValueVisitor;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SemanticQueryRewriter = (function () {\n            function SemanticQueryRewriter(exprRewriter) {\n                this.exprRewriter = exprRewriter;\n            }\n            SemanticQueryRewriter.prototype.rewriteFrom = function (fromValue) {\n                var fromContents = {};\n                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();\n                for (var i = 0, len = originalFromKeys.length; i < len; i++) {\n                    var keyName = originalFromKeys[i], originalEntityRef = originalFrom.entity(keyName), originalEntityExpr = data.SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);\n                    fromContents[keyName] = {\n                        schema: updatedEntityExpr.schema,\n                        entity: updatedEntityExpr.entity,\n                    };\n                }\n                return new data.SQFrom(fromContents);\n            };\n            SemanticQueryRewriter.prototype.rewriteSelect = function (selectItems, from) {\n                debug.assertValue(selectItems, 'selectItems');\n                debug.assertValue(from, 'from');\n                return this.rewriteNamedSQExpressions(selectItems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteGroupBy = function (groupByitems, from) {\n                debug.assertAnyValue(groupByitems, 'groupByitems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(groupByitems))\n                    return;\n                return this.rewriteNamedSQExpressions(groupByitems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteNamedSQExpressions = function (expressions, from) {\n                var _this = this;\n                debug.assertValue(expressions, 'expressions');\n                return _.map(expressions, function (item) {\n                    return {\n                        name: item.name,\n                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(_this.exprRewriter), from)\n                    };\n                });\n            };\n            SemanticQueryRewriter.prototype.rewriteOrderBy = function (orderByItems, from) {\n                debug.assertAnyValue(orderByItems, 'orderByItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(orderByItems))\n                    return;\n                var orderBy = [];\n                for (var i = 0, len = orderByItems.length; i < len; i++) {\n                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\n                    orderBy.push({\n                        direction: item.direction,\n                        expr: updatedExpr,\n                    });\n                }\n                return orderBy;\n            };\n            SemanticQueryRewriter.prototype.rewriteWhere = function (whereItems, from) {\n                var _this = this;\n                debug.assertAnyValue(whereItems, 'whereItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(whereItems))\n                    return;\n                var where = [];\n                for (var i = 0, len = whereItems.length; i < len; i++) {\n                    var originalWhere = whereItems[i];\n                    var updatedWhere = {\n                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\n                    };\n                    if (originalWhere.target)\n                        updatedWhere.target = _.map(originalWhere.target, function (e) { return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from); });\n                    where.push(updatedWhere);\n                }\n                return where;\n            };\n            return SemanticQueryRewriter;\n        }());\n        data.SemanticQueryRewriter = SemanticQueryRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /**\n         * Represents a semantic query that is:\n         * 1) Round-trippable with a JSON QueryDefinition.\n         * 2) Immutable\n         * 3) Long-lived and does not have strong references to a conceptual model (only names).\n         */\n        var SemanticQuery = (function () {\n            function SemanticQuery(from, where, orderBy, select, groupBy) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(select, 'select');\n                this.fromValue = from;\n                this.whereItems = where;\n                this.orderByItems = orderBy;\n                this.selectItems = select;\n                this.groupByItems = groupBy;\n            }\n            SemanticQuery.create = function () {\n                if (!SemanticQuery.empty)\n                    SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\n                return SemanticQuery.empty;\n            };\n            SemanticQuery.createWithTrimmedFrom = function (from, where, orderBy, select, groupBy) {\n                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\n                // Where\n                if (where) {\n                    for (var i = 0, len = where.length; i < len; i++) {\n                        var filter = where[i];\n                        filter.condition.accept(unreferencedKeyFinder);\n                        var filterTarget = filter.target;\n                        if (filterTarget) {\n                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                                if (filterTarget[j])\n                                    filterTarget[j].accept(unreferencedKeyFinder);\n                        }\n                    }\n                }\n                // OrderBy\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++)\n                        orderBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                // Select\n                for (var i = 0, len = select.length; i < len; i++)\n                    select[i].expr.accept(unreferencedKeyFinder);\n                // GroupBy\n                if (groupBy) {\n                    for (var i = 0, len = groupBy.length; i < len; i++)\n                        groupBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                var unreferencedKeys = unreferencedKeyFinder.result();\n                for (var i = 0, len = unreferencedKeys.length; i < len; i++)\n                    from.remove(unreferencedKeys[i]);\n                return new SemanticQuery(from, where, orderBy, select, groupBy);\n            };\n            SemanticQuery.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticQuery.prototype.select = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getSelect();\n                return this.setSelect(values);\n            };\n            SemanticQuery.prototype.getSelect = function () {\n                return SemanticQuery.createNamedExpressionArray(this.selectItems);\n            };\n            SemanticQuery.createNamedExpressionArray = function (items) {\n                return ArrayExtensions.extendWithName(_.map(items, function (s) {\n                    return {\n                        name: s.name,\n                        expr: s.expr,\n                    };\n                }));\n            };\n            SemanticQuery.prototype.setSelect = function (values) {\n                var from = this.fromValue.clone();\n                var selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.rewriteExpressionsWithSourceRenames = function (values, from) {\n                var items = [];\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    items.push({\n                        name: value.name,\n                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\n                    });\n                }\n                return items;\n            };\n            /** Removes the given expression from the select. */\n            SemanticQuery.prototype.removeSelect = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var originalItems = this.selectItems, selectItems = [];\n                for (var i = 0, len = originalItems.length; i < len; i++) {\n                    var originalExpr = originalItems[i];\n                    if (data.SQExpr.equals(originalExpr.expr, expr))\n                        continue;\n                    selectItems.push(originalExpr);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            /** Removes the given expression from order by. */\n            SemanticQuery.prototype.removeOrderBy = function (expr) {\n                var sorts = this.orderBy();\n                for (var i = sorts.length - 1; i >= 0; i--) {\n                    if (data.SQExpr.equals(sorts[i].expr, expr))\n                        sorts.splice(i, 1);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.selectNameOf = function (expr) {\n                var index = data.SQExprUtils.indexOfExpr(_.map(this.selectItems, function (s) { return s.expr; }), expr);\n                if (index >= 0)\n                    return this.selectItems[index].name;\n            };\n            SemanticQuery.prototype.setSelectAt = function (index, expr) {\n                debug.assertValue(expr, 'expr');\n                if (index >= this.selectItems.length)\n                    return;\n                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;\n                select[index] = {\n                    name: originalName,\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\n            };\n            /** Adds a the expression to the select clause. */\n            SemanticQuery.prototype.addSelect = function (expr, exprName) {\n                debug.assertValue(expr, 'expr');\n                var selectItems = this.select(), from = this.fromValue.clone();\n                selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.createNamedExpr = function (currentNames, from, expr, exprName) {\n                return {\n                    name: data.SQExprUtils.uniqueName(currentNames, expr, exprName),\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n            };\n            SemanticQuery.prototype.groupBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getGroupBy();\n                return this.setGroupBy(values);\n            };\n            SemanticQuery.prototype.getGroupBy = function () {\n                return SemanticQuery.createNamedExpressionArray(this.groupByItems);\n            };\n            SemanticQuery.prototype.setGroupBy = function (values) {\n                var from = this.fromValue.clone();\n                var groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.addGroupBy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var groupByItems = this.groupBy(), from = this.fromValue.clone();\n                groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.orderBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getOrderBy();\n                return this.setOrderBy(values);\n            };\n            SemanticQuery.prototype.getOrderBy = function () {\n                var result = [];\n                var orderBy = this.orderByItems;\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++) {\n                        var clause = orderBy[i];\n                        result.push({\n                            expr: clause.expr,\n                            direction: clause.direction,\n                        });\n                    }\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setOrderBy = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedOrderBy = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var clause = values[i];\n                    updatedOrderBy.push({\n                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\n                        direction: clause.direction,\n                    });\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.where = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getWhere();\n                return this.setWhere(values);\n            };\n            SemanticQuery.prototype.getWhere = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                if (whereItems) {\n                    for (var i = 0, len = whereItems.length; i < len; i++)\n                        result.push(whereItems[i]);\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setWhere = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedWhere = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var filter = values[i];\n                    var updatedFilter = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\n                    };\n                    var filterTarget = filter.target;\n                    if (filterTarget) {\n                        updatedFilter.target = [];\n                        for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                            if (filterTarget[j]) {\n                                var updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\n                                updatedFilter.target.push(updatedTarget);\n                            }\n                    }\n                    updatedWhere.push(updatedFilter);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.addWhere = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedWhere = this.where(), incomingWhere = filter.where(), from = this.fromValue.clone();\n                for (var i = 0, len = incomingWhere.length; i < len; i++) {\n                    var clause = incomingWhere[i];\n                    var updatedClause = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\n                    };\n                    if (clause.target)\n                        updatedClause.target = _.map(clause.target, function (t) { return SQExprRewriterWithSourceRenames.rewrite(t, from); });\n                    updatedWhere.push(updatedClause);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                var orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\n                var select = rewriter.rewriteSelect(this.selectItems, from);\n                var groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\n                return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\n            };\n            return SemanticQuery;\n        }());\n        data.SemanticQuery = SemanticQuery;\n        /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\n        var SemanticFilter = (function () {\n            function SemanticFilter(from, where) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                this.fromValue = from;\n                this.whereItems = where;\n            }\n            SemanticFilter.fromSQExpr = function (contract) {\n                debug.assertValue(contract, 'contract');\n                var from = new SQFrom();\n                var rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\n                // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\n                //         Thus not setting a target here.\n                var where = [{\n                        condition: rewrittenContract\n                    }];\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.getDefaultValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.defaultValue());\n            };\n            SemanticFilter.getAnyValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.anyValue());\n            };\n            SemanticFilter.getDataViewScopeIdentityComparisonFilters = function (fieldSQExprs, value) {\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assertValue(value, 'value');\n                if (fieldSQExprs instanceof Array) {\n                    var values = Array.apply(null, Array(fieldSQExprs.length)).map(function () { return value; });\n                    return SemanticFilter.fromSQExpr(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(fieldSQExprs, values));\n                }\n                return SemanticFilter.fromSQExpr(data.SQExprBuilder.equal(fieldSQExprs, value));\n            };\n            SemanticFilter.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticFilter.prototype.conditions = function () {\n                var expressions = [];\n                var where = this.whereItems;\n                for (var i = 0, len = where.length; i < len; i++) {\n                    var filter = where[i];\n                    expressions.push(filter.condition);\n                }\n                return expressions;\n            };\n            SemanticFilter.prototype.where = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                for (var i = 0, len = whereItems.length; i < len; i++)\n                    result.push(whereItems[i]);\n                return result;\n            };\n            SemanticFilter.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new data.SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.rewrite(validator);\n                return validator.errors;\n            };\n            /** Merges a list of SemanticFilters into one. */\n            SemanticFilter.merge = function (filters) {\n                if (_.isEmpty(filters))\n                    return null;\n                if (filters.length === 1)\n                    return filters[0];\n                var firstFilter = filters[0];\n                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\n                for (var i = 1, len = filters.length; i < len; i++)\n                    SemanticFilter.applyFilter(filters[i], from, where);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.isDefaultFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isDefaultValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isAnyFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isAnyValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isSameFilter = function (leftFilter, rightFilter) {\n                if (jsCommon.JsonComparer.equals(leftFilter, rightFilter)) {\n                    return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\n                        || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\n                }\n                return false;\n            };\n            SemanticFilter.applyFilter = function (filter, from, where) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                // Where\n                var filterWhereItems = filter.whereItems;\n                for (var i = 0; i < filterWhereItems.length; i++) {\n                    var filterWhereItem = filterWhereItems[i];\n                    var updatedWhereItem = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\n                    };\n                    if (filterWhereItem.target)\n                        updatedWhereItem.target = _.map(filterWhereItem.target, function (e) { return SQExprRewriterWithSourceRenames.rewrite(e, from); });\n                    where.push(updatedWhereItem);\n                }\n            };\n            return SemanticFilter;\n        }());\n        data.SemanticFilter = SemanticFilter;\n        /** Represents a SemanticQuery/SemanticFilter from clause. */\n        var SQFrom = (function () {\n            function SQFrom(items) {\n                this.items = items || {};\n            }\n            SQFrom.prototype.keys = function () {\n                return Object.keys(this.items);\n            };\n            SQFrom.prototype.entity = function (key) {\n                return this.items[key];\n            };\n            SQFrom.prototype.ensureEntity = function (entity, desiredVariableName) {\n                debug.assertValue(entity, 'entity');\n                // 1) Reuse a reference to the entity among the already referenced\n                var keys = this.keys();\n                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {\n                    var key = keys[i_1], item = this.items[key];\n                    if (item && entity.entity === item.entity && entity.schema === item.schema)\n                        return { name: key };\n                }\n                // 2) Add a reference to the entity\n                var candidateName = desiredVariableName || this.candidateName(entity.entity), uniqueName = candidateName, i = 2;\n                while (this.items[uniqueName]) {\n                    uniqueName = candidateName + i++;\n                }\n                this.items[uniqueName] = entity;\n                return { name: uniqueName, new: true };\n            };\n            SQFrom.prototype.remove = function (key) {\n                delete this.items[key];\n            };\n            /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\n            SQFrom.prototype.candidateName = function (ref) {\n                debug.assertValue(ref, 'ref');\n                var idx = ref.lastIndexOf('.');\n                if (idx >= 0 && (idx !== ref.length - 1))\n                    ref = ref.substr(idx + 1);\n                return ref.substring(0, 1).toLowerCase();\n            };\n            SQFrom.prototype.clone = function () {\n                // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\n                var cloned = new SQFrom();\n                // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\n                $.extend(cloned.items, this.items);\n                return cloned;\n            };\n            return SQFrom;\n        }());\n        data.SQFrom = SQFrom;\n        var SQExprRewriterWithSourceRenames = (function (_super) {\n            __extends(SQExprRewriterWithSourceRenames, _super);\n            function SQExprRewriterWithSourceRenames(renames) {\n                debug.assertValue(renames, 'renames');\n                _super.call(this);\n                this.renames = renames;\n            }\n            SQExprRewriterWithSourceRenames.prototype.visitEntity = function (expr) {\n                var updatedName = this.renames[expr.entity];\n                if (updatedName)\n                    return new data.SQEntityExpr(expr.schema, expr.entity, updatedName);\n                return _super.prototype.visitEntity.call(this, expr);\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteFilter = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedTargets = undefined;\n                if (filter.target)\n                    updatedTargets = this.rewriteArray(filter.target);\n                var updatedCondition = filter.condition.accept(this);\n                if (filter.condition === updatedCondition && filter.target === updatedTargets)\n                    return filter;\n                var updatedFilter = {\n                    condition: updatedCondition,\n                };\n                if (updatedTargets)\n                    updatedFilter.target = updatedTargets;\n                return updatedFilter;\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteArray = function (exprs) {\n                debug.assertValue(exprs, 'exprs');\n                var updatedExprs;\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i], rewrittenExpr = expr.accept(this);\n                    if (expr !== rewrittenExpr && !updatedExprs)\n                        updatedExprs = ArrayExtensions.take(exprs, i);\n                    if (updatedExprs)\n                        updatedExprs.push(rewrittenExpr);\n                }\n                return updatedExprs || exprs;\n            };\n            SQExprRewriterWithSourceRenames.rewrite = function (expr, from) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(from, 'from');\n                var renames = QuerySourceRenameDetector.run(expr, from);\n                var rewriter = new SQExprRewriterWithSourceRenames(renames);\n                return expr.accept(rewriter);\n            };\n            return SQExprRewriterWithSourceRenames;\n        }(data.SQExprRewriter));\n        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;\n        /** Responsible for updating a QueryFrom based on SQExpr references. */\n        var QuerySourceRenameDetector = (function (_super) {\n            __extends(QuerySourceRenameDetector, _super);\n            function QuerySourceRenameDetector(from) {\n                debug.assertValue(from, 'from');\n                _super.call(this);\n                this.from = from;\n                this.renames = {};\n            }\n            QuerySourceRenameDetector.run = function (expr, from) {\n                var detector = new QuerySourceRenameDetector(from);\n                expr.accept(detector);\n                return detector.renames;\n            };\n            QuerySourceRenameDetector.prototype.visitEntity = function (expr) {\n                // TODO: Renames must take the schema into account, not just entity set name.\n                var existingEntity = this.from.entity(expr.variable);\n                if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\n                    return;\n                var actualEntity = this.from.ensureEntity({\n                    schema: expr.schema,\n                    entity: expr.entity,\n                }, expr.variable);\n                this.renames[expr.entity] = actualEntity.name;\n            };\n            return QuerySourceRenameDetector;\n        }(data.DefaultSQExprVisitorWithTraversal));\n        /** Visitor for finding unreferenced sources. */\n        var UnreferencedKeyFinder = (function (_super) {\n            __extends(UnreferencedKeyFinder, _super);\n            function UnreferencedKeyFinder(keys) {\n                debug.assertValue(keys, 'keys');\n                _super.call(this);\n                this.keys = keys;\n            }\n            UnreferencedKeyFinder.prototype.visitEntity = function (expr) {\n                var index = this.keys.indexOf(expr.variable);\n                if (index >= 0)\n                    this.keys.splice(index, 1);\n            };\n            UnreferencedKeyFinder.prototype.result = function () {\n                return this.keys;\n            };\n            return UnreferencedKeyFinder;\n        }(data.DefaultSQExprVisitorWithTraversal));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewTransform = powerbi.data.DataViewTransform;\n        var SQExprBuilder = powerbi.data.SQExprBuilder;\n        function createCategoricalDataViewBuilder() {\n            return new CategoricalDataViewBuilder();\n        }\n        data.createCategoricalDataViewBuilder = createCategoricalDataViewBuilder;\n        var CategoricalDataViewBuilder = (function () {\n            function CategoricalDataViewBuilder() {\n                this.categories = [];\n                this.staticMeasureColumns = [];\n                this.dynamicMeasureColumns = [];\n                this.columnIndex = 0;\n            }\n            CategoricalDataViewBuilder.prototype.withCategory = function (options) {\n                var categoryValues = options.values, identityFrom = options.identityFrom, type = options.source.type;\n                var categoryColumn = {\n                    source: options.source,\n                    identityFields: options.identityFrom.fields,\n                    identity: options.identityFrom.identities || [],\n                    values: categoryValues,\n                };\n                if (!options.identityFrom.identities) {\n                    for (var categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\n                        categoryColumn.identity.push(getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\n                    }\n                }\n                if (!this.categories)\n                    this.categories = [];\n                this.categories.push(categoryColumn);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withCategories = function (categories) {\n                if (_.isEmpty(this.categories))\n                    this.categories = categories;\n                else\n                    Array.prototype.push.apply(this.categories, categories);\n                return this;\n            };\n            /**\n             * Adds static series columns.\n             *\n             * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in\n             * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\n             */\n            CategoricalDataViewBuilder.prototype.withValues = function (options) {\n                debug.assertValue(options, 'options');\n                var columns = options.columns;\n                debug.assertValue(columns, 'columns');\n                for (var _i = 0, columns_8 = columns; _i < columns_8.length; _i++) {\n                    var column = columns_8[_i];\n                    this.staticMeasureColumns.push(column.source);\n                }\n                this.staticSeriesValues = columns;\n                return this;\n            };\n            /**\n             * Adds dynamic series columns.\n             *\n             * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in\n             * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\n             */\n            CategoricalDataViewBuilder.prototype.withGroupedValues = function (options) {\n                debug.assertValue(options, 'options');\n                var groupColumn = options.groupColumn;\n                debug.assertValue(groupColumn, 'groupColumn');\n                this.dynamicSeriesMetadata = {\n                    column: groupColumn.source,\n                    identityFrom: groupColumn.identityFrom,\n                    values: groupColumn.values,\n                };\n                var valueColumns = options.valueColumns;\n                for (var _i = 0, valueColumns_1 = valueColumns; _i < valueColumns_1.length; _i++) {\n                    var valueColumn = valueColumns_1[_i];\n                    this.dynamicMeasureColumns.push(valueColumn.source);\n                }\n                this.dynamicSeriesValues = options.data;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.fillData = function (dataViewValues) {\n                var categoryColumn = _.first(this.categories);\n                var categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 0;\n                if (this.hasDynamicSeries()) {\n                    for (var seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\n                        var seriesMeasures = this.dynamicSeriesValues[seriesIndex];\n                        debug.assert(seriesMeasures.length === this.dynamicMeasureColumns.length, 'seriesMeasures.length === this.dynamicMeasureColumns.length');\n                        for (var measureIndex = 0, measuresLen = this.dynamicMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                            var groupIndex = seriesIndex * measuresLen + measureIndex;\n                            applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\n                        }\n                    }\n                }\n                if (this.hasStaticSeries()) {\n                    // Note: when the target categorical has both dynamic and static series, append static measures at the end of the values array.\n                    var staticColumnsStartingIndex = this.hasDynamicSeries() ? (this.dynamicSeriesValues.length * this.dynamicMeasureColumns.length) : 0;\n                    for (var measureIndex = 0, measuresLen = this.staticMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                        applySeriesData(dataViewValues[staticColumnsStartingIndex + measureIndex], this.staticSeriesValues[measureIndex], categoryLength);\n                    }\n                }\n            };\n            /**\n             * Returns the DataView with metadata and DataViewCategorical.\n             * Returns undefined if the combination of parameters is illegal, such as having both dynamic series and static series when building a visual DataView.\n             */\n            CategoricalDataViewBuilder.prototype.build = function () {\n                var metadataColumns = [];\n                var categorical = {};\n                var categoryMetadata = this.categories;\n                var dynamicSeriesMetadata = this.dynamicSeriesMetadata;\n                // --- Build metadata columns and value groups ---\n                for (var _i = 0, categoryMetadata_1 = categoryMetadata; _i < categoryMetadata_1.length; _i++) {\n                    var columnMetadata = categoryMetadata_1[_i];\n                    pushIfNotExists(metadataColumns, columnMetadata.source);\n                }\n                if (this.hasDynamicSeries()) {\n                    // Dynamic series, or Dyanmic & Static series.\n                    pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\n                    categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\n                    // For each series value we will make one column per measure\n                    var seriesValues = dynamicSeriesMetadata.values;\n                    for (var seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\n                        var seriesValue = seriesValues[seriesIndex];\n                        var seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\n                        for (var _a = 0, _b = this.dynamicMeasureColumns; _a < _b.length; _a++) {\n                            var measure = _b[_a];\n                            var column = _.clone(measure);\n                            column.groupName = seriesValue;\n                            pushIfNotExists(metadataColumns, column);\n                            categorical.values.push({\n                                source: column,\n                                values: [],\n                                identity: seriesIdentity,\n                            });\n                        }\n                    }\n                    if (this.hasStaticSeries()) {\n                        // IMPORTANT: In the Dyanmic & Static series case, the groups array shall not include any static group. This is to match the behavior of production code that creates query DataView objects.\n                        // Get the current return value of grouped() before adding static measure columns, an use that as the return value of this categorical.\n                        // Otherwise, the default behavior of DataViewValueColumns.grouped() from DataViewTransform.createValueColumns() is to create series groups from all measure columns.\n                        var dynamicSeriesGroups_1 = categorical.values.grouped();\n                        categorical.values.grouped = function () { return dynamicSeriesGroups_1; };\n                        this.appendStaticMeasureColumns(metadataColumns, categorical.values);\n                    }\n                }\n                else {\n                    // Static series only / no series\n                    categorical.values = DataViewTransform.createValueColumns();\n                    this.appendStaticMeasureColumns(metadataColumns, categorical.values);\n                }\n                var categories = this.categories;\n                if (!_.isEmpty(categories))\n                    categorical.categories = categories;\n                // --- Fill in data point values ---\n                this.fillData(categorical.values);\n                var dataView = {\n                    metadata: {\n                        columns: metadataColumns,\n                    },\n                    categorical: categorical,\n                };\n                if (this.isLegalDataView(dataView)) {\n                    return dataView;\n                }\n            };\n            CategoricalDataViewBuilder.prototype.appendStaticMeasureColumns = function (metadataColumns, valueColumns) {\n                debug.assertValue(metadataColumns, 'metadataColumns');\n                debug.assertValue(valueColumns, 'valueColumns');\n                if (!_.isEmpty(this.staticMeasureColumns)) {\n                    for (var _i = 0, _a = this.staticMeasureColumns; _i < _a.length; _i++) {\n                        var column = _a[_i];\n                        pushIfNotExists(metadataColumns, column);\n                        valueColumns.push({\n                            source: column,\n                            values: [],\n                        });\n                    }\n                }\n            };\n            CategoricalDataViewBuilder.prototype.isLegalDataView = function (dataView) {\n                if (this.hasDynamicSeries() && this.hasStaticSeries() && CategoricalDataViewBuilder.isVisualDataView(dataView.metadata.columns)) {\n                    // It is illegal to have both dynamic series and static series in a visual DataViewCategorical,\n                    // because the DataViewValueColumns interface today cannot express that 100% (see its 'source' property and return value of its 'grouped()' function).\n                    return false;\n                }\n                return true;\n            };\n            /**\n             * This function infers that if any metadata column has 'queryName',\n             * then the user of this builder is building a visual DataView (as opposed to query DataView).\n             *\n             * @param metadataColumns The complete collection of metadata columns in the categorical.\n             */\n            CategoricalDataViewBuilder.isVisualDataView = function (metadataColumns) {\n                return !_.isEmpty(metadataColumns) &&\n                    _.any(metadataColumns, function (metadataColumn) { return !!metadataColumn.queryName; });\n            };\n            CategoricalDataViewBuilder.prototype.hasDynamicSeries = function () {\n                return !!this.dynamicSeriesMetadata; // In Map visual scenarios, you can have dynamic series without measure columns\n            };\n            CategoricalDataViewBuilder.prototype.hasStaticSeries = function () {\n                return !!this.staticSeriesValues;\n            };\n            return CategoricalDataViewBuilder;\n        }());\n        function getScopeIdentity(source, index, value, valueType) {\n            var identities = source.identities;\n            if (identities) {\n                return identities[index];\n            }\n            debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\n            return data.createDataViewScopeIdentity(SQExprBuilder.equal(source.fields[0], SQExprBuilder.typedConstant(value, valueType)));\n        }\n        function pushIfNotExists(items, itemToAdd) {\n            if (_.contains(items, itemToAdd))\n                return;\n            items.push(itemToAdd);\n        }\n        function applySeriesData(target, source, categoryLength) {\n            debug.assertValue(target, 'target');\n            debug.assertValue(source, 'source');\n            debug.assertValue(categoryLength, 'categoryLength');\n            var values = source.values;\n            debug.assert(categoryLength === values.length || categoryLength === 0, 'categoryLength === values.length || categoryLength === 0');\n            target.values = values;\n            var highlights = source.highlights;\n            if (highlights) {\n                debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\n                target.highlights = highlights;\n            }\n            var aggregates;\n            if (source.minLocal !== undefined) {\n                if (!aggregates)\n                    aggregates = {};\n                aggregates.minLocal = source.minLocal;\n            }\n            if (source.maxLocal !== undefined) {\n                if (!aggregates)\n                    aggregates = {};\n                aggregates.maxLocal = source.maxLocal;\n            }\n            if (aggregates) {\n                target.source.aggregates = aggregates;\n                _.extend(target, aggregates);\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExpr = powerbi.data.SQExpr;\n        function createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n            return new StaticEvalContext(colorAllocatorCache || data.createColorAllocatorCache(), dataView || { metadata: { columns: [] } }, selectTransforms);\n        }\n        data.createStaticEvalContext = createStaticEvalContext;\n        /**\n         * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\n         * are supported.\n         */\n        var StaticEvalContext = (function () {\n            function StaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorCache = colorAllocatorCache;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            StaticEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorCache.get(expr);\n            };\n            StaticEvalContext.prototype.getExprValue = function (expr) {\n                var dataView = this.dataView, selectTransforms = this.selectTransforms;\n                if (!dataView || !selectTransforms)\n                    return;\n                if (SQExpr.isAggregation(expr)) {\n                    var columnAggregate = findAggregateValue(expr, selectTransforms, dataView.metadata.columns);\n                    if (columnAggregate !== undefined) {\n                        return columnAggregate;\n                    }\n                }\n                if (dataView.table)\n                    return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\n            };\n            StaticEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            return StaticEvalContext;\n        }());\n        function getExprValueFromTable(expr, selectTransforms, table, rowIdx) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            debug.assertValue(table, 'table');\n            debug.assertValue(rowIdx, 'rowIdx');\n            var rows = table.rows;\n            if (_.isEmpty(rows) || rows.length <= rowIdx)\n                return;\n            var cols = table.columns;\n            var selectIdx = findSelectIndex(expr, selectTransforms);\n            if (selectIdx < 0)\n                return;\n            for (var colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\n                if (selectIdx !== cols[colIdx].index)\n                    continue;\n                return rows[rowIdx][colIdx];\n            }\n        }\n        data.getExprValueFromTable = getExprValueFromTable;\n        function findAggregateValue(expr, selectTransforms, columns) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            debug.assertValue(columns, 'columns');\n            var selectIdx = findSelectIndex(expr.arg, selectTransforms);\n            if (selectIdx < 0)\n                return;\n            for (var colIdx = 0, colLen = columns.length; colIdx < colLen; colIdx++) {\n                var column = columns[colIdx], columnAggr = column.aggregates;\n                if (selectIdx !== column.index || !columnAggr)\n                    continue;\n                var aggregateValue = findAggregates(columnAggr, expr.func);\n                if (aggregateValue !== undefined)\n                    return aggregateValue;\n            }\n        }\n        function findSelectIndex(expr, selectTransforms) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            var queryName;\n            if (SQExpr.isSelectRef(expr))\n                queryName = expr.expressionName;\n            for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                var selectTransform = selectTransforms[selectIdx];\n                if (!selectTransform || !selectTransform.queryName)\n                    continue;\n                if (queryName) {\n                    if (selectTransform.queryName === queryName)\n                        return selectIdx;\n                }\n                else {\n                    if (SQExpr.equals(selectTransform.expr, expr))\n                        return selectIdx;\n                }\n            }\n            return -1;\n        }\n        function findAggregates(aggregates, func) {\n            debug.assertValue(aggregates, 'aggregates');\n            debug.assertValue(func, 'func');\n            switch (func) {\n                case data.QueryAggregateFunction.Min:\n                    return getOptional(aggregates.min, aggregates.minLocal);\n                case data.QueryAggregateFunction.Max:\n                    return getOptional(aggregates.max, aggregates.maxLocal);\n            }\n        }\n        function getOptional(value1, value2) {\n            debug.assertAnyValue(value1, 'value1');\n            debug.assertAnyValue(value2, 'value2');\n            if (value1 !== undefined)\n                return value1;\n            return value2;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createMatrixEvalContext(colorAllocatorProvider, dataViewMatrix) {\n            // NOTE: Matrix context-sensitive evaluation is not yet implemented.\n            return data.createStaticEvalContext(colorAllocatorProvider);\n        }\n        data.createMatrixEvalContext = createMatrixEvalContext;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi_1) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var Formatting = jsCommon.Formatting;\n    var RegExpExtensions = jsCommon.RegExpExtensions;\n    /** Formatting Encoder */\n    var FormattingEncoder;\n    (function (FormattingEncoder) {\n        function preserveEscaped(format, specialChars) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = \"\\\\\" + specialChars[i];\n                var newText = String.fromCharCode(0xE000 + i);\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveEscaped = preserveEscaped;\n        function restoreEscaped(format, specialChars) {\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = String.fromCharCode(0xE000 + i);\n                var newText = specialChars[i];\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\n        }\n        FormattingEncoder.restoreEscaped = restoreEscaped;\n        function preserveLiterals(format, literals) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            for (var i = 0;; i++) {\n                var fromIndex = format.indexOf(\"'\");\n                if (fromIndex < 0) {\n                    break;\n                }\n                var toIndex = format.indexOf(\"'\", fromIndex + 1);\n                if (toIndex < 0) {\n                    break;\n                }\n                var literal = format.substring(fromIndex, toIndex + 1);\n                literals.push(literal.substring(1, toIndex - fromIndex));\n                var token = String.fromCharCode(0xE100 + i);\n                format = format.replace(literal, token);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveLiterals = preserveLiterals;\n        function restoreLiterals(format, literals) {\n            var count = literals.length;\n            for (var i = 0; i < count; i++) {\n                var token = String.fromCharCode(0xE100 + i);\n                var literal = literals[i];\n                format = format.replace(token, literal);\n            }\n            return format;\n        }\n        FormattingEncoder.restoreLiterals = restoreLiterals;\n    })(FormattingEncoder || (FormattingEncoder = {}));\n    var IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\n    var ZeroPlaceholder = '0';\n    var DigitPlaceholder = '#';\n    var ExponentialFormatChar = 'E';\n    var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\n    var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\n    /** Formatting Service */\n    var FormattingService = (function () {\n        function FormattingService() {\n        }\n        FormattingService.prototype.formatValue = function (value, format, culture) {\n            // Handle special cases\n            if (value === undefined || value === null) {\n                return '';\n            }\n            var gculture = this.getCulture(culture);\n            if (DateTimeFormat.canFormat(value)) {\n                // Dates\n                return DateTimeFormat.format(value, format, gculture);\n            }\n            else if (NumberFormat.canFormat(value)) {\n                // Numbers\n                return NumberFormat.format(value, format, gculture);\n            }\n            else {\n                // Other data types - return as string\n                return value.toString();\n            }\n        };\n        FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {\n            var _this = this;\n            if (!formatWithIndexedTokens) {\n                return \"\";\n            }\n            var result = formatWithIndexedTokens.replace(IndexedTokensRegex, function (match, left, right, argToken) {\n                if (left) {\n                    return \"{\";\n                }\n                else if (right) {\n                    return \"}\";\n                }\n                else {\n                    var parts = argToken.split(\":\");\n                    var argIndex = parseInt(parts[0], 10);\n                    var argFormat = parts[1];\n                    return _this.formatValue(args[argIndex], argFormat, culture);\n                }\n            });\n            return result;\n        };\n        FormattingService.prototype.isStandardNumberFormat = function (format) {\n            return NumberFormat.isStandardFormat(format);\n        };\n        FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {\n            var gculture = this.getCulture(culture);\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\n        };\n        FormattingService.prototype.dateFormatString = function (unit) {\n            if (!this._dateTimeScaleFormatInfo)\n                this.initialize();\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\n        };\n        /**\n         * Sets the current localization culture\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         */\n        FormattingService.prototype.setCurrentCulture = function (cultureSelector) {\n            if (this._currentCultureSelector !== cultureSelector) {\n                this._currentCulture = this.getCulture(cultureSelector);\n                this._currentCultureSelector = cultureSelector;\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\n            }\n        };\n        /**\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         * Exposing this function for testability of unsupported cultures\n         */\n        FormattingService.prototype.getCulture = function (cultureSelector) {\n            if (cultureSelector == null) {\n                if (this._currentCulture == null) {\n                    this.initialize();\n                }\n                return this._currentCulture;\n            }\n            else {\n                var culture = Globalize.findClosestCulture(cultureSelector);\n                if (!culture)\n                    culture = Globalize.culture(\"en-US\");\n                return culture;\n            }\n        };\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\n        FormattingService.prototype.initialize = function () {\n            var cultureName = this.getCurrentCulture();\n            this.setCurrentCulture(cultureName);\n            var calendarName = this.getUrlParam(\"calendar\");\n            if (calendarName) {\n                var culture = this._currentCulture;\n                var c = culture.calendars[calendarName];\n                if (c) {\n                    culture.calendar = c;\n                }\n            }\n        };\n        /**\n         *  Exposing this function for testability\n         */\n        FormattingService.prototype.getCurrentCulture = function () {\n            var urlParam = this.getUrlParam(\"language\");\n            if (urlParam) {\n                return urlParam;\n            }\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\n                // Get cultureInfo set in powerbi\n                return powerbi.common.cultureInfo;\n            }\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\n        };\n        /**\n         *  Exposing this function for testability\n         *  @param name: queryString name\n         */\n        FormattingService.prototype.getUrlParam = function (name) {\n            var param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\n            return param ? param[1] : undefined;\n        };\n        return FormattingService;\n    }());\n    /**\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for dates.\n     */\n    var DateTimeFormat;\n    (function (DateTimeFormat) {\n        var _currentCachedFormat;\n        var _currentCachedProcessedFormat;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = value instanceof Date;\n            return result;\n        }\n        DateTimeFormat.canFormat = canFormat;\n        /** Formats the date using provided format and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            var isStandard = format.length === 1;\n            try {\n                if (isStandard) {\n                    return formatDateStandard(value, format, culture);\n                }\n                else {\n                    return formatDateCustom(value, format, culture);\n                }\n            }\n            catch (e) {\n                return formatDateStandard(value, \"G\", culture);\n            }\n        }\n        DateTimeFormat.format = format;\n        /** Formats the date using standard format expression */\n        function formatDateStandard(value, format, culture) {\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\n            var patterns = culture.calendar.patterns;\n            // Extend supported set of patterns\n            ensurePatterns(culture.calendar);\n            // Handle extended set of formats\n            var output = Formatting.findDateFormat(value, format, culture.name);\n            if (output.format.length === 1)\n                format = patterns[output.format];\n            else\n                format = output.format;\n            //need to revisit when globalization is enabled\n            culture = Globalize.culture(\"en-US\");\n            return Globalize.format(output.value, format, culture);\n        }\n        /** Formats the date using custom format expression */\n        function formatDateCustom(value, format, culture) {\n            var result;\n            var literals = [];\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            format = FormattingEncoder.preserveLiterals(format, literals);\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            if (format.indexOf(\"F\") > -1) {\n                // F is not supported so we need to replace the F with f based on the milliseconds\n                // Replace all sequences of F longer than 3 with \"FFF\"\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\n                // Based on milliseconds update the format to use fff\n                var milliseconds = value.getMilliseconds();\n                if (milliseconds % 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\n                if ((milliseconds % 100) / 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\n                if ((milliseconds % 1000) / 100 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\n                }\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\n                if (format === \"\" || format === \"%\")\n                    return \"\";\n            }\n            format = processCustomDateTimeFormat(format);\n            result = Globalize.format(value, format, culture);\n            result = localize(result, culture.calendar);\n            result = FormattingEncoder.restoreLiterals(result, literals);\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            return result;\n        }\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\n        function processCustomDateTimeFormat(format) {\n            if (format === _currentCachedFormat) {\n                return _currentCachedProcessedFormat;\n            }\n            _currentCachedFormat = format;\n            format = Formatting.fixDateTimeFormat(format);\n            _currentCachedProcessedFormat = format;\n            return format;\n        }\n        /** Localizes the time separator symbol */\n        function localize(value, dictionary) {\n            var timeSeparator = dictionary[\":\"];\n            if (timeSeparator === \":\") {\n                return value;\n            }\n            var result = \"\";\n            var count = value.length;\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \":\":\n                        result += timeSeparator;\n                        break;\n                    default:\n                        result += char;\n                        break;\n                }\n            }\n            return result;\n        }\n        function ensurePatterns(calendar) {\n            var patterns = calendar.patterns;\n            if (patterns[\"g\"] === undefined) {\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, short time\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, long time\n            }\n        }\n    })(DateTimeFormat || (DateTimeFormat = {}));\n    /**\n     * NumberFormat module contains the static methods for formatting the numbers.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for numeric types including custom formats.\n     */\n    var NumberFormat;\n    (function (NumberFormat) {\n        var NonScientificFormatRegex = /^\\{.+\\}.*/;\n        var NumericalPlaceHolderRegex = /\\{.+\\}/;\n        var ScientificFormatRegex = /e[+-]*[0#]+/i;\n        var StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\n        var TrailingZerosRegex = /0+$/;\n        var DecimalFormatRegex = /\\.([0#]*)/g;\n        var NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\n        var LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\n        var DecimalFormatCharacter = '.';\n        NumberFormat.NumberFormatComponentsDelimeter = ';';\n        function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {\n            if (!numericFormat || baseFormat === undefined)\n                return baseFormat;\n            var newFormat = \"{0:\" + numericFormat + \"}\";\n            return baseFormat.replace(\"{0}\", newFormat);\n        }\n        function getNumericFormat(value, baseFormat) {\n            if (baseFormat == null)\n                return baseFormat;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                if (value > 0)\n                    return getNumericFormatFromComponent(value, positive);\n                else if (value === 0)\n                    return getNumericFormatFromComponent(value, zero);\n                return getNumericFormatFromComponent(value, negative);\n            }\n            return getNumericFormatFromComponent(value, baseFormat);\n        }\n        NumberFormat.getNumericFormat = getNumericFormat;\n        function getNumericFormatFromComponent(value, format) {\n            var match = RegExpExtensions.run(NumericFormatRegex, format);\n            if (match)\n                return match[0];\n            return format;\n        }\n        function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {\n            if (decimals == null)\n                return baseFormat;\n            // Default format string\n            if (baseFormat == null)\n                baseFormat = ZeroPlaceholder;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                var formats = [positive, negative, zero];\n                for (var i = 0; i < formats.length; i++) {\n                    // Update format in formats array\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\n                }\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\n            }\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\n        }\n        NumberFormat.addDecimalsToFormat = addDecimalsToFormat;\n        function addDecimalsToFormatComponent(format, decimals, trailingZeros) {\n            decimals = Math.abs(decimals);\n            if (decimals >= 0) {\n                var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\n                var decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\n                var match = RegExpExtensions.run(DecimalFormatRegex, format);\n                if (match) {\n                    var beforeDecimal = format.substr(0, match.index);\n                    var formatDecimal = format.substr(match.index + 1, match[1].length);\n                    var afterDecimal = format.substr(match.index + match[0].length);\n                    if (trailingZeros)\n                        // Use explicit decimals argument as placeholders\n                        formatDecimal = decimalPlaceholders;\n                    else {\n                        var decimalChange = decimalPlaceholders.length - formatDecimal.length;\n                        if (decimalChange > 0)\n                            // Append decimalPlaceholders to existing decimal portion of format string\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\n                        else if (decimalChange < 0)\n                            // Remove decimals from formatDecimal\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\n                    }\n                    if (formatDecimal.length > 0)\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\n                    return beforeDecimal + formatDecimal + afterDecimal;\n                }\n                else if (decimalPlaceholders.length > 0)\n                    // Replace last numeric placeholder with decimal portion\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\n            }\n            return format;\n        }\n        function hasFormatComponents(format) {\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\n        }\n        NumberFormat.hasFormatComponents = hasFormatComponents;\n        function getComponents(format) {\n            var signFormat = {\n                hasNegative: false,\n                positive: format,\n                negative: format,\n                zero: format,\n            };\n            var signSpecificFormats = format.split(NumberFormat.NumberFormatComponentsDelimeter);\n            var formatCount = signSpecificFormats.length;\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\n            if (formatCount > 1) {\n                signFormat.hasNegative = true;\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\n                signFormat.negative = signSpecificFormats[1];\n                if (formatCount > 2)\n                    signFormat.zero = signSpecificFormats[2];\n            }\n            return signFormat;\n        }\n        NumberFormat.getComponents = getComponents;\n        var _lastCustomFormatMeta;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = typeof (value) === \"number\";\n            return result;\n        }\n        NumberFormat.canFormat = canFormat;\n        function isStandardFormat(format) {\n            debug.assertValue(format, 'format');\n            return StandardFormatRegex.test(format);\n        }\n        NumberFormat.isStandardFormat = isStandardFormat;\n        /** Formats the number using specified format expression and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            try {\n                if (isStandardFormat(format))\n                    return formatNumberStandard(value, format, culture);\n                return formatNumberCustom(value, format, culture);\n            }\n            catch (e) {\n                return Globalize.format(value, undefined, culture);\n            }\n        }\n        NumberFormat.format = format;\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\n        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {\n            debug.assertValue(value, 'value');\n            debug.assertValue(format, 'format');\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\n            debug.assertValue(culture, 'culture');\n            debug.assert(!isStandardFormat(format), 'Standard format');\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\n        }\n        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;\n        /** Formats the number using standard format expression */\n        function formatNumberStandard(value, format, culture) {\n            var result;\n            var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\n            var numberFormatInfo = culture.numberFormat;\n            var formatChar = format.charAt(0);\n            switch (formatChar) {\n                case \"e\":\n                case \"E\":\n                    if (precision === undefined) {\n                        precision = 6;\n                    }\n                    var mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\n                    result = formatNumberCustom(value, format, culture);\n                    break;\n                case \"f\":\n                case \"F\":\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"g\":\n                case \"G\":\n                    var abs = Math.abs(value);\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\n                    }\n                    else {\n                        // Otherwise use exponential\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\n                        result = result.replace(\"e\", \"E\");\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"r\":\n                case \"R\":\n                    result = value.toString();\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"x\":\n                case \"X\":\n                    result = value.toString(16);\n                    if (formatChar === \"X\") {\n                        result = result.toUpperCase();\n                    }\n                    if (precision !== undefined) {\n                        var actualPrecision = result.length;\n                        var isNegative = value < 0;\n                        if (isNegative) {\n                            actualPrecision--;\n                        }\n                        var paddingZerosCount = precision - actualPrecision;\n                        var paddingZeros = undefined;\n                        if (paddingZerosCount > 0) {\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\n                        }\n                        if (isNegative) {\n                            result = \"-\" + paddingZeros + result.substr(1);\n                        }\n                        else {\n                            result = paddingZeros + result;\n                        }\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                default:\n                    result = Globalize.format(value, format, culture);\n            }\n            return result;\n        }\n        /** Formats the number using custom format expression */\n        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {\n            var result;\n            var numberFormatInfo = culture.numberFormat;\n            if (isFinite(value)) {\n                // Split format by positive[;negative;zero] pattern\n                var formatComponents = getComponents(format);\n                // Pick a format based on the sign of value\n                if (value > 0) {\n                    format = formatComponents.positive;\n                }\n                else if (value === 0) {\n                    format = formatComponents.zero;\n                }\n                else {\n                    format = formatComponents.negative;\n                }\n                // Normalize value if we have an explicit negative format\n                if (formatComponents.hasNegative)\n                    value = Math.abs(value);\n                // Get format metadata\n                var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\n                // Preserve literals and escaped chars\n                if (formatMeta.hasEscapes) {\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%‰\");\n                }\n                var literals = [];\n                if (formatMeta.hasQuotes) {\n                    format = FormattingEncoder.preserveLiterals(format, literals);\n                }\n                // Scientific format\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\n                    var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\n                    if (scientificMatch) {\n                        // Case 2.1. Scientific custom format\n                        var formatM = format.substr(0, scientificMatch.index);\n                        var formatE = format.substr(scientificMatch.index + 2); // E(+|-)\n                        var precision = getCustomFormatPrecision(formatM, formatMeta);\n                        var scale = getCustomFormatScale(formatM, formatMeta);\n                        if (scale !== 1) {\n                            value = value * scale;\n                        }\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        var s = value.toExponential(precision);\n                        var indexOfE = s.indexOf(\"e\");\n                        var mantissa = s.substr(0, indexOfE);\n                        var exp = s.substr(indexOfE + 1);\n                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\n                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\n                            resultE = resultE.substr(1);\n                        }\n                        var e = scientificMatch[0].charAt(0);\n                        result = resultM + e + resultE;\n                    }\n                }\n                // Non scientific format\n                if (result === undefined) {\n                    var valueFormatted = void 0;\n                    var isValueGlobalized = false;\n                    var precision = getCustomFormatPrecision(format, formatMeta);\n                    var scale = getCustomFormatScale(format, formatMeta);\n                    if (scale !== 1)\n                        value = value * scale;\n                    // Rounding\n                    value = parseFloat(toNonScientific(value, precision));\n                    if (nonScientificOverrideFormat) {\n                        // Get numeric format from format string\n                        var numericFormat = NumberFormat.getNumericFormat(value, format);\n                        // Add separators and decimalFormat to nonScientificFormat\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\n                        // Format the value\n                        valueFormatted = powerbi_1.formattingService.format(nonScientificOverrideFormat, [value], culture.name);\n                        isValueGlobalized = true;\n                    }\n                    else\n                        valueFormatted = toNonScientific(value, precision);\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\n                }\n                if (formatMeta.hasQuotes) {\n                    result = FormattingEncoder.restoreLiterals(result, literals);\n                }\n                if (formatMeta.hasEscapes) {\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%‰\");\n                }\n                _lastCustomFormatMeta = formatMeta;\n            }\n            else {\n                return Globalize.format(value, undefined);\n            }\n            return result;\n        }\n        /** Returns string with the fixed point respresentation of the number */\n        function toNonScientific(value, precision) {\n            var result = \"\";\n            var precisionZeros = 0;\n            // Double precision numbers support actual 15-16 decimal digits of precision.\n            if (precision > 16) {\n                precisionZeros = precision - 16;\n                precision = 16;\n            }\n            var digitsBeforeDecimalPoint = powerbi_1.Double.log10(Math.abs(value));\n            if (digitsBeforeDecimalPoint < 16) {\n                if (digitsBeforeDecimalPoint > 0) {\n                    var maxPrecision = 16 - digitsBeforeDecimalPoint;\n                    if (precision > maxPrecision) {\n                        precisionZeros += precision - maxPrecision;\n                        precision = maxPrecision;\n                    }\n                }\n                result = value.toFixed(precision);\n            }\n            else if (digitsBeforeDecimalPoint === 16) {\n                result = value.toFixed(0);\n                precisionZeros += precision;\n                if (precisionZeros > 0) {\n                    result += \".\";\n                }\n            }\n            else {\n                // Different browsers have different implementations of the toFixed().\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\n                // So we need to check for range and convert the to exponential with the max precision.\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\n                // Assert that value is a number and fall back on returning value if it is not\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                if (typeof (value) !== \"number\")\n                    return String(value);\n                result = value.toExponential(15);\n                var indexOfE = result.indexOf(\"e\");\n                if (indexOfE > 0) {\n                    var indexOfDot = result.indexOf(\".\");\n                    var mantissa = result.substr(0, indexOfE);\n                    var exp = result.substr(indexOfE + 1);\n                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\n                    if (precision > 0) {\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\n                    }\n                }\n            }\n            if (precisionZeros > 0) {\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\n            }\n            return result;\n        }\n        /**\n         * Returns the formatMetadata of the format\n         * When calculating precision and scale, if format string of\n         * positive[;negative;zero] => positive format will be used\n         * @param (required) format - format string\n         * @param (optional) calculatePrecision - calculate precision of positive format\n         * @param (optional) calculateScale - calculate scale of positive format\n         */\n        function getCustomFormatMetadata(format, calculatePrecision, calculateScale) {\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\n                return _lastCustomFormatMeta;\n            }\n            var result = {\n                format: format,\n                hasEscapes: false,\n                hasQuotes: false,\n                hasE: false,\n                hasCommas: false,\n                hasDots: false,\n                hasPercent: false,\n                hasPermile: false,\n                precision: undefined,\n                scale: undefined,\n            };\n            for (var i = 0, length_1 = format.length; i < length_1; i++) {\n                var c = format.charAt(i);\n                switch (c) {\n                    case \"\\\\\":\n                        result.hasEscapes = true;\n                        break;\n                    case \"'\":\n                    case \"\\\"\":\n                        result.hasQuotes = true;\n                        break;\n                    case \"e\":\n                    case \"E\":\n                        result.hasE = true;\n                        break;\n                    case \",\":\n                        result.hasCommas = true;\n                        break;\n                    case \".\":\n                        result.hasDots = true;\n                        break;\n                    case \"%\":\n                        result.hasPercent = true;\n                        break;\n                    case \"‰\":\n                        result.hasPermile = true;\n                        break;\n                }\n            }\n            // Use positive format for calculating these values\n            var formatComponents = getComponents(format);\n            if (calculatePrecision)\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\n            if (calculateScale)\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\n            return result;\n        }\n        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\n        function getCustomFormatPrecision(format, formatMeta) {\n            if (formatMeta.precision > -1) {\n                return formatMeta.precision;\n            }\n            var result = 0;\n            if (formatMeta.hasDots) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex > -1) {\n                    var count = format.length;\n                    for (var i = dotIndex; i < count; i++) {\n                        var char = format.charAt(i);\n                        if (char.match(NumericPlaceholderRegex))\n                            result++;\n                        // 0.00E+0 :: Break before counting 0 in\n                        // exponential portion of format string\n                        if (char === ExponentialFormatChar)\n                            break;\n                    }\n                    result = Math.min(19, result);\n                }\n            }\n            formatMeta.precision = result;\n            return result;\n        }\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\n        function getCustomFormatScale(format, formatMeta) {\n            if (formatMeta.scale > -1) {\n                return formatMeta.scale;\n            }\n            var result = 1;\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\n                result = result * 100;\n            }\n            if (formatMeta.hasPermile && format.indexOf(\"‰\") > -1) {\n                result = result * 1000;\n            }\n            if (formatMeta.hasCommas) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex === -1) {\n                    dotIndex = format.length;\n                }\n                for (var i = dotIndex - 1; i > -1; i--) {\n                    var char = format.charAt(i);\n                    if (char === \",\") {\n                        result = result / 1000;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            formatMeta.scale = result;\n            return result;\n        }\n        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {\n            var suppressModifyValue = !!nonScientificOverrideFormat;\n            var formatParts = format.split(\".\", 2);\n            if (formatParts.length === 2) {\n                var wholeFormat = formatParts[0];\n                var fractionFormat = formatParts[1];\n                var displayUnit = \"\";\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\n                if (nonScientificOverrideFormat) {\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\n                    value = value.replace(displayUnit, \"\");\n                }\n                var globalizedDecimalSeparator = numberFormatInfo[\".\"];\n                var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\n                var valueParts = value.split(decimalSeparator, 2);\n                var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\n                var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\n                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\n                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\n                    return wholeFormattedValue + fractionFormattedValue.value;\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\n            }\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\n        }\n        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {\n            var groupSymbolIndex = format.indexOf(\",\");\n            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\n            var groupDigitCount = 0;\n            var groupIndex = 0;\n            var groupSizes = numberFormatInfo.groupSizes || [3];\n            var groupSize = groupSizes[0];\n            var groupSeparator = numberFormatInfo[\",\"];\n            var sign = \"\";\n            var firstChar = value.charAt(0);\n            if (firstChar === \"+\" || firstChar === \"-\") {\n                sign = numberFormatInfo[firstChar];\n                value = value.substr(1);\n            }\n            var isZero = value === \"0\";\n            var result = \"\";\n            var leftBuffer = \"\";\n            var vi = value.length - 1;\n            var fmtOnly = true;\n            // Iterate through format chars and replace 0 and # with the digits from the value string\n            for (var fi = format.length - 1; fi > -1; fi--) {\n                var formatChar = format.charAt(fi);\n                switch (formatChar) {\n                    case ZeroPlaceholder:\n                    case DigitPlaceholder:\n                        fmtOnly = false;\n                        if (leftBuffer !== \"\") {\n                            result = leftBuffer + result;\n                            leftBuffer = \"\";\n                        }\n                        if (!suppressModifyValue) {\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\n                                if (enableGroups) {\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\n                                    if (groupDigitCount === groupSize) {\n                                        result = groupSeparator + result;\n                                        groupIndex++;\n                                        if (groupIndex < groupSizes.length) {\n                                            groupSize = groupSizes[groupIndex];\n                                        }\n                                        groupDigitCount = 1;\n                                    }\n                                    else {\n                                        groupDigitCount++;\n                                    }\n                                }\n                            }\n                            if (vi > -1) {\n                                if (isZero && formatChar === DigitPlaceholder) {\n                                }\n                                else {\n                                    result = value.charAt(vi) + result;\n                                }\n                                vi--;\n                            }\n                            else if (formatChar !== DigitPlaceholder) {\n                                result = formatChar + result;\n                            }\n                        }\n                        break;\n                    case \",\":\n                        // We should skip all the , chars\n                        break;\n                    default:\n                        leftBuffer = formatChar + leftBuffer;\n                        break;\n                }\n            }\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\n            if (!suppressModifyValue) {\n                if (vi > -1 && result !== \"\") {\n                    if (enableGroups) {\n                        while (vi > -1) {\n                            if (groupDigitCount === groupSize) {\n                                result = groupSeparator + result;\n                                groupIndex++;\n                                if (groupIndex < groupSizes.length) {\n                                    groupSize = groupSizes[groupIndex];\n                                }\n                                groupDigitCount = 1;\n                            }\n                            else {\n                                groupDigitCount++;\n                            }\n                            result = value.charAt(vi) + result;\n                            vi--;\n                        }\n                    }\n                    else {\n                        result = value.substr(0, vi + 1) + result;\n                    }\n                }\n                // Insert sign in front of the leftBuffer and result\n                return sign + leftBuffer + result;\n            }\n            if (fmtOnly)\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\n                return sign + leftBuffer + result;\n            return sign + leftBuffer + value + result;\n        }\n        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {\n            var vi = 0;\n            var fCount = format.length;\n            var vCount = value.length;\n            if (suppressModifyValue) {\n                debug.assert(fCount > 0, \"Empty formatting string\");\n                var lastChar = format.charAt(fCount - 1);\n                if (!lastChar.match(NumericPlaceholderRegex))\n                    return {\n                        value: value + lastChar,\n                        fmtOnly: value === \"\",\n                    };\n                return {\n                    value: value,\n                    fmtOnly: value === \"\",\n                };\n            }\n            var result = \"\", fmtOnly = true;\n            for (var fi = 0; fi < fCount; fi++) {\n                var formatChar = format.charAt(fi);\n                if (vi < vCount) {\n                    switch (formatChar) {\n                        case ZeroPlaceholder:\n                        case DigitPlaceholder:\n                            result += value[vi++];\n                            fmtOnly = false;\n                            break;\n                        default:\n                            result += formatChar;\n                    }\n                }\n                else {\n                    if (formatChar !== DigitPlaceholder) {\n                        result += formatChar;\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\n                    }\n                }\n            }\n            return {\n                value: result,\n                fmtOnly: fmtOnly,\n            };\n        }\n        function localize(value, dictionary) {\n            var plus = dictionary[\"+\"];\n            var minus = dictionary[\"-\"];\n            var dot = dictionary[\".\"];\n            var comma = dictionary[\",\"];\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\n                return value;\n            }\n            var count = value.length;\n            var result = \"\";\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \"+\":\n                        result = result + plus;\n                        break;\n                    case \"-\":\n                        result = result + minus;\n                        break;\n                    case \".\":\n                        result = result + dot;\n                        break;\n                    case \",\":\n                        result = result + comma;\n                        break;\n                    default:\n                        result = result + char;\n                        break;\n                }\n            }\n            return result;\n        }\n    })(NumberFormat = powerbi_1.NumberFormat || (powerbi_1.NumberFormat = {}));\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\n    var DateTimeScaleFormatInfo = (function () {\n        // Constructor\n        /**\n         * Creates new instance of the DateTimeScaleFormatInfo class.\n         * @param culture - culture which calendar info is going to be used to derive the formats.\n         */\n        function DateTimeScaleFormatInfo(culture) {\n            var calendar = culture.calendar;\n            var patterns = calendar.patterns;\n            var monthAbbreviations = calendar[\"months\"][\"namesAbbr\"];\n            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];\n            var yearMonthPattern = patterns[\"Y\"];\n            var monthDayPattern = patterns[\"M\"];\n            var fullPattern = patterns[\"f\"];\n            var longTimePattern = patterns[\"T\"];\n            var shortTimePattern = patterns[\"t\"];\n            var separator = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\n            var hasYearSymbol = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\n            var yearPos = fullPattern.indexOf(\"yy\");\n            var monthPos = fullPattern.indexOf(\"MMMM\");\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\n            var minutePos = fullPattern.indexOf(\"mm\");\n            var pmPos = fullPattern.indexOf(\"tt\");\n            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\n            this.MinutePattern = shortTimePattern;\n            this.SecondPattern = longTimePattern;\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\n            // Special cases\n            switch (culture.name) {\n                case \"fi-FI\":\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\n                    break;\n            }\n        }\n        // Methods\n        /**\n         * Returns the format string of the provided DateTimeUnit.\n         * @param unit - date or time unit\n         */\n        DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {\n            switch (unit) {\n                case powerbi_1.DateTimeUnit.Year:\n                    return this.YearPattern;\n                case powerbi_1.DateTimeUnit.Month:\n                    return this.MonthPattern;\n                case powerbi_1.DateTimeUnit.Week:\n                case powerbi_1.DateTimeUnit.Day:\n                    return this.DayPattern;\n                case powerbi_1.DateTimeUnit.Hour:\n                    return this.HourPattern;\n                case powerbi_1.DateTimeUnit.Minute:\n                    return this.MinutePattern;\n                case powerbi_1.DateTimeUnit.Second:\n                    return this.SecondPattern;\n                case powerbi_1.DateTimeUnit.Millisecond:\n                    return this.MillisecondPattern;\n            }\n            debug.assertFail('Unexpected unit: ' + unit);\n        };\n        return DateTimeScaleFormatInfo;\n    }());\n    powerbi_1.formattingService = new FormattingService();\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\n        var SQExprShortSerializer;\n        (function (SQExprShortSerializer) {\n            function serialize(expr) {\n                return JSON.stringify(expr.accept(SQExprSerializer.instance));\n            }\n            SQExprShortSerializer.serialize = serialize;\n            function serializeArray(exprs) {\n                var str = '[';\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    if (i > 0)\n                        str += ',';\n                    str += SQExprShortSerializer.serialize(exprs[i]);\n                }\n                return str + ']';\n            }\n            SQExprShortSerializer.serializeArray = serializeArray;\n            /** Responsible for serializing an SQExpr into a comparable string. */\n            var SQExprSerializer = (function (_super) {\n                __extends(SQExprSerializer, _super);\n                function SQExprSerializer() {\n                    _super.apply(this, arguments);\n                }\n                SQExprSerializer.prototype.visitColumnRef = function (expr) {\n                    return {\n                        col: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitMeasureRef = function (expr) {\n                    return {\n                        measure: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitAggr = function (expr) {\n                    return {\n                        agg: {\n                            a: expr.arg.accept(this),\n                            f: expr.func,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitEntity = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    debug.assertValue(expr.entity, 'expr.entity');\n                    return {\n                        e: expr.entity\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchyLevel = function (expr) {\n                    return {\n                        h: expr.arg.accept(this),\n                        l: expr.level,\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchy = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        h: expr.hierarchy,\n                    };\n                };\n                SQExprSerializer.prototype.visitPropertyVariationSource = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        n: expr.name,\n                        p: expr.property,\n                    };\n                };\n                SQExprSerializer.prototype.visitAnd = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        and: {\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitCompare = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        comp: {\n                            k: expr.comparison,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitConstant = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        const: {\n                            t: expr.type.primitiveType,\n                            v: expr.value,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitArithmetic = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        arithmetic: {\n                            o: expr.operator,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitScopedEval = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        scopedEval: {\n                            e: expr.expression.accept(this),\n                            s: serializeArray(expr.scope)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitWithRef = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        withRef: {\n                            e: expr.expressionName\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitDefault = function (expr) {\n                    debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\n                    return;\n                };\n                SQExprSerializer.instance = new SQExprSerializer();\n                return SQExprSerializer;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var Selector = powerbi.data.Selector;\n        /**\n         * A combination of identifiers used to uniquely identify\n         * data points and their bound geometry.\n         */\n        var SelectionId = (function () {\n            function SelectionId(selector, highlight) {\n                this.selector = selector;\n                this.highlight = highlight;\n                this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\n                this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\n            }\n            SelectionId.prototype.equals = function (other) {\n                if (!this.selector || !other.selector) {\n                    return (!this.selector === !other.selector) && this.highlight === other.highlight;\n                }\n                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);\n            };\n            /**\n             * Checks equality against other for all identifiers existing in this.\n             */\n            SelectionId.prototype.includes = function (other, ignoreHighlight) {\n                if (ignoreHighlight === void 0) { ignoreHighlight = false; }\n                var thisSelector = this.selector;\n                var otherSelector = other.selector;\n                if (!thisSelector || !otherSelector) {\n                    return false;\n                }\n                var thisData = thisSelector.data;\n                var otherData = otherSelector.data;\n                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\n                    return false;\n                if (!ignoreHighlight && this.highlight !== other.highlight)\n                    return false;\n                if (thisData) {\n                    if (!otherData)\n                        return false;\n                    if (thisData.length > 0) {\n                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {\n                            var thisValue = thisData[i];\n                            if (!otherData.some(function (otherValue) { return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue); }))\n                                return false;\n                        }\n                    }\n                }\n                return true;\n            };\n            SelectionId.prototype.getKey = function () {\n                return this.key;\n            };\n            SelectionId.prototype.getKeyWithoutHighlight = function () {\n                return this.keyWithoutHighlight;\n            };\n            SelectionId.prototype.hasIdentity = function () {\n                return (this.selector && !!this.selector.data);\n            };\n            SelectionId.prototype.getSelector = function () {\n                return this.selector;\n            };\n            SelectionId.prototype.getSelectorsByColumn = function () {\n                return this.selectorsByColumn;\n            };\n            SelectionId.createNull = function (highlight) {\n                if (highlight === void 0) { highlight = false; }\n                return new SelectionId(null, highlight);\n            };\n            SelectionId.createWithId = function (id, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                if (id) {\n                    selector = {\n                        data: [id]\n                    };\n                }\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithMeasure = function (measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                debug.assertValue(measureId, 'measureId');\n                var selector = {\n                    metadata: measureId\n                };\n                var selectionId = new SelectionId(selector, highlight);\n                selectionId.selectorsByColumn = { metadata: measureId };\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasure = function (id, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                if (id) {\n                    selector.data = [id];\n                }\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id && !measureId)\n                    selector = null;\n                var selectionId = new SelectionId(selector, highlight);\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasureAndCategory = function (id, measureId, queryName, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\n                if (selectionId.selector) {\n                    selectionId.selectorsByColumn = {};\n                    if (id && queryName) {\n                        selectionId.selectorsByColumn.dataMap = {};\n                        selectionId.selectorsByColumn.dataMap[queryName] = id;\n                    }\n                    if (measureId)\n                        selectionId.selectorsByColumn.metadata = measureId;\n                }\n                return selectionId;\n            };\n            SelectionId.createWithIds = function (id1, id2, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector = { data: selectorData };\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithIdsAndMeasure = function (id1, id2, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector.data = selectorData;\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id1 && !id2 && !measureId)\n                    selector = null;\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithSelectorForColumnAndMeasure = function (dataMap, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId;\n                var keys = Object.keys(dataMap);\n                if (keys.length === 2) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], dataMap[keys[1]], measureId, highlight);\n                }\n                else if (keys.length === 1) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], null, measureId, highlight);\n                }\n                else {\n                    selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\n                }\n                var selectorsByColumn = {};\n                if (!_.isEmpty(dataMap))\n                    selectorsByColumn.dataMap = dataMap;\n                if (measureId)\n                    selectorsByColumn.metadata = measureId;\n                if (!dataMap && !measureId)\n                    selectorsByColumn = null;\n                selectionId.selectorsByColumn = selectorsByColumn;\n                return selectionId;\n            };\n            SelectionId.createWithHighlight = function (original) {\n                debug.assertValue(original, 'original');\n                debug.assert(!original.highlight, '!original.highlight');\n                var newId = new SelectionId(original.getSelector(), /*highlight*/ true);\n                newId.selectorsByColumn = original.selectorsByColumn;\n                return newId;\n            };\n            SelectionId.idArray = function (id1, id2) {\n                if (id1 || id2) {\n                    var data_4 = [];\n                    if (id1)\n                        data_4.push(id1);\n                    if (id2 && id2 !== id1)\n                        data_4.push(id2);\n                    return data_4;\n                }\n            };\n            return SelectionId;\n        }());\n        visuals.SelectionId = SelectionId;\n        /**\n         * This class is designed to simplify the creation of SelectionId objects\n         * It allows chaining to build up an object before calling 'create' to build a SelectionId\n         */\n        var SelectionIdBuilder = (function () {\n            function SelectionIdBuilder() {\n            }\n            SelectionIdBuilder.builder = function () {\n                return new SelectionIdBuilder();\n            };\n            SelectionIdBuilder.prototype.withCategory = function (categoryColumn, index) {\n                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\n                    this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\n                return this;\n            };\n            SelectionIdBuilder.prototype.withSeries = function (seriesColumn, valueColumn) {\n                if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\n                    this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\n                return this;\n            };\n            SelectionIdBuilder.prototype.withMeasure = function (measureId) {\n                this.measure = measureId;\n                return this;\n            };\n            SelectionIdBuilder.prototype.createSelectionId = function () {\n                return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\n            };\n            SelectionIdBuilder.prototype.ensureDataMap = function () {\n                if (!this.dataMap)\n                    this.dataMap = {};\n                return this.dataMap;\n            };\n            return SelectionIdBuilder;\n        }());\n        visuals.SelectionIdBuilder = SelectionIdBuilder;\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n\n\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Allows generic traversal and type discovery for a SQExpr tree. */\r\n    export interface ISQExprVisitorWithArg<T, TArg> {\r\n        visitEntity(expr: SQEntityExpr, arg: TArg): T;\r\n        visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T;\r\n        visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T;\r\n        visitAggr(expr: SQAggregationExpr, arg: TArg): T;\r\n        visitPercentile(expr: SQPercentileExpr, arg: TArg): T;\r\n        visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T;\r\n        visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T;\r\n        visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T;\r\n        visitSelectRef(expr: SQSelectRefExpr, arg: TArg): T;\r\n        visitAnd(expr: SQAndExpr, arg: TArg): T;\r\n        visitBetween(expr: SQBetweenExpr, arg: TArg): T;\r\n        visitIn(expr: SQInExpr, arg: TArg): T;\r\n        visitOr(expr: SQOrExpr, arg: TArg): T;\r\n        visitCompare(expr: SQCompareExpr, arg: TArg): T;\r\n        visitContains(expr: SQContainsExpr, arg: TArg): T;\r\n        visitExists(expr: SQExistsExpr, arg: TArg): T;\r\n        visitNot(expr: SQNotExpr, arg: TArg): T;\r\n        visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T;\r\n        visitConstant(expr: SQConstantExpr, arg: TArg): T;\r\n        visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T;\r\n        visitDateAdd(expr: SQDateAddExpr, arg: TArg): T;\r\n        visitNow(expr: SQNowExpr, arg: TArg): T;\r\n        visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T;\r\n        visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T;\r\n        visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T;\r\n        visitFillRule(expr: SQFillRuleExpr, arg: TArg): T;\r\n        visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T;\r\n        visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T;\r\n        visitWithRef(expr: SQWithRefExpr, arg: TArg): T;\r\n    }\r\n\r\n    export interface ISQExprVisitor<T> extends ISQExprVisitorWithArg<T, void> {\r\n    }\r\n\r\n    /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\r\n    export class DefaultSQExprVisitorWithArg<T, TArg> implements ISQExprVisitorWithArg<T, TArg> {\r\n        public visitEntity(expr: SQEntityExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n        \r\n        public visitWithRef(expr: SQWithRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr, arg: TArg): T {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that others may derive from. */\r\n    export class DefaultSQExprVisitor<T> extends DefaultSQExprVisitorWithArg<T, void> implements ISQExprVisitor<T> {\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\r\n    export class DefaultSQExprVisitorWithTraversal implements ISQExprVisitor<void>, IFillRuleDefinitionVisitor<void, void> {\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): void {\r\n            expr.arg.accept(this);\r\n        } \r\n\r\n        public visitPercentile(expr: SQPercentileExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr): void {\r\n            expr.arg.accept(this);\r\n            expr.lower.accept(this);\r\n            expr.upper.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): void {\r\n            let args = expr.args;\r\n            for (let i = 0, len = args.length; i < len; i++)\r\n                args[i].accept(this);\r\n\r\n            let values = expr.values;\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueTuple = values[i];\r\n                for (let j = 0, jlen = valueTuple.length; j < jlen; j++)\r\n                    valueTuple[j].accept(this);\r\n            }\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr): void {\r\n            expr.input.accept(this);\r\n\r\n            let rule = expr.rule,\r\n                gradient2 = rule.linearGradient2,\r\n                gradient3 = rule.linearGradient3;\r\n\r\n            if (gradient2) {\r\n                this.visitLinearGradient2(gradient2);\r\n            }\r\n\r\n            if (gradient3) {\r\n                this.visitLinearGradient3(gradient3);\r\n            }\r\n        }\r\n\r\n        public visitLinearGradient2(gradient2: LinearGradient2Definition): void {\r\n            debug.assertValue(gradient2, 'gradient2');\r\n\r\n            this.visitFillRuleStop(gradient2.min);\r\n            this.visitFillRuleStop(gradient2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(gradient3: LinearGradient3Definition): void {\r\n            debug.assertValue(gradient3, 'gradient3');\r\n\r\n            this.visitFillRuleStop(gradient3.min);\r\n            this.visitFillRuleStop(gradient3.mid);\r\n            this.visitFillRuleStop(gradient3.max);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): void {\r\n            expr.expression.accept(this);\r\n\r\n            for (let scopeExpr of expr.scope) {\r\n                scopeExpr.accept(this);\r\n            }\r\n        }\r\n        \r\n        public visitWithRef(expr: SQWithRefExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): void {\r\n            return;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): void {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            stop.color.accept(this);\r\n\r\n            let value = stop.value;\r\n            if (value)\r\n                value.accept(this);\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Defines a custom enumeration data type, and its values. */\r\n    export interface IEnumType {\r\n        /** Gets the members of the enumeration, limited to the validMembers, if appropriate. */\r\n        members(validMembers?: EnumMemberValue[]): IEnumMember[];\r\n    }\r\n\r\n    export function createEnumType(members: IEnumMember[]): IEnumType {\r\n        return new EnumType(members);\r\n    }\r\n\r\n    class EnumType implements IEnumType {\r\n        private allMembers: IEnumMember[];\r\n\r\n        constructor(allMembers: IEnumMember[]) {\r\n            debug.assertValue(allMembers, 'allMembers');\r\n\r\n            this.allMembers = allMembers;\r\n        }\r\n\r\n        public members(validMembers?: EnumMemberValue[]): IEnumMember[] {\r\n            let allMembers = this.allMembers;\r\n            if (!validMembers)\r\n                return allMembers;\r\n\r\n            let membersToReturn: IEnumMember[] = [];\r\n            for (let member of allMembers) {\r\n                if (_.contains(validMembers, member.value))\r\n                    membersToReturn.push(member);\r\n            }\r\n            return membersToReturn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface FillDefinition {\r\n        solid?: {\r\n            color?: SQExpr;\r\n        };\r\n        gradient?: {\r\n            startColor?: SQExpr;\r\n            endColor?: SQExpr;\r\n        };\r\n        pattern?: {\r\n            patternKind?: SQExpr;\r\n            color?: SQExpr;\r\n        };\r\n    }\r\n\r\n    export module FillSolidColorTypeDescriptor {\r\n        /** Gets a value indicating whether the descriptor is nullable or not. */\r\n        export function nullable(descriptor: FillSolidColorTypeDescriptor): boolean {\r\n            debug.assertValue(descriptor, 'descriptor');\r\n\r\n            if (descriptor === true)\r\n                return false;\r\n\r\n            let advancedDescriptor = <FillSolidColorAdvancedTypeDescriptor>descriptor;\r\n            return !!advancedDescriptor.nullable;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ImageTypeDescriptor {\r\n    }\r\n\r\n    export type ImageDefinition = ImageDefinitionGeneric<SQExpr>;\r\n\r\n    export module ImageDefinition {\r\n        export const urlType: ValueTypeDescriptor = { misc: { imageUrl: true } };\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SemanticFilter = powerbi.data.SemanticFilter;\r\n\r\n    export type StructuralObjectDefinition =\r\n        FillDefinition |\r\n        FillRuleDefinition |\r\n        SemanticFilter |\r\n        DefaultValueDefinition |\r\n        ImageDefinition |\r\n        ParagraphsDefinition;\r\n\r\n    export module StructuralTypeDescriptor {\r\n        export function isValid(type: StructuralTypeDescriptor): boolean {\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (type.fill ||\r\n                type.fillRule ||\r\n                type.filter ||\r\n                type.expression ||\r\n                type.image ||\r\n                type.paragraphs) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n\r\n    export interface ValueTypeDescriptor {\r\n        extendedType?: ExtendedType;\r\n    }\r\n    \r\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\r\n    export class ValueType implements ValueTypeDescriptor {\r\n        private static typeCache: { [id: string]: ValueType } = {};\r\n\r\n        private underlyingType: ExtendedType;\r\n        private category: string;\r\n\r\n        private temporalType: TemporalType;\r\n        private geographyType: GeographyType;\r\n        private miscType: MiscellaneousType;\r\n        private formattingType: FormattingType;\r\n        private enumType: IEnumType;\r\n        private scriptingType: ScriptType;\r\n\r\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\r\n        constructor(type: ExtendedType, category?: string, enumType?: IEnumType) {\r\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\r\n            debug.assert(!!category || category === null, 'category');\r\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\r\n\r\n            this.underlyingType = type;\r\n            this.category = category;\r\n\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\r\n                this.temporalType = new TemporalType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\r\n                this.geographyType = new GeographyType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\r\n                this.miscType = new MiscellaneousType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\r\n                this.formattingType = new FormattingType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\r\n                this.enumType = enumType;\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\r\n                this.scriptingType = new ScriptType(type);\r\n            }\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\r\n        public static fromDescriptor(descriptor: ValueTypeDescriptor): ValueType {\r\n            descriptor = descriptor || {};\r\n\r\n            // Simplified primitive types\r\n            if (descriptor.text) return ValueType.fromExtendedType(ExtendedType.Text);\r\n            if (descriptor.integer) return ValueType.fromExtendedType(ExtendedType.Integer);\r\n            if (descriptor.numeric) return ValueType.fromExtendedType(ExtendedType.Double);\r\n            if (descriptor.bool) return ValueType.fromExtendedType(ExtendedType.Boolean);\r\n            if (descriptor.dateTime) return ValueType.fromExtendedType(ExtendedType.DateTime);\r\n            if (descriptor.duration) return ValueType.fromExtendedType(ExtendedType.Duration);\r\n            if (descriptor.binary) return ValueType.fromExtendedType(ExtendedType.Binary);\r\n            if (descriptor.none) return ValueType.fromExtendedType(ExtendedType.None);\r\n\r\n            // Extended types\r\n            if (descriptor.scripting) {\r\n                if (descriptor.scripting.source) return ValueType.fromExtendedType(ExtendedType.ScriptSource);\r\n            }\r\n            if (descriptor.enumeration) return ValueType.fromEnum(descriptor.enumeration);\r\n            if (descriptor.temporal) {\r\n                if (descriptor.temporal.year) return ValueType.fromExtendedType(ExtendedType.Year_Integer);\r\n                if (descriptor.temporal.month) return ValueType.fromExtendedType(ExtendedType.Month_Integer);\r\n            }\r\n            if (descriptor.geography) {\r\n                if (descriptor.geography.address) return ValueType.fromExtendedType(ExtendedType.Address);\r\n                if (descriptor.geography.city) return ValueType.fromExtendedType(ExtendedType.City);\r\n                if (descriptor.geography.continent) return ValueType.fromExtendedType(ExtendedType.Continent);\r\n                if (descriptor.geography.country) return ValueType.fromExtendedType(ExtendedType.Country);\r\n                if (descriptor.geography.county) return ValueType.fromExtendedType(ExtendedType.County);\r\n                if (descriptor.geography.region) return ValueType.fromExtendedType(ExtendedType.Region);\r\n                if (descriptor.geography.postalCode) return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\r\n                if (descriptor.geography.stateOrProvince) return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\r\n                if (descriptor.geography.place) return ValueType.fromExtendedType(ExtendedType.Place);\r\n                if (descriptor.geography.latitude) return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\r\n                if (descriptor.geography.longitude) return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\r\n            }\r\n            if (descriptor.misc) {\r\n                if (descriptor.misc.image) return ValueType.fromExtendedType(ExtendedType.Image);\r\n                if (descriptor.misc.imageUrl) return ValueType.fromExtendedType(ExtendedType.ImageUrl);\r\n                if (descriptor.misc.webUrl) return ValueType.fromExtendedType(ExtendedType.WebUrl);\r\n                if (descriptor.misc.barcode) return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\r\n            }\r\n            if (descriptor.formatting) {\r\n                if (descriptor.formatting.color) return ValueType.fromExtendedType(ExtendedType.Color);\r\n                if (descriptor.formatting.formatString) return ValueType.fromExtendedType(ExtendedType.FormatString);\r\n                if (descriptor.formatting.alignment) return ValueType.fromExtendedType(ExtendedType.Alignment);\r\n                if (descriptor.formatting.labelDisplayUnits) return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\r\n                if (descriptor.formatting.fontSize) return ValueType.fromExtendedType(ExtendedType.FontSize);\r\n                if (descriptor.formatting.labelDensity) return ValueType.fromExtendedType(ExtendedType.LabelDensity);\r\n            }\r\n            if (descriptor.extendedType) {\r\n                return ValueType.fromExtendedType(descriptor.extendedType);\r\n            }\r\n            if (descriptor.operations) {\r\n                if (descriptor.operations.searchEnabled) return ValueType.fromExtendedType(ExtendedType.SearchEnabled);\r\n            }\r\n\r\n            return ValueType.fromExtendedType(ExtendedType.Null);\r\n        }\r\n\r\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\r\n        public static fromExtendedType(extendedType: ExtendedType): ValueType {\r\n            extendedType = extendedType || ExtendedType.Null;\r\n\r\n            let primitiveType = getPrimitiveType(extendedType),\r\n                category = getCategoryFromExtendedType(extendedType);\r\n            debug.assert(\r\n                primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null,\r\n                'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\r\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\r\n        public static fromPrimitiveTypeAndCategory(primitiveType: PrimitiveType, category?: string): ValueType {\r\n            primitiveType = primitiveType || PrimitiveType.Null;\r\n            category = category || null;\r\n\r\n            let id = primitiveType.toString();\r\n            if (category)\r\n                id += '|' + category;\r\n\r\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\r\n        }\r\n\r\n        /** Creates a ValueType to describe the given IEnumType. */\r\n        public static fromEnum(enumType: IEnumType): ValueType {\r\n            debug.assertValue(enumType, 'enumType');\r\n\r\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\r\n        }\r\n\r\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\r\n        public static isCompatibleTo(type: ValueTypeDescriptor, otherTypes: ValueTypeDescriptor[]): boolean {\r\n            debug.assertValue(type, 'type');\r\n            debug.assertValue(otherTypes, 'otherTypes');\r\n\r\n            let valueType = ValueType.fromDescriptor(type);\r\n            for (let otherType of otherTypes) {\r\n                let otherValueType = ValueType.fromDescriptor(otherType);\r\n\r\n                if (otherValueType.isCompatibleFrom(valueType))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\r\n        public isCompatibleFrom(other: ValueType): boolean {\r\n            debug.assertValue(other, 'other');\r\n\r\n            let otherPrimitiveType = other.primitiveType;\r\n            if (this === other ||\r\n                this.primitiveType === otherPrimitiveType ||\r\n                otherPrimitiveType === PrimitiveType.Null)\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if the instance ValueType is equal to the 'other' ValueType\r\n         * @param {ValueType} other the other ValueType to check equality against\r\n         * @returns True if the instance ValueType is equal to the 'other' ValueType\r\n         */\r\n        public equals(other: ValueType): boolean {\r\n            return _.isEqual(this, other);\r\n        }\r\n\r\n        /** Gets the exact primitive type of this ValueType. */\r\n        public get primitiveType(): PrimitiveType {\r\n            return getPrimitiveType(this.underlyingType);\r\n        }\r\n\r\n        /** Gets the exact extended type of this ValueType. */\r\n        public get extendedType(): ExtendedType {\r\n            return this.underlyingType;\r\n        }\r\n\r\n        /** Gets the data category string (if any) for this ValueType. */\r\n        public get categoryString(): string {\r\n            return this.category;\r\n        }\r\n\r\n        // Simplified primitive types\r\n\r\n        /** Indicates whether the type represents text values. */\r\n        public get text(): boolean {\r\n            return this.primitiveType === PrimitiveType.Text;\r\n        }\r\n\r\n        /** Indicates whether the type represents any numeric value. */\r\n        public get numeric(): boolean {\r\n            return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\r\n        }\r\n\r\n        /** Indicates whether the type represents integer numeric values. */\r\n        public get integer(): boolean {\r\n            return this.primitiveType === PrimitiveType.Integer;\r\n        }\r\n\r\n        /** Indicates whether the type represents Boolean values. */\r\n        public get bool(): boolean {\r\n            return this.primitiveType === PrimitiveType.Boolean;\r\n        }\r\n\r\n        /** Indicates whether the type represents any date/time values. */\r\n        public get dateTime(): boolean {\r\n            return this.primitiveType === PrimitiveType.DateTime ||\r\n                this.primitiveType === PrimitiveType.Date ||\r\n                this.primitiveType === PrimitiveType.Time;\r\n        }\r\n\r\n        /** Indicates whether the type represents duration values. */\r\n        public get duration(): boolean {\r\n            return this.primitiveType === PrimitiveType.Duration;\r\n        }\r\n\r\n        /** Indicates whether the type represents binary values. */\r\n        public get binary(): boolean {\r\n            return this.primitiveType === PrimitiveType.Binary;\r\n        }\r\n\r\n        /** Indicates whether the type represents none values. */\r\n        public get none(): boolean {\r\n            return this.primitiveType === PrimitiveType.None;\r\n        }\r\n\r\n        // Extended types\r\n\r\n        /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\r\n        public get temporal(): TemporalType {\r\n            return this.temporalType;\r\n        }\r\n\r\n        /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\r\n        public get geography(): GeographyType {\r\n            return this.geographyType;\r\n        }\r\n\r\n        /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\r\n        public get misc(): MiscellaneousType {\r\n            return this.miscType;\r\n        }\r\n\r\n        /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\r\n        public get formatting(): FormattingType {\r\n            return this.formattingType;\r\n        }\r\n\r\n        /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\r\n        public get enum(): IEnumType {\r\n            return this.enumType;\r\n        }\r\n\r\n        public get scripting(): ScriptType {\r\n            return this.scriptingType;\r\n        }\r\n    }\r\n\r\n    export class ScriptType implements ScriptTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get source(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\r\n        }\r\n    }\r\n\r\n    export class TemporalType implements TemporalTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get year(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\r\n        }\r\n        public get month(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\r\n        }\r\n    }\r\n\r\n    export class GeographyType implements GeographyTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get address(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\r\n        }\r\n        public get city(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\r\n        }\r\n        public get continent(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\r\n        }\r\n        public get country(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\r\n        }\r\n        public get county(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\r\n        }\r\n        public get region(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\r\n        }\r\n        public get postalCode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\r\n        }\r\n        public get stateOrProvince(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\r\n        }\r\n        public get place(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\r\n        }\r\n        public get latitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\r\n        }\r\n        public get longitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\r\n        }\r\n    }\r\n\r\n    export class MiscellaneousType implements MiscellaneousTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get image(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\r\n        }\r\n        public get imageUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\r\n        }\r\n        public get webUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\r\n        }\r\n        public get barcode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\r\n        }\r\n    }\r\n\r\n    export class FormattingType implements FormattingTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get color(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\r\n        }\r\n\r\n        public get formatString(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\r\n        }\r\n\r\n        public get alignment(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\r\n        }\r\n\r\n        public get labelDisplayUnits(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\r\n        }\r\n\r\n        public get fontSize(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\r\n        }\r\n\r\n        public get labelDensity(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\r\n        }\r\n    }\r\n\r\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\r\n    export enum PrimitiveType {\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = 2,\r\n        Double = 3,\r\n        Integer = 4,\r\n        Boolean = 5,\r\n        Date = 6,\r\n        DateTime = 7,\r\n        DateTimeZone = 8,\r\n        Time = 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n    }\r\n\r\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\r\n    export enum ExtendedType {\r\n        // Flags (1 << 8-15 range [0xFF00])\r\n        // Important: Enum members must be declared before they are used in TypeScript.\r\n        Numeric = 1 << 8,\r\n        Temporal = 1 << 9,\r\n        Geography = 1 << 10,\r\n        Miscellaneous = 1 << 11,\r\n        Formatting = 1 << 12,\r\n        Scripting = 1 << 13,        \r\n\r\n        // Primitive types (0-255 range [0xFF] | flags)\r\n        // The member names and base values must match those in PrimitiveType.\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = Numeric | 2,\r\n        Double = Numeric | 3,\r\n        Integer = Numeric | 4,\r\n        Boolean = 5,\r\n        Date = Temporal | 6,\r\n        DateTime = Temporal | 7,\r\n        DateTimeZone = Temporal | 8,\r\n        Time = Temporal | 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n\r\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\r\n        // Temporal\r\n        Year = Temporal | (1 << 16),\r\n        Year_Text = Year | Text,\r\n        Year_Integer = Year | Integer,\r\n        Year_Date = Year | Date,\r\n        Year_DateTime = Year | DateTime,\r\n        Month = Temporal | (2 << 16),\r\n        Month_Text = Month | Text,\r\n        Month_Integer = Month | Integer,\r\n        Month_Date = Month | Date,\r\n        Month_DateTime = Month | DateTime,\r\n        // Geography\r\n        Address = Text | Geography | (100 << 16),\r\n        City = Text | Geography | (101 << 16),\r\n        Continent = Text | Geography | (102 << 16),\r\n        Country = Text | Geography | (103 << 16),\r\n        County = Text | Geography | (104 << 16),\r\n        Region = Text | Geography | (105 << 16),\r\n        PostalCode = Geography | (106 << 16),\r\n        PostalCode_Text = PostalCode | Text,\r\n        PostalCode_Integer = PostalCode | Integer,\r\n        StateOrProvince = Text | Geography | (107 << 16),\r\n        Place = Text | Geography | (108 << 16),\r\n        Latitude = Geography | (109 << 16),\r\n        Latitude_Decimal = Latitude | Decimal,\r\n        Latitude_Double = Latitude | Double,\r\n        Longitude = Geography | (110 << 16),\r\n        Longitude_Decimal = Longitude | Decimal,\r\n        Longitude_Double = Longitude | Double,\r\n        // Miscellaneous\r\n        Image = Binary | Miscellaneous | (200 << 16),\r\n        ImageUrl = Text | Miscellaneous | (201 << 16),\r\n        WebUrl = Text | Miscellaneous | (202 << 16),\r\n        Barcode =  Miscellaneous | (203 << 16),\r\n        Barcode_Text = Barcode | Text,\r\n        Barcode_Integer = Barcode | Integer,\r\n\r\n        // Formatting\r\n        Color = Text | Formatting | (300 << 16),\r\n        FormatString = Text | Formatting | (301 << 16),\r\n        Alignment = Text | Formatting | (306 << 16),\r\n        LabelDisplayUnits = Text | Formatting | (307 << 16),\r\n        FontSize = Double | Formatting | (308 << 16),\r\n        LabelDensity = Double | Formatting | (309 << 16),\r\n        // Enumeration\r\n        Enumeration = Text | 400 << 16,\r\n        // Scripting\r\n        ScriptSource = Text | Scripting | (500 << 16),        \r\n        // NOTE: To avoid confusion, underscores should be used only to delimit primitive type variants of an extended type\r\n        // (e.g. Year_Integer or Latitude_Double above)\r\n\r\n        //Operations\r\n        SearchEnabled = Boolean | (1 << 16),\r\n    }\r\n\r\n    const PrimitiveTypeMask = 0xFF;\r\n    const PrimitiveTypeWithFlagsMask = 0xFFFF;\r\n    const PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\r\n\r\n    function getPrimitiveType(extendedType: ExtendedType): PrimitiveType {\r\n        return extendedType & PrimitiveTypeMask;\r\n    }\r\n\r\n    function isPrimitiveType(extendedType: ExtendedType): boolean {\r\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\r\n    }\r\n\r\n    function getCategoryFromExtendedType(extendedType: ExtendedType): string {\r\n        if (isPrimitiveType(extendedType))\r\n            return null;\r\n\r\n        let category = ExtendedType[extendedType];\r\n        if (category) {\r\n            // Check for ExtendedType declaration without a primitive type.\r\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\r\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\r\n            let delimIdx = category.lastIndexOf('_');\r\n            if (delimIdx > 0) {\r\n                let baseCategory = category.slice(0, delimIdx);\r\n                if (ExtendedType[baseCategory]) {\r\n                    debug.assert(\r\n                        (ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask),\r\n                        'Unexpected value for ExtendedType base member of ' + extendedType);\r\n                    category = baseCategory;\r\n                }\r\n            }\r\n        }\r\n        return category || null;\r\n    }\r\n\r\n    function toExtendedType(primitiveType: PrimitiveType, category?: string): ExtendedType {\r\n        let primitiveString = PrimitiveType[primitiveType];\r\n        let t = ExtendedType[primitiveString];\r\n        if (t == null) {\r\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\r\n            t = ExtendedType.Null;\r\n        }\r\n\r\n        if (primitiveType && category) {\r\n            let categoryType: ExtendedType = ExtendedType[category];\r\n            if (categoryType) {\r\n                let categoryPrimitiveType = getPrimitiveType(categoryType);\r\n                if (categoryPrimitiveType === PrimitiveType.Null) {\r\n                    // Category supports multiple primitive types, check if requested primitive type is supported\r\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\r\n                    categoryType = t | categoryType;\r\n                    if (ExtendedType[categoryType]) {\r\n                        debug.assert(\r\n                            ExtendedType[categoryType] === (category + '_' + primitiveString),\r\n                            'Unexpected name for ExtendedType member ' + categoryType);\r\n                        t = categoryType;\r\n                    }\r\n                }\r\n                else if (categoryPrimitiveType === primitiveType) {\r\n                    // Primitive type matches the single supported type for the category\r\n                    t = categoryType;\r\n                }\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    function matchesExtendedTypeWithAnyPrimitive(a: ExtendedType, b: ExtendedType): boolean {\r\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /**\r\n     * Represents the versions of the data shape binding structure.\r\n     * NOTE Keep this file in sync with the Sql\\InfoNav\\src\\Data\\Contracts\\DsqGeneration\\DataShapeBindingVersions.cs\r\n     * file in the TFS Dev branch.\r\n     */\r\n    export const enum DataShapeBindingVersions {\r\n        /** The initial version of data shape binding */\r\n        Version0 = 0,\r\n        /** Explicit subtotal support for axis groupings. */\r\n        Version1 = 1,\r\n    }\r\n\r\n    export interface DataShapeBindingLimitTarget {\r\n        Primary?: number;\r\n    }\r\n\r\n    export enum DataShapeBindingLimitType {\r\n        Top = 0,\r\n        First = 1,\r\n        Last = 2,\r\n        Sample = 3,\r\n        Bottom = 4,\r\n    }\r\n\r\n    export interface DataShapeBindingLimit {\r\n        Count?: number;\r\n        Target: DataShapeBindingLimitTarget;\r\n        Type: DataShapeBindingLimitType;\r\n    }\r\n\r\n    export interface DataShapeBinding {\r\n        Version?: number;\r\n        Primary: DataShapeBindingAxis;\r\n        Secondary?: DataShapeBindingAxis;\r\n        Aggregates?: DataShapeBindingAggregate[];\r\n        Projections?: number[];\r\n        Limits?: DataShapeBindingLimit[];\r\n        Highlights?: FilterDefinition[];\r\n        DataReduction?: DataShapeBindingDataReduction;\r\n        IncludeEmptyGroups?: boolean;\r\n        SuppressedJoinPredicates?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingDataReduction {\r\n        Primary?: DataShapeBindingDataReductionAlgorithm;\r\n        Secondary?: DataShapeBindingDataReductionAlgorithm;\r\n        DataVolume?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionAlgorithm {\r\n        Top?: DataShapeBindingDataReductionTopLimit;\r\n        Sample?: DataShapeBindingDataReductionSampleLimit;\r\n        Bottom?: DataShapeBindingDataReductionBottomLimit;\r\n        Window?: DataShapeBindingDataReductionDataWindow;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionTopLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionSampleLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionBottomLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionDataWindow {\r\n        Count?: number;\r\n        RestartTokens?: RestartToken;\r\n    }\r\n\r\n    export interface DataShapeBindingAxis {\r\n        Groupings: DataShapeBindingAxisGrouping[];\r\n    }\r\n\r\n    export enum SubtotalType {\r\n        None = 0,\r\n        Before = 1,\r\n        After = 2\r\n    }\r\n\r\n    export interface DataShapeBindingAxisGrouping {\r\n        Projections: number[];\r\n        GroupBy?: number[];\r\n        SuppressedProjections?: number[];\r\n        Subtotal?: SubtotalType;\r\n        ShowItemsWithNoData?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingAggregate {\r\n        Select: number;\r\n        Kind?: DataShapeBindingAggregateKind;\r\n        Aggregations?: DataShapeBindingSelectAggregateContainer[];\r\n    }\r\n\r\n    export const enum DataShapeBindingAggregateKind {\r\n        None = 0,\r\n        Min = 1,\r\n        Max = 1 << 1,\r\n    }\r\n\r\n    export interface DataShapeBindingSelectAggregateContainer {\r\n        Percentile: DataShapeBindingSelectPercentileAggregate;\r\n    }\r\n\r\n    export interface DataShapeBindingSelectPercentileAggregate {\r\n        Exclusive?: boolean;\r\n        K: number;\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataShapeBindingDataReduction {\r\n\r\n        export function createFrom(reduction: ReductionAlgorithm): DataShapeBindingDataReductionAlgorithm {\r\n            if (!reduction)\r\n                return;\r\n\r\n            var result: DataShapeBindingDataReductionAlgorithm;\r\n            if (reduction.top) {\r\n                result = {\r\n                    Top: {}\r\n                };\r\n\r\n                if (reduction.top.count)\r\n                    result.Top.Count = reduction.top.count;\r\n            }\r\n\r\n            if (reduction.bottom) {\r\n                result = {\r\n                    Bottom: {}\r\n                };\r\n\r\n                if (reduction.bottom.count)\r\n                    result.Bottom.Count = reduction.bottom.count;\r\n            }\r\n\r\n            if (reduction.sample) {\r\n                result = {\r\n                    Sample: {}\r\n                };\r\n\r\n                if (reduction.sample.count)\r\n                    result.Sample.Count = reduction.sample.count;\r\n            }\r\n\r\n            if (reduction.window) {\r\n                result = {\r\n                    Window: {}\r\n                };\r\n\r\n                if (reduction.window.count)\r\n                    result.Window.Count = reduction.window.count;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface FederatedConceptualSchemaInitOptions {\r\n        schemas: { [name: string]: ConceptualSchema };\r\n        links?: ConceptualSchemaLink[];\r\n    }\r\n\r\n    /** Represents a federated conceptual schema. */\r\n    export class FederatedConceptualSchema {\r\n        private schemas: { [name: string]: ConceptualSchema };\r\n        private links: ConceptualSchemaLink[];\r\n\r\n        constructor(options: FederatedConceptualSchemaInitOptions) {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.schemas = options.schemas; \r\n            if (options.links)\r\n                this.links = options.links;\r\n        }\r\n\r\n        public schema(name: string): ConceptualSchema {\r\n            return this.schemas[name];\r\n        }\r\n    }\r\n\r\n    /** Describes a semantic relationship between ConceptualSchemas. */\r\n    export interface ConceptualSchemaLink {\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module Selector {\r\n        export function filterFromSelector(selectors: Selector[], isNot?: boolean): SemanticFilter {\r\n            if (_.isEmpty(selectors))\r\n                return;\r\n\r\n            let exprs: SQExpr[] = [];\r\n            for (let i = 0, ilen = selectors.length; i < ilen; i++) {\r\n                let identity = selectors[i];\r\n                let data = identity.data;\r\n                let exprToAdd: SQExpr = undefined;\r\n                if (data && data.length) {\r\n                    for (let j = 0, jlen = data.length; j < jlen; j++) {\r\n                        exprToAdd = SQExprBuilder.and(exprToAdd, <SQExpr>(<DataViewScopeIdentity>identity.data[j]).expr);\r\n                    }\r\n                }\r\n\r\n                if (exprToAdd)\r\n                    exprs.push(exprToAdd);\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return DataViewScopeIdentity.filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function matchesData(selector: Selector, identities: DataViewScopeIdentity[]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(identities, 'identities');\r\n\r\n            let selectorData = selector.data;\r\n            if (selectorData.length !== identities.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = selectorData.length; i < len; i++) {\r\n                let dataItem = selector.data[i];\r\n                let selectorDataItem = <DataViewScopeIdentity>dataItem;\r\n                if (selectorDataItem.expr) {\r\n                    if (!DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\r\n                        return false;\r\n                }\r\n                else {\r\n                    if (!DataViewScopeWildcard.matches(<DataViewScopeWildcard>dataItem, identities[i]))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function matchesKeys(selector: Selector, keysList: SQExpr[][]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(keysList, 'keysList');\r\n\r\n            let selectorData = selector.data,\r\n                selectorDataLength = selectorData.length;\r\n            if (selectorDataLength !== keysList.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < selectorDataLength; i++) {\r\n                let selectorDataItem = selector.data[i],\r\n                    selectorDataExprs: SQExpr[];\r\n\r\n                if ((<DataViewScopeIdentity>selectorDataItem).expr) {\r\n                    selectorDataExprs = ScopeIdentityExtractor.getKeys(<SQExpr>(<DataViewScopeIdentity>selectorDataItem).expr);\r\n                }\r\n                else if ((<DataViewScopeWildcard>selectorDataItem).exprs) {\r\n                    selectorDataExprs = <SQExpr[]>(<DataViewScopeWildcard>selectorDataItem).exprs;\r\n                } else { \r\n                    // In case DataViewRoleWildcard\r\n                    return false;\r\n                }\r\n\r\n                if (!selectorDataExprs)\r\n                    continue;\r\n                if (!SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /** Determines whether two selectors are equal. */\r\n        export function equals(x: Selector, y: Selector): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            if (x.id !== y.id)\r\n                return false;\r\n            if (x.metadata !== y.metadata)\r\n                return false;\r\n            if (!equalsDataArray(x.data, y.data))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsDataArray(x: DataRepetitionSelector[], y: DataRepetitionSelector[]): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            if (x.length !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = x.length; i < len; i++) {\r\n                if (!equalsData(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsData(x: DataRepetitionSelector, y: DataRepetitionSelector): boolean {\r\n            let selector1 = <DataViewScopeIdentity & DataViewRoleWildcard & DataViewScopeWildcard>x;\r\n            let selector2 = <DataViewScopeIdentity & DataViewRoleWildcard & DataViewScopeWildcard>y;\r\n            if (selector1.expr && selector2.expr)\r\n                return DataViewScopeIdentity.equals(selector1, selector2);\r\n\r\n            if (selector1.exprs && selector2.exprs)\r\n                return DataViewScopeWildcard.equals(selector1, selector2);\r\n\r\n            if (selector1.roles && selector2.roles)\r\n                return DataViewRoleWildcard.equals(selector1, selector2);\r\n\r\n            return false;\r\n        }\r\n\r\n        export function getKey(selector: Selector): string {\r\n            let toStringify: any = {};\r\n            if (selector.data) {\r\n                let data = [];\r\n                for (let i = 0, ilen = selector.data.length; i < ilen; i++) {\r\n                    data.push(selector.data[i].key);\r\n                }\r\n                toStringify.data = data;\r\n            }\r\n            if (selector.metadata)\r\n                toStringify.metadata = selector.metadata;\r\n            if (selector.id)\r\n                toStringify.id = selector.id;\r\n            return JSON.stringify(toStringify);\r\n        }\r\n\r\n        export function containsWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (!dataItems)\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                let wildCard = <DataViewScopeWildcard & DataViewRoleWildcard>dataItem;\r\n                if (wildCard.exprs || wildCard.roles)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function hasRoleWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (_.isEmpty(dataItems))\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                if (isRoleWildcard(dataItem))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRoleWildcard(dataItem: DataRepetitionSelector): dataItem is DataViewRoleWildcard {\r\n            return !_.isEmpty((<DataViewRoleWildcard>dataItem).roles);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface QueryDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where?: QueryFilter[];\r\n        OrderBy?: QuerySortClause[];\r\n        Select: QueryExpressionContainer[];\r\n        GroupBy?: QueryExpressionContainer[];\r\n    }\r\n\r\n    export interface FilterDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where: QueryFilter[];\r\n    }\r\n\r\n    export enum EntitySourceType {\r\n        Table = 0,\r\n        Pod = 1,\r\n    }\r\n\r\n    export interface EntitySource {\r\n        Name: string;\r\n        EntitySet?: string; // TODO: Remove this when Q&A Silverlight is removed and make Entity required\r\n        Entity?: string;\r\n        Schema?: string;\r\n        Type?: EntitySourceType;\r\n    }\r\n\r\n    export interface QueryFilter {\r\n        Target?: QueryExpressionContainer[];\r\n        Condition: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QuerySortClause {\r\n        Expression: QueryExpressionContainer;\r\n        Direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryExpressionContainer {\r\n        Name?: string;\r\n\r\n        SourceRef?: QuerySourceRefExpression;\r\n        Column?: QueryColumnExpression;\r\n        Measure?: QueryMeasureExpression;\r\n        Aggregation?: QueryAggregationExpression;\r\n        Percentile?: QueryPercentileExpression;\r\n        Hierarchy?: QueryHierarchyExpression;\r\n        HierarchyLevel?: QueryHierarchyLevelExpression;\r\n        PropertyVariationSource?: QueryPropertyVariationSourceExpression;\r\n\r\n        // Logical\r\n        And?: QueryBinaryExpression;\r\n        Between?: QueryBetweenExpression;\r\n        In?: QueryInExpression;\r\n        Or?: QueryBinaryExpression;\r\n        Comparison?: QueryComparisonExpression;\r\n        Not?: QueryNotExpression;\r\n        Contains?: QueryContainsExpression;\r\n        StartsWith?: QueryStartsWithExpression;\r\n        Exists?: QueryExistsExpression;\r\n\r\n        // Constants\r\n        Boolean?: QueryBooleanExpression;\r\n        DateTime?: QueryDateTimeExpression;\r\n        DateTimeSecond?: QueryDateTimeSecondExpression;\r\n        Date?: QueryDateTimeExpression;\r\n        Decimal?: QueryDecimalExpression;\r\n        Integer?: QueryIntegerExpression;\r\n        Null?: QueryNullExpression;\r\n        Number?: QueryNumberExpression;\r\n        String?: QueryStringExpression;\r\n        Literal?: QueryLiteralExpression;\r\n\r\n        DateSpan?: QueryDateSpanExpression;\r\n        DateAdd?: QueryDateAddExpression;\r\n        Now?: QueryNowExpression;\r\n\r\n        // Default Values\r\n        DefaultValue?: QueryDefaultValueExpression;\r\n        AnyValue?: QueryAnyValueExpression;\r\n\r\n        Arithmetic?: QueryArithmeticExpression;\r\n\r\n        // Evaluation Expressions\r\n        ScopedEval?: QueryScopedEvalExpression;\r\n\r\n        // Reference Expressions\r\n        WithRef?: QueryWithRefExpression;\r\n\r\n        // Client-only expressions\r\n        FillRule?: QueryFillRuleExpression;\r\n        ResourcePackageItem?: QueryResourcePackageItem;\r\n        SelectRef?: QuerySelectRefExpression;\r\n    }\r\n\r\n    export interface QueryPropertyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryColumnExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QueryMeasureExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QuerySourceRefExpression {\r\n        Source: string;\r\n    }\r\n\r\n    export interface QuerySelectRefExpression {\r\n        ExpressionName: string;\r\n    }\r\n\r\n    export interface QueryAggregationExpression {\r\n        Function: QueryAggregateFunction;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryPercentileExpression {\r\n        Expression: QueryExpressionContainer;\r\n        K: number;\r\n        Exclusive?: boolean;\r\n    }\r\n\r\n    export interface QueryHierarchyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Hierarchy: string;\r\n    }\r\n\r\n    export interface QueryHierarchyLevelExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Level: string;\r\n    }\r\n\r\n    export interface QueryPropertyVariationSourceExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Name: string;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryBinaryExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryBetweenExpression {\r\n        Expression: QueryExpressionContainer;\r\n        LowerBound: QueryExpressionContainer;\r\n        UpperBound: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryInExpression {\r\n        Expressions: QueryExpressionContainer[];\r\n        Values: QueryExpressionContainer[][];\r\n    }\r\n\r\n    export interface QueryComparisonExpression extends QueryBinaryExpression {\r\n        ComparisonKind: QueryComparisonKind;\r\n    }\r\n\r\n    export interface QueryContainsExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryNotExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryStartsWithExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryExistsExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryConstantExpression<T> {\r\n        Value: T;\r\n    }\r\n\r\n    export interface QueryLiteralExpression {\r\n        Value: string;\r\n    }\r\n\r\n    export interface QueryBooleanExpression extends QueryConstantExpression<boolean> { }\r\n    export interface QueryDateTimeExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDateTimeSecondExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDecimalExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryIntegerExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryNumberExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryNullExpression { }\r\n    export interface QueryStringExpression extends QueryConstantExpression<string> { }\r\n\r\n    export interface QueryDateSpanExpression {\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryDateAddExpression {\r\n        Amount: number;\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryNowExpression { }\r\n\r\n    export interface QueryDefaultValueExpression { }\r\n\r\n    export interface QueryAnyValueExpression { }\r\n\r\n    export interface QueryArithmeticExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n        Operator: ArithmeticOperatorKind;\r\n    }\r\n\r\n    export const enum ArithmeticOperatorKind {\r\n        Add = 0,\r\n        Subtract = 1,\r\n        Multiply = 2,\r\n        Divide = 3,\r\n    }\r\n\r\n    export function getArithmeticOperatorName(arithmeticOperatorKind: ArithmeticOperatorKind): string {\r\n        switch (arithmeticOperatorKind) {\r\n            case ArithmeticOperatorKind.Add:\r\n                return \"Add\";\r\n            case ArithmeticOperatorKind.Subtract:\r\n                return \"Subtract\";\r\n            case ArithmeticOperatorKind.Multiply:\r\n                return \"Multiply\";\r\n            case ArithmeticOperatorKind.Divide:\r\n                return \"Divide\";\r\n        }\r\n        throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\r\n    }\r\n\r\n    export interface QueryFillRuleExpression {\r\n        Input: QueryExpressionContainer;\r\n        FillRule: FillRuleGeneric<QueryExpressionContainer, QueryExpressionContainer>;\r\n    }\r\n\r\n    export interface QueryResourcePackageItem {\r\n        PackageName: string;\r\n        PackageType: number;\r\n        ItemName: string;\r\n    }\r\n\r\n    export interface QueryScopedEvalExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Scope: QueryExpressionContainer[];\r\n    }\r\n\r\n    export interface QueryWithRefExpression {\r\n        ExpressionName: string;\r\n    }\r\n\r\n    export enum TimeUnit {\r\n        Day = 0,\r\n        Week = 1,\r\n        Month = 2,\r\n        Year = 3,\r\n        Decade = 4,\r\n        Second = 5,\r\n        Minute = 6,\r\n        Hour = 7,\r\n    }\r\n\r\n    export enum QueryAggregateFunction {\r\n        Sum = 0,\r\n        Avg = 1,\r\n        Count = 2,\r\n        Min = 3,\r\n        Max = 4,\r\n        CountNonNull = 5,\r\n        Median = 6,\r\n        StandardDeviation = 7,\r\n        Variance = 8,\r\n    }\r\n\r\n    export enum QueryComparisonKind {\r\n        Equal = 0,\r\n        GreaterThan = 1,\r\n        GreaterThanOrEqual = 2,\r\n        LessThan = 3,\r\n        LessThanOrEqual = 4,\r\n    }\r\n\r\n    /** Defines semantic data types. */\r\n    export enum SemanticType {\r\n        None = 0x0,\r\n        Number = 0x1,\r\n        Integer = Number + 0x2,\r\n        DateTime = 0x4,\r\n        Time = 0x08,\r\n        Date = DateTime + 0x10,\r\n        Month = Integer + 0x20,\r\n        Year = Integer + 0x40,\r\n        YearAndMonth = 0x80,\r\n        MonthAndDay = 0x100,\r\n        Decade = Integer + 0x200,\r\n        YearAndWeek = 0x400,\r\n        String = 0x800,\r\n        Boolean = 0x1000,\r\n        Table = 0x2000,\r\n        Range = 0x4000,\r\n    }\r\n\r\n    export interface QueryMetadata {\r\n        Select?: SelectMetadata[];\r\n        Filters?: FilterMetadata[];\r\n    }\r\n\r\n    // TODO: Stop using SemanticType and ConceptualDataCategory here (may need server contract changes)\r\n    export interface SelectMetadata {\r\n        Restatement: string;\r\n\r\n        /* SemanticType or PrimitiveType. */\r\n        Type?: number;\r\n\r\n        Format?: string;\r\n        DataCategory?: ConceptualDataCategory;\r\n\r\n        /** The select projection name. */\r\n        Name?: string;\r\n\r\n        /* If defined, this indicates the KPI class*/\r\n        kpiStatusGraphic?: string; // old version of kpi data\r\n\r\n        /* If defined, this indicates the KPI metadata*/\r\n        kpi?: DataViewKpiColumnMetadata;\r\n    }\r\n\r\n    export interface FilterMetadata {\r\n        Restatement: string;\r\n        Kind?: FilterKind;\r\n        /** The expression being filtered.  This is reflected in the filter card UI. */\r\n        expression?: QueryExpressionContainer;\r\n    }\r\n\r\n    export enum FilterKind {\r\n        Default,\r\n        Period,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Represents a projection from a query result. */\r\n    export interface QueryProjection {\r\n        /** Name of item in the semantic query Select clause. */\r\n        queryRef: string;\r\n\r\n        /** Optional format string. */\r\n        format?: string; // TODO: Deprecate this, and populate format string through objects instead.\r\n    }\r\n\r\n    /** A set of QueryProjections, grouped by visualization property, and ordered within that property. */\r\n    export interface QueryProjectionsByRole {\r\n        [roleName: string]: QueryProjectionCollection;\r\n    }\r\n\r\n    export class QueryProjectionCollection {\r\n        private items: QueryProjection[];\r\n\r\n        /* The activeProjectionReference is an array that contains all the items that we are grouping on in case of a drillable\r\n           role. For example, if you have a drill role with [Country, State, City] and the user drilled to state, the active items\r\n           will include [Country and State]. This means that the query will group on both country and state and the state \"last item\"\r\n           is the item that the user drilled to.\r\n        */\r\n        private _activeProjectionRefs: string[];\r\n        private _showAll: boolean;\r\n\r\n        public constructor(items: QueryProjection[], activeProjectionRefs?: string[], showAll?: boolean) {\r\n            debug.assertValue(items, 'items');\r\n\r\n            this.items = items;\r\n            this._activeProjectionRefs = activeProjectionRefs;\r\n            this._showAll = showAll;\r\n        }\r\n\r\n        /** Returns all projections in a mutable array. */\r\n        public all(): QueryProjection[] {\r\n            return this.items;\r\n        }\r\n\r\n        public get activeProjectionRefs(): string[] {\r\n            return this._activeProjectionRefs;\r\n        }\r\n\r\n        public set activeProjectionRefs(queryReferences: string[]) {\r\n            if (!_.isEmpty(queryReferences)) {\r\n                let queryRefs = this.items.map(val => val.queryRef);\r\n\r\n                for (let queryReference of queryReferences) {\r\n                    if (!_.contains(queryRefs, queryReference))\r\n                        return;\r\n                }\r\n\r\n                this._activeProjectionRefs = queryReferences;\r\n            }\r\n        }\r\n\r\n        public get showAll(): boolean {\r\n            return this._showAll;\r\n        }\r\n\r\n        public set showAll(value: boolean) {\r\n            this._showAll = value;\r\n        }\r\n\r\n        public addActiveQueryReference(queryRef: string): void {\r\n            if (!this._activeProjectionRefs)\r\n                this._activeProjectionRefs = [queryRef];\r\n            else\r\n                this._activeProjectionRefs.push(queryRef);\r\n        }\r\n\r\n        public getLastActiveQueryReference(): string {\r\n            if (!_.isEmpty(this._activeProjectionRefs)) {\r\n                return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\r\n            }\r\n        }\r\n\r\n        /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */\r\n        public replaceQueryRef(oldQueryRef: string, newQueryRef: string): void {\r\n            debug.assertValue(oldQueryRef, 'oldQueryRef');\r\n            debug.assertValue(newQueryRef, 'newQueryRef');\r\n            debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');\r\n            debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');\r\n\r\n            // Note: the same queryRef can get projected multiple times\r\n            for (let item of this.items) {\r\n                if (item.queryRef === oldQueryRef) {\r\n                    item.queryRef = newQueryRef;\r\n                }\r\n            }\r\n        }\r\n\r\n        public clone(): QueryProjectionCollection {\r\n            return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);\r\n        }\r\n    }\r\n\r\n    export module QueryProjectionsByRole {\r\n        /** Clones the QueryProjectionsByRole. */\r\n        export function clone(roles: QueryProjectionsByRole): QueryProjectionsByRole {\r\n            if (!roles)\r\n                return roles;\r\n\r\n            let clonedRoles: QueryProjectionsByRole = {};\r\n\r\n            for (let roleName in roles)\r\n                clonedRoles[roleName] = roles[roleName].clone();\r\n\r\n            return clonedRoles;\r\n        }\r\n\r\n        /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\r\n        export function getRole(roles: QueryProjectionsByRole, name: string): QueryProjectionCollection {\r\n            debug.assertAnyValue(roles, 'roles');\r\n            debug.assertValue(name, 'name');\r\n\r\n            if (!roles)\r\n                return;\r\n\r\n            return roles[name];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export interface VisualElement {\r\n        DataRoles?: DataRole[];\r\n        Settings?: VisualElementSettings;\r\n    }\r\n\r\n    /** Defines common settings for a visual element. */\r\n    export interface VisualElementSettings {\r\n        DisplayUnitSystemType?: DisplayUnitSystemType;\r\n    }\r\n\r\n    export interface DataRole {\r\n        Name: string;\r\n        Projection: number;\r\n        isActive?: boolean;\r\n    }\r\n\r\n    /** The system used to determine display units used during formatting */\r\n    export enum DisplayUnitSystemType {\r\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\r\n        Default,\r\n\r\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\r\n        Verbose,\r\n\r\n        /**\r\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\r\n         * Suitable for dashboard tile cards\r\n         */\r\n        WholeUnits,\r\n\r\n        /**A display unit system that also contains Auto and None units for data labels*/\r\n        DataLabels,\r\n    }\r\n}\r\n\r\nmodule powerbi.data.contracts {\r\n\r\n    export interface DataViewSource {\r\n        data: any;\r\n        type?: string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Repreasents the sequence of the dates/times */\r\n    export class DateTimeSequence {\r\n        // Constants\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;        \r\n\r\n        // Fields\r\n        public min: Date;\r\n        public max: Date;\r\n        public unit: DateTimeUnit;\r\n        public sequence: Date[];\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n\r\n        // Constructors\r\n        /** Creates new instance of the DateTimeSequence */\r\n        constructor(unit: DateTimeUnit) { \r\n            this.unit = unit;\r\n            this.sequence = [];\r\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\r\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Add a new Date to a sequence.\r\n         * @param date - date to add\r\n         */\r\n        public add(date: Date) { \r\n            if (date < this.min) { \r\n                this.min = date;\r\n            }\r\n            if (date > this.max) { \r\n                this.max = date;\r\n            }\r\n            this.sequence.push(date);\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Extends the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public extendToCover(min: Date, max: Date): void {\r\n            let x: Date = this.min;\r\n            while (min < x) {\r\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\r\n                this.sequence.splice(0, 0, x);\r\n            }\r\n            this.min = x;\r\n\r\n            x = this.max;\r\n            while (x < max) {\r\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\r\n                this.sequence.push(x);\r\n            }\r\n            this.max = x;\r\n        }\r\n\r\n        /** \r\n         * Move the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public moveToCover(min: Date, max: Date): void { \r\n            let delta: number = DateTimeSequence.getDelta(min, max, this.unit);\r\n            let count = Math.floor(delta / this.interval);\r\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\r\n\r\n            this.sequence = [];            \r\n            this.sequence.push(this.min);\r\n            this.max = this.min;\r\n            while (this.max < max) {\r\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\r\n                this.sequence.push(this.max);\r\n            }\r\n        }\r\n\r\n        // Static\r\n        /**\r\n         * Calculate a new DateTimeSequence\r\n         * @param dataMin - Date representing min of the data range\r\n         * @param dataMax - Date representing max of the data range\r\n         * @param expectedCount - expected number of intervals in the sequence\r\n         * @param unit - of the intervals in the sequence\r\n         */\r\n        public static calculate(dataMin: Date, dataMax: Date, expectedCount: number, unit?: DateTimeUnit): DateTimeSequence {\r\n            if (!unit) { \r\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\r\n            }\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Month:\r\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Week:\r\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Day:\r\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Hour:\r\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Minute:\r\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Second:\r\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\r\n                default:\r\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\r\n            }\r\n        }\r\n\r\n        public static calculateYears(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\r\n\r\n            // Calculate range and sequence\r\n            let yearsRange = NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\r\n\r\n            // Calculate year sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\r\n            let newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval; \r\n            let date = new Date(newMinYear, 0, 1);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Year);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMonths(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let minYear = dataMin.getFullYear();\r\n            let maxYear = dataMax.getFullYear();\r\n            let minMonth = dataMin.getMonth();\r\n            let maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\r\n            let date = new Date(minYear, 0, 1);\r\n            \r\n            // Calculate month sequence\r\n            let sequence = NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Month);\r\n            return result;\r\n        }\r\n\r\n        public static calculateWeeks(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            let firstDayOfWeek = 0;\r\n            let minDayOfWeek = dataMin.getDay();\r\n            let dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\r\n            let minDay = dataMin.getDate() - dayOffset;\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Week));\r\n\r\n            // Calculate week sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Week);\r\n            return result;\r\n        }\r\n\r\n        public static calculateDays(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, DateTimeUnit.Day));\r\n            \r\n            // Calculate day sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Day);\r\n            return result;\r\n        }\r\n\r\n        public static calculateHours(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Hour));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Hour));\r\n            \r\n            // Calculate hour sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Hour);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMinutes(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Minute));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Minute));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Minute);\r\n            return result;\r\n        }\r\n\r\n        public static calculateSeconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Second));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Second));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Second);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMilliseconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\r\n            let min = DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Millisecond);\r\n            let max = DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Millisecond);\r\n            \r\n            // Calculate milliseconds numeric sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(min, max), expectedCount, 0);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Millisecond);\r\n            return result;\r\n        }\r\n\r\n        public static addInterval(value: Date, interval: number, unit: DateTimeUnit): Date {\r\n            interval = Math.round(interval);\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return DateUtils.addYears(value, interval);\r\n                case DateTimeUnit.Month:\r\n                    return DateUtils.addMonths(value, interval);\r\n                case DateTimeUnit.Week:\r\n                    return DateUtils.addWeeks(value, interval);\r\n                case DateTimeUnit.Day:\r\n                    return DateUtils.addDays(value, interval);\r\n                case DateTimeUnit.Hour:\r\n                    return DateUtils.addHours(value, interval);\r\n                case DateTimeUnit.Minute:\r\n                    return DateUtils.addMinutes(value, interval);\r\n                case DateTimeUnit.Second:\r\n                    return DateUtils.addSeconds(value, interval);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateUtils.addMilliseconds(value, interval);\r\n            }\r\n        }\r\n\r\n        private static fromNumericSequence(date: Date, sequence: NumericSequence, unit: DateTimeUnit) { \r\n            let result = new DateTimeSequence(unit);\r\n            for (let i = 0; i < sequence.sequence.length; i++) { \r\n                let x: number = sequence.sequence[i];\r\n                let d: Date = DateTimeSequence.addInterval(date, x, unit);\r\n                result.add(d);\r\n            }\r\n            result.interval = sequence.interval;\r\n            result.intervalOffset = sequence.intervalOffset;\r\n            return result;\r\n        }\r\n\r\n        private static getDelta(min: Date, max: Date, unit: DateTimeUnit): number {\r\n            let delta: number = 0;\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    delta = max.getFullYear() - min.getFullYear();\r\n                    break;\r\n                case DateTimeUnit.Month:\r\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\r\n                    break;\r\n                case DateTimeUnit.Week:\r\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Day:\r\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Hour:\r\n                    delta = (max.getTime() - min.getTime()) / 3600000;\r\n                    break;\r\n                case DateTimeUnit.Minute:\r\n                    delta = (max.getTime() - min.getTime()) / 60000;\r\n                    break;\r\n                case DateTimeUnit.Second:\r\n                    delta = (max.getTime() - min.getTime()) / 1000;\r\n                    break;\r\n                case DateTimeUnit.Millisecond:\r\n                    delta = max.getTime() - min.getTime();\r\n                    break;\r\n            }\r\n            return delta;\r\n        }\r\n\r\n        public static getIntervalUnit(min:Date, max:Date, maxCount: number): DateTimeUnit {\r\n            maxCount = Math.max(maxCount, 2);\r\n            let totalDays = DateTimeSequence.getDelta(min, max, DateTimeUnit.Day);\r\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\r\n                return DateTimeUnit.Year;\r\n            if (totalDays > 60 && totalDays > 7 * maxCount)\r\n                return DateTimeUnit.Month;\r\n            if (totalDays > 14 && totalDays > 2 * maxCount)\r\n                return DateTimeUnit.Week;\r\n            let totalHours = DateTimeSequence.getDelta(min, max, DateTimeUnit.Hour);\r\n            if (totalDays > 2 && totalHours > 12 * maxCount)\r\n                return DateTimeUnit.Day;\r\n            if (totalHours >= 24 && totalHours >= maxCount)\r\n                return DateTimeUnit.Hour;\r\n            let totalMinutes = DateTimeSequence.getDelta(min, max, DateTimeUnit.Minute);\r\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\r\n                return DateTimeUnit.Minute;\r\n            let totalSeconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Second);\r\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\r\n                return DateTimeUnit.Second;\r\n            let totalMilliseconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Millisecond);\r\n            if (totalMilliseconds > 0)\r\n                return DateTimeUnit.Millisecond;\r\n  \r\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\r\n            let date = min;\r\n            if (date.getMilliseconds() !== 0)\r\n                return DateTimeUnit.Millisecond;\r\n            if (date.getSeconds() !== 0)\r\n                return DateTimeUnit.Second;\r\n            if (date.getMinutes() !== 0)\r\n                return DateTimeUnit.Minute;\r\n            if (date.getHours() !== 0)\r\n                return DateTimeUnit.Hour;\r\n            if (date.getDate() !== 1)\r\n                return DateTimeUnit.Day;\r\n            if (date.getMonth() !== 0)\r\n                return DateTimeUnit.Month;\r\n            \r\n            return DateTimeUnit.Year;\r\n        }\r\n    }\r\n\r\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\r\n    export module DateUtils { \r\n        let MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n        let MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n\r\n        /**\r\n         * Returns bool indicating weither the provided year is a leap year.\r\n         * @param year - year value\r\n         */\r\n        function isLeap(year: number): boolean { \r\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\r\n        }\r\n\r\n        /** \r\n         * Returns number of days in the provided year/month.\r\n         * @param year - year value\r\n         * @param month - month value\r\n         */\r\n        function getMonthDays(year: number, month: number) { \r\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of years to the provided date.\r\n         * @param date - date value\r\n         * @param yearDelta - number of years to add\r\n         */\r\n        export function addYears(date: Date, yearDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n            let isLeapDay = month === 2 && day === 29;\r\n\r\n            let result = new Date(date.getTime());\r\n            year = year + yearDelta;\r\n            if (isLeapDay && !isLeap(year)) {\r\n                day = 28;\r\n            } \r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of months to the provided date.\r\n         * @param date - date value\r\n         * @param monthDelta - number of months to add\r\n         */\r\n        export function addMonths(date: Date, monthDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n           \r\n            let result = new Date(date.getTime());\r\n            year += (monthDelta - (monthDelta % 12)) / 12;\r\n            month += monthDelta % 12;\r\n\r\n            // VSTS 1325771: Certain column charts don't display any data\r\n            // Wrap arround the month if is after december (value 11)\r\n            if (month > 11) {\r\n                month = month % 12;\r\n                year++;\r\n            }\r\n\r\n            day = Math.min(day, getMonthDays(year, month));\r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of weeks to the provided date.\r\n         * @param date - date value\r\n         * @param weeks - number of weeks to add\r\n         */\r\n        export function addWeeks(date: Date, weeks: number): Date { \r\n            return addDays(date, weeks * 7);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of days to the provided date.\r\n         * @param date - date value\r\n         * @param days - number of days to add\r\n         */\r\n        export function addDays(date: Date, days: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();           \r\n            let result = new Date(date.getTime());\r\n            result.setFullYear(year, month, day + days);\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of hours to the provided date.\r\n         * @param date - date value\r\n         * @param hours - number of hours to add\r\n         */\r\n        export function addHours(date: Date, hours: number): Date { \r\n            return new Date(date.getTime() + hours * 3600000);\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of minutes to the provided date.\r\n         * @param date - date value\r\n         * @param minutes - number of minutes to add\r\n         */\r\n        export function addMinutes(date: Date, minutes: number): Date { \r\n            return new Date(date.getTime() + minutes * 60000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of seconds to the provided date.\r\n         * @param date - date value\r\n         * @param seconds - number of seconds to add\r\n         */\r\n        export function addSeconds(date: Date, seconds: number): Date { \r\n            return new Date(date.getTime() + seconds * 1000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of milliseconds to the provided date.\r\n         * @param date - date value\r\n         * @param milliseconds - number of milliseconds to add\r\n         */\r\n        export function addMilliseconds(date: Date, milliseconds: number): Date { \r\n            return new Date(date.getTime() + milliseconds);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    // Constants\r\n    const maxExponent = 24;\r\n    const defaultScientificBigNumbersBoundary = 1E15;\r\n    const scientificSmallNumbersBoundary = 1E-4;\r\n    const PERCENTAGE_FORMAT = '%';\r\n    const SCIENTIFIC_FORMAT = 'E+0';\r\n    const DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\r\n\r\n    // Regular expressions\r\n    /**\r\n     * This regex looks for strings that match one of the following conditions:\r\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\r\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\r\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\r\n     * The entire string (start to end) must match, and the match is not case-sensitive.\r\n     */\r\n    const SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\r\n\r\n    export class DisplayUnit {\r\n        // Fields\r\n        public value: number;\r\n        public title: string;\r\n        public labelFormat: string;\r\n        public applicableRangeMin: number;\r\n        public applicableRangeMax: number;\r\n\r\n        // Methods\r\n        public project(value: number): number {\r\n            if (this.value) {\r\n                return Double.removeDecimalNoise(value / this.value);\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public reverseProject(value: number): number {\r\n            if (this.value) {\r\n                return value * this.value;\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public isApplicableTo(value: number): boolean {\r\n            value = Math.abs(value);\r\n            let precision = Double.getPrecision(value, 3);\r\n            return Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && Double.lessWithPrecision(value, this.applicableRangeMax, precision);\r\n        }\r\n\r\n        public isScaling(): boolean {\r\n            return this.value > 1;\r\n        }\r\n    }\r\n\r\n    export class DisplayUnitSystem {\r\n        // Fields\r\n        public units: DisplayUnit[];\r\n        public displayUnit: DisplayUnit;\r\n        private unitBaseValue: number;\r\n        protected static UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\r\n\r\n        // Constructor\r\n        constructor(units?: DisplayUnit[]) {\r\n            this.units = units ? units : [];\r\n        }\r\n\r\n        // Properties\r\n        public get title(): string {\r\n            return this.displayUnit ? this.displayUnit.title : undefined;\r\n        }\r\n\r\n        // Methods\r\n        public update(value: number): void {\r\n            if (value === undefined)\r\n                return;\r\n\r\n            this.unitBaseValue = value;\r\n            this.displayUnit = this.findApplicableDisplayUnit(value);\r\n        }\r\n\r\n        private findApplicableDisplayUnit(value: number): DisplayUnit {\r\n            for (let unit of this.units) {\r\n                if (unit.isApplicableTo(value))\r\n                    return unit;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        public format(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n            if (this.isFormatSupported(format)) {\r\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\r\n\r\n                if (this.hasScientitifcFormat(format)) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\r\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\r\n                }\r\n                if (decimals != null) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n            }\r\n            \r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        public isPercentageFormat(format: string): boolean {\r\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\r\n        }\r\n\r\n        public shouldRespectScalingUnit(format: string): boolean {\r\n            return !this.isPercentageFormat(format);\r\n        }\r\n\r\n        public getNumberOfDecimalsForFormatting(format: string, decimals?: number) {\r\n            return decimals;\r\n        }\r\n\r\n        public isScalingUnit(): boolean {\r\n            return this.displayUnit && this.displayUnit.isScaling();\r\n        }\r\n\r\n        private formatHelper(value: number, nonScientificFormat: string, format: string, decimals?: number, trailingZeros?: boolean) {\r\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\r\n            if ((format === 'g' || format === 'G') && decimals != null)\r\n                format = visuals.valueFormatter.DefaultNumericFormat;\r\n\r\n            format = NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\r\n\r\n            if (format && !formattingService.isStandardNumberFormat(format))\r\n                return formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\r\n\r\n            if (!format)\r\n                format = 'G';\r\n            if (!nonScientificFormat)\r\n                nonScientificFormat = '{0}';\r\n\r\n            let text = formattingService.formatValue(value, format);\r\n            return formattingService.format(nonScientificFormat, [text]);\r\n        }\r\n\r\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\r\n        public formatSingleValue(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            // Change unit base to a value appropriate for this value\r\n            this.update(this.shouldUseValuePrecision(value) ? Double.getPrecision(value, 8) : value);\r\n\r\n            return this.format(value, format, decimals, trailingZeros);\r\n        }\r\n\r\n        private shouldUseValuePrecision(value: number): boolean {\r\n            if (this.units.length === 0)\r\n                return true;\r\n\r\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\r\n            let applicableRangeMin: number = 0;\r\n            for (let i = 0; i < this.units.length; i++) {\r\n                if (this.units[i].isScaling()) {\r\n                    applicableRangeMin = this.units[i].applicableRangeMin;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return Math.abs(value) < applicableRangeMin;\r\n        }\r\n\r\n        protected isScientific(value: number): boolean {\r\n            return value < - defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\r\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\r\n        }\r\n\r\n        protected hasScientitifcFormat(format: string): boolean {\r\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\r\n        }\r\n\r\n        protected supportsScientificFormat(format: string): boolean {\r\n            if (format)\r\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\r\n\r\n            return true;\r\n        }\r\n\r\n        protected shouldFallbackToScientific(value: number, format: string): boolean {\r\n            return !this.hasScientitifcFormat(format)\r\n                && this.supportsScientificFormat(format)\r\n                && this.isScientific(value);\r\n        }\r\n\r\n        protected getScientificFormat(data: number, format: string, decimals: number, trailingZeros: boolean): string {\r\n            // Use scientific format outside of the range\r\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\r\n                let numericFormat = NumberFormat.getNumericFormat(data, format);\r\n                if (decimals)\r\n                    numericFormat = NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\r\n\r\n                if (numericFormat)\r\n                    return numericFormat + SCIENTIFIC_FORMAT;\r\n                else\r\n                    return DEFAULT_SCIENTIFIC_FORMAT;\r\n            }\r\n\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\r\n    export class NoDisplayUnitSystem extends DisplayUnitSystem {\r\n        // Constructor\r\n        constructor() {\r\n            super([]);\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\r\n        we are showing values (chart axes) and as such it is the default unit system. */\r\n    export class DefaultDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DefaultDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        // Methods\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n\r\n        public static reset(): void {\r\n            DefaultDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DefaultDisplayUnitSystem.units) {\r\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, (value: number, previousUnitValue: number, min: number) => {\r\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\r\n                    if (value - previousUnitValue >= 1000) {\r\n                        return value / 10;\r\n                    }\r\n\r\n                    return min;\r\n                });\r\n\r\n                // Ensure last unit has max of infinity\r\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DefaultDisplayUnitSystem.units;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\r\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\r\n        where we have restricted space but do not want to show partial units. */\r\n    export class WholeUnitsDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public static reset(): void {\r\n            WholeUnitsDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!WholeUnitsDisplayUnitSystem.units) {\r\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\r\n\r\n                // Ensure last unit has max of infinity\r\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n\r\n            return WholeUnitsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export class DataLabelsDisplayUnitSystem extends DisplayUnitSystem {\r\n\r\n        // Constants\r\n        private static AUTO_DISPLAYUNIT_VALUE = 0;\r\n        private static NONE_DISPLAYUNIT_VALUE = 1;\r\n        protected static UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\r\n\r\n        private static units: DisplayUnit[];\r\n\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DataLabelsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DataLabelsDisplayUnitSystem.units) {\r\n                let units = [];\r\n                let adjustMinBasedOnPreviousUnit = (value: number, previousUnitValue: number, min: number): number => {\r\n                    // Never returns true, we are always ignoring\r\n                    // We do not early switch (e.g. 100K instead of 0.1M)\r\n                    // Intended? If so, remove this function, otherwise, remove if statement\r\n                    if (value === -1)\r\n                        if (value - previousUnitValue >= 1000) {\r\n                            return value / 10;\r\n                        }\r\n                    return min;\r\n                };\r\n\r\n                // Add Auto & None\r\n                let names = unitLookup(-1);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                names = unitLookup(0);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                // Add normal units\r\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\r\n\r\n                // Ensure last unit has max of infinity\r\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DataLabelsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export interface DisplayUnitSystemNames {\r\n        title: string;\r\n        format: string;\r\n    }\r\n\r\n    function createDisplayUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames, adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number) {\r\n        let units = [];\r\n        for (let i = 3; i < maxExponent; i++) {\r\n            let names = unitLookup(i);\r\n            if (names)\r\n                addUnitIfNonEmpty(units, Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n        }\r\n\r\n        return units;\r\n    }\r\n\r\n    function addUnitIfNonEmpty(\r\n        units: DisplayUnit[],\r\n        value: number,\r\n        title: string,\r\n        labelFormat: string,\r\n        adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number): void {\r\n        if (title || labelFormat) {\r\n            let min = value;\r\n\r\n            if (units.length > 0) {\r\n                let previousUnit = units[units.length - 1];\r\n\r\n                if (adjustMinBasedOnPreviousUnit)\r\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\r\n\r\n                previousUnit.applicableRangeMax = min;\r\n            }\r\n            let unit = new DisplayUnit();\r\n            unit.value = value;\r\n            unit.applicableRangeMin = min;\r\n            unit.applicableRangeMax = min * 1000;\r\n            unit.title = title;\r\n            unit.labelFormat = labelFormat;\r\n            units.push(unit);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequence {\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;\r\n\r\n        private maxAllowedMargin: number;\r\n        private canExtendMin: boolean;\r\n        private canExtendMax: boolean;\r\n\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n        public min: number;\r\n        public max: number;\r\n        public precision: number;\r\n        public sequence: number[];\r\n\r\n        public static calculate (range: NumericSequenceRange, expectedCount: number, maxAllowedMargin?: number, minPower?: number, useZeroRefPoint?: boolean, steps?: number[]): NumericSequence {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\r\n            debug.assert(minPower === undefined|| (minPower >= Double.MIN_EXP && minPower <= Double.MAX_EXP), \"minPower\");\r\n            debug.assert(maxAllowedMargin === undefined|| (maxAllowedMargin >= 0), \"maxAllowedMargin\");\r\n\r\n            let result = new NumericSequence();\r\n\r\n            if (expectedCount === undefined)\r\n                expectedCount = 10;\r\n            else\r\n                expectedCount = Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (minPower === undefined)\r\n                minPower = Double.MIN_EXP;\r\n            if (useZeroRefPoint === undefined)\r\n                useZeroRefPoint = false;\r\n            if (maxAllowedMargin === undefined)\r\n                maxAllowedMargin = 1;\r\n            if (steps === undefined)\r\n                steps = [1, 2, 5];\r\n\r\n            // Handle single stop case\r\n            if (range.forcedSingleStop) {\r\n                result.interval = range.getSize();\r\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\r\n                result.min = range.min;\r\n                result.max = range.max;\r\n                result.sequence = [range.forcedSingleStop];\r\n                return result;\r\n            }\r\n\r\n            let interval = 0;\r\n            let min = 0;\r\n            let max = 9;\r\n            let canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\r\n            let canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\r\n\r\n            let size = range.getSize();\r\n            let exp = Double.log10(size);\r\n\r\n            // Account for Exp of steps\r\n            let stepExp = Double.log10(steps[0]);\r\n            exp = exp - stepExp;\r\n\r\n            // Account for MaxCount\r\n            let expectedCountExp = Double.log10(expectedCount);\r\n            exp = exp - expectedCountExp;\r\n\r\n            // Account for MinPower\r\n            exp = Math.max(exp, minPower - stepExp + 1);\r\n            let count = undefined;\r\n            // Create array of \"good looking\" numbers\r\n            if (interval !== 0) {\r\n                // If explicit interval is defined - use it instead of the steps array.\r\n                let power = Double.pow10(exp);\r\n                let roundMin = Double.floorToPrecision(range.min, power);\r\n                let roundMax = Double.ceilToPrecision(range.max, power);\r\n                let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\r\n\r\n                roundRange.shrinkByStep(range, interval);\r\n                min = roundRange.min;\r\n                max = roundRange.max;\r\n                count = Math.floor(roundRange.getSize() / interval);\r\n            }\r\n            else {\r\n                // No interval defined -> find optimal interval\r\n                let dexp;\r\n                for (dexp = 0; dexp < 3; dexp++) {\r\n                    let e = exp + dexp;\r\n                    let power = Double.pow10(e);\r\n\r\n                    let roundMin = Double.floorToPrecision(range.min, power);\r\n                    let roundMax = Double.ceilToPrecision(range.max, power);\r\n\r\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\r\n                    let stepsCount = steps.length;\r\n                    let stepPower = Double.pow10(e - 1);\r\n                    for (let i = 0; i < stepsCount; i++) {\r\n                        let step = steps[i] * stepPower;\r\n                        let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\r\n                        roundRange.shrinkByStep(range, step);\r\n\r\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\r\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\r\n                            roundRange.min -= step;\r\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\r\n                            roundRange.max += step;\r\n\r\n                        // Count the intervals\r\n                        count = Double.ceilWithPrecision(roundRange.getSize() / step);\r\n\r\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\r\n                            interval = step;\r\n                            min = roundRange.min;\r\n                            max = roundRange.max;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Increase the scale power until the interval is found\r\n                    if (interval !== 0)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Avoid extreme count cases (>1000 ticks)\r\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\r\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\r\n                interval = (max - min) / count;\r\n            }\r\n\r\n            result.min = min;\r\n            result.max = max;\r\n            result.interval = interval;\r\n            result.intervalOffset = min - range.min;\r\n            result.maxAllowedMargin = maxAllowedMargin;\r\n            result.canExtendMin = canExtendMin;\r\n            result.canExtendMax = canExtendMax;\r\n\r\n            // Fill in the Sequence\r\n            let precision = Double.getPrecision(interval, 0);\r\n            result.precision = precision;\r\n\r\n            let sequence = [];\r\n\r\n            let x = Double.roundToPrecision(min, precision);\r\n            sequence.push(x);\r\n            for (let i = 0; i < count; i++) {\r\n                x = Double.roundToPrecision(x + interval, precision);\r\n                sequence.push(x);\r\n            }\r\n            \r\n            result.sequence = sequence;\r\n\r\n            result.trimMinMax(range.min, range.max);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid. \r\n         * @min - The minimum of the range.\r\n         * @max - The maximum of the range.\r\n         * @maxCount - The max count of intervals.\r\n         * @steps - array of intervals.\r\n         */\r\n        public static calculateUnits(min: number, max: number, maxCount: number, steps: number[]): NumericSequence {\r\n            // Initialization actions\r\n            maxCount = Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (min === max) {\r\n                max = min + 1;\r\n            }\r\n            let stepCount = 0;\r\n            let step = 0;\r\n\r\n            // Calculate step\r\n            for (let i = 0; i < steps.length; i++)\r\n            {\r\n                step = steps[i];\r\n                let maxStepCount = Double.ceilWithPrecision(max / step);\r\n                let minStepCount = Double.floorWithPrecision(min / step);\r\n                stepCount = maxStepCount - minStepCount;\r\n                    \r\n                if (stepCount <= maxCount) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Calculate the offset\r\n            let offset = -min;\r\n            offset = offset % step;\r\n\r\n            // Create sequence\r\n            let result = new NumericSequence();\r\n            result.sequence = [];\r\n            for (let x = min + offset; ; x += step)\r\n            {\r\n                result.sequence.push(x);\r\n                if (x >= max)\r\n                    break;\r\n            }\r\n            result.interval = step;\r\n            result.intervalOffset = offset;\r\n            result.min = result.sequence[0];\r\n            result.max = result.sequence[result.sequence.length - 1];\r\n            return result;\r\n        }\r\n\r\n        public trimMinMax(min: number, max: number): void {        \r\n            let minMargin = (min - this.min) / this.interval;\r\n            let maxMargin = (this.max - max) / this.interval;\r\n            let marginPrecision = 0.001;\r\n\r\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\r\n                this.min = min;\r\n            }\r\n\r\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\r\n                this.max = max;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequenceRange {\r\n        private static DEFAULT_MAX: number = 10;\r\n        private static MIN_SUPPORTED_DOUBLE = -1E307;\r\n        private static MAX_SUPPORTED_DOUBLE = 1E307;\r\n\r\n        public min: number;\r\n        public max: number;\r\n        public includeZero: boolean;\r\n        public forcedSingleStop: number;\r\n        public hasDataRange: boolean;\r\n        public hasFixedMin: boolean;\r\n        public hasFixedMax: boolean;\r\n\r\n        private _ensureIncludeZero(): void { \r\n            if (this.includeZero) {\r\n                // fixed min and max has higher priority than includeZero\r\n                if (this.min > 0 && !this.hasFixedMin) {\r\n                    this.min = 0;\r\n                }\r\n                if (this.max < 0 && !this.hasFixedMax) {\r\n                    this.max = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureNotEmpty(): void { \r\n            if (this.min === this.max) {\r\n                if (!this.min) {\r\n                    this.min = 0;\r\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\r\n                    this.hasFixedMin = true;\r\n                    this.hasFixedMax = true;\r\n                } else {\r\n                    // We are dealing with a single data value (includeZero is not set)\r\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\r\n                    // Interval is calculated based on the number:\r\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\r\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\r\n                    let value = this.min;\r\n                    let exp = Double.log10(Math.abs(value));\r\n                    let step: number;\r\n                    if (exp >= 0 && exp < 4) {\r\n                        step = 0.5;\r\n                        this.forcedSingleStop = value;\r\n                    } else {\r\n                        step = Double.pow10(exp) / 2;\r\n                        this.forcedSingleStop = null;\r\n                    }\r\n                    this.min = value - step;\r\n                    this.max = value + step;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureDirection() { \r\n            if (this.min > this.max) { \r\n                let temp = this.min;\r\n                this.min = this.max;\r\n                this.max = temp;\r\n            }\r\n        }\r\n\r\n        public getSize(): number {\r\n            return this.max - this.min;\r\n        }\r\n\r\n        public shrinkByStep(range: NumericSequenceRange, step: number) {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(step > 0, \"step\");\r\n\r\n            let oldCount = this.min / step;\r\n            let newCount = range.min / step;\r\n            let deltaCount = Math.floor(newCount - oldCount);\r\n            this.min += deltaCount * step;\r\n\r\n            oldCount = this.max / step;\r\n            newCount = range.max / step;\r\n            deltaCount = Math.ceil(newCount - oldCount);\r\n            this.max += deltaCount * step;\r\n        }\r\n\r\n        public static calculate(dataMin: number, dataMax: number, fixedMin?:number, fixedMax?:number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\r\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.includeZero = includeZero ? true : false;\r\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\r\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\r\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\r\n\r\n            dataMin = Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n            dataMax = Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n\r\n            // Calculate the range using the min, max, dataRange\r\n            if (result.hasFixedMin && result.hasFixedMax) {\r\n                result.min = fixedMin;\r\n                result.max = fixedMax;\r\n            } else if (result.hasFixedMin) {\r\n                result.min = fixedMin;\r\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\r\n            } else if (result.hasFixedMax) {\r\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\r\n                result.max = fixedMax;\r\n            } else if (result.hasDataRange) {\r\n                result.min = dataMin;\r\n                result.max = dataMax;\r\n            } else {\r\n                result.min = 0;\r\n                result.max = 0;\r\n            }\r\n\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            \r\n            if (result.min === 0) {\r\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\r\n            } else if (result.max === 0) {\r\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public static calculateDataRange(dataMin: number, dataMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\r\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\r\n            } else {\r\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\r\n            }\r\n        }\r\n\r\n        public static calculateFixedRange(fixedMin: number, fixedMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assertValue(fixedMin, \"fixedMin\");\r\n            debug.assertValue(fixedMax, \"fixedMax\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.hasDataRange = false;\r\n            result.includeZero = includeZero;\r\n            result.min = fixedMin;\r\n            result.max = fixedMax;\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            result.hasFixedMin = true;\r\n            result.hasFixedMax = true;\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export module ValueUtil {\r\n        export function hasValue(value: any): boolean {\r\n            return value !== undefined && value !== null;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n\r\n    /**\r\n     * Formats the value using provided format expression\r\n     * @param value - value to be formatted and converted to string.\r\n     * @param format - format to be applied if the number shouldn't be abbreviated.\r\n     * If the number should be abbreviated this string is checked for special characters like $ or % if any\r\n     */\r\n    export interface ICustomValueFormatter {\r\n        (value: any, format?: string): string;\r\n    }\r\n\r\n    export interface ICustomValueColumnFormatter {\r\n        (value: any,\r\n            column: DataViewMetadataColumn,\r\n            formatStringProp: DataViewObjectPropertyIdentifier,\r\n            nullsAreBlank?: boolean): string;\r\n    }\r\n\r\n    export interface ValueFormatterOptions {\r\n        /** The format string to use. */\r\n        format?: string;\r\n\r\n        /** The data value. */\r\n        value?: any;\r\n\r\n        /** The data value. */\r\n        value2?: any;\r\n\r\n        /** The number of ticks. */\r\n        tickCount?: any;\r\n\r\n        /** The display unit system to use */\r\n        displayUnitSystemType?: DisplayUnitSystemType;\r\n\r\n        /** True if we are formatting single values in isolation (e.g. card), as opposed to multiple values with a common base (e.g. chart axes) */\r\n        formatSingleValues?: boolean;\r\n\r\n        /** True if we want to trim off unnecessary zeroes after the decimal and remove a space before the % symbol */\r\n        allowFormatBeautification?: boolean;\r\n\r\n        /** Specifies the maximum number of decimal places to show*/\r\n        precision?: number;\r\n\r\n        /** Detect axis precision based on value */\r\n        detectAxisPrecision?: boolean;\r\n\r\n        /** Specifies the column type of the data value */\r\n        columnType?: ValueTypeDescriptor;\r\n    }\r\n\r\n    export interface IValueFormatter {\r\n        format(value: any): string;\r\n        displayUnit?: DisplayUnit;\r\n        options?: ValueFormatterOptions;\r\n    }\r\n\r\n    /** Captures all locale-specific options used by the valueFormatter. */\r\n    export interface ValueFormatterLocalizationOptions {\r\n        null: string;\r\n        true: string;\r\n        false: string;\r\n        NaN: string;\r\n        infinity: string;\r\n        negativeInfinity: string;\r\n\r\n        /** Returns a beautified form the given format string. */\r\n        beautify(format: string): string;\r\n\r\n        /** Returns an object describing the given exponent in the current language. */\r\n        describe(exponent: number): DisplayUnitSystemNames;\r\n        restatementComma: string;\r\n        restatementCompoundAnd: string;\r\n        restatementCompoundOr: string;\r\n    }\r\n\r\n    export module valueFormatter {\r\n        import StringExtensions = jsCommon.StringExtensions;\r\n        const BeautifiedFormat: { [x: string]: string } = {\r\n            '0.00 %;-0.00 %;0.00 %': 'Percentage',\r\n            '0.0 %;-0.0 %;0.0 %': 'Percentage1',\r\n        };\r\n\r\n        export const DefaultIntegerFormat = 'g';\r\n        export const DefaultNumericFormat = '#,0.00';\r\n        export const DefaultDateFormat = 'd';\r\n\r\n        const defaultLocalizedStrings = {\r\n            'NullValue': '(Blank)',\r\n            'BooleanTrue': 'True',\r\n            'BooleanFalse': 'False',\r\n            'NaNValue': 'NaN',\r\n            'InfinityValue': '+Infinity',\r\n            'NegativeInfinityValue': '-Infinity',\r\n            'RestatementComma': '{0}, {1}',\r\n            'RestatementCompoundAnd': '{0} and {1}',\r\n            'RestatementCompoundOr': '{0} or {1}',\r\n            'DisplayUnitSystem_EAuto_Title': 'Auto',\r\n            'DisplayUnitSystem_E0_Title': 'None',\r\n            'DisplayUnitSystem_E3_LabelFormat': '{0}K',\r\n            'DisplayUnitSystem_E3_Title': 'Thousands',\r\n            'DisplayUnitSystem_E6_LabelFormat': '{0}M',\r\n            'DisplayUnitSystem_E6_Title': 'Millions',\r\n            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\r\n            'DisplayUnitSystem_E9_Title': 'Billions',\r\n            'DisplayUnitSystem_E12_LabelFormat': '{0}T',\r\n            'DisplayUnitSystem_E12_Title': 'Trillions',\r\n            'Percentage': '#,0.##%',\r\n            'Percentage1': '#,0.#%',\r\n            'TableTotalLabel': 'Total',\r\n            'Tooltip_HighlightedValueDisplayName': 'Highlighted',\r\n            'Funnel_PercentOfFirst': 'Percent of first',\r\n            'Funnel_PercentOfPrevious': 'Percent of previous',\r\n            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',\r\n            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',\r\n            // Geotagging strings\r\n            'GeotaggingString_Continent': 'continent',\r\n            'GeotaggingString_Continents': 'continents',\r\n            'GeotaggingString_Country': 'country',\r\n            'GeotaggingString_Countries': 'countries',\r\n            'GeotaggingString_State': 'state',\r\n            'GeotaggingString_States': 'states',\r\n            'GeotaggingString_City': 'city',\r\n            'GeotaggingString_Cities': 'cities',\r\n            'GeotaggingString_Town': 'town',\r\n            'GeotaggingString_Towns': 'towns',\r\n            'GeotaggingString_Province': 'province',\r\n            'GeotaggingString_Provinces': 'provinces',\r\n            'GeotaggingString_County': 'county',\r\n            'GeotaggingString_Counties': 'counties',\r\n            'GeotaggingString_Village': 'village',\r\n            'GeotaggingString_Villages': 'villages',\r\n            'GeotaggingString_Post': 'post',\r\n            'GeotaggingString_Zip': 'zip',\r\n            'GeotaggingString_Code': 'code',\r\n            'GeotaggingString_Place': 'place',\r\n            'GeotaggingString_Places': 'places',\r\n            'GeotaggingString_Address': 'address',\r\n            'GeotaggingString_Addresses': 'addresses',\r\n            'GeotaggingString_Street': 'street',\r\n            'GeotaggingString_Streets': 'streets',\r\n            'GeotaggingString_Longitude': 'longitude',\r\n            'GeotaggingString_Longitude_Short': 'lon',\r\n            'GeotaggingString_Latitude': 'latitude',\r\n            'GeotaggingString_Latitude_Short': 'lat',\r\n            'GeotaggingString_PostalCode': 'postal code',\r\n            'GeotaggingString_PostalCodes': 'postal codes',\r\n            'GeotaggingString_ZipCode': 'zip code',\r\n            'GeotaggingString_ZipCodes': 'zip codes',\r\n            'GeotaggingString_Territory': 'territory',\r\n            'GeotaggingString_Territories': 'territories',\r\n        };\r\n\r\n        function beautify(format: string): string {\r\n            let key = BeautifiedFormat[format];\r\n            if (key)\r\n                return defaultLocalizedStrings[key] || format;\r\n            return format;\r\n        }\r\n\r\n        function describeUnit(exponent: number): DisplayUnitSystemNames {\r\n            let exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\r\n\r\n            let title: string = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\r\n            let format: string = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\r\n\r\n            if (title || format)\r\n                return { title: title, format: format };\r\n        }\r\n\r\n        export function getLocalizedString(stringId: string): string {\r\n            return defaultLocalizedStrings[stringId];\r\n        }\r\n\r\n        // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\r\n        let locale: ValueFormatterLocalizationOptions = {\r\n            null: defaultLocalizedStrings['NullValue'],\r\n            true: defaultLocalizedStrings['BooleanTrue'],\r\n            false: defaultLocalizedStrings['BooleanFalse'],\r\n            NaN: defaultLocalizedStrings['NaNValue'],\r\n            infinity: defaultLocalizedStrings['InfinityValue'],\r\n            negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\r\n            beautify: format => beautify(format),\r\n            describe: exponent => describeUnit(exponent),\r\n            restatementComma: defaultLocalizedStrings['RestatementComma'],\r\n            restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\r\n            restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\r\n        };\r\n\r\n        const MaxScaledDecimalPlaces = 2;\r\n        const MaxValueForDisplayUnitRounding = 1000;\r\n        const MinIntegerValueForDisplayUnits = 10000;\r\n        const MinPrecisionForDisplayUnits = 2;\r\n\r\n        const DateTimeMetadataColumn: DataViewMetadataColumn = {\r\n            displayName: '',\r\n            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),\r\n        };\r\n\r\n        export function getFormatMetadata(format: string): powerbi.NumberFormat.NumericFormatMetadata {\r\n            return powerbi.NumberFormat.getCustomFormatMetadata(format);\r\n        }\r\n\r\n        export function setLocaleOptions(options: ValueFormatterLocalizationOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            locale = options;\r\n\r\n            DefaultDisplayUnitSystem.reset();\r\n            WholeUnitsDisplayUnitSystem.reset();\r\n        }\r\n\r\n        export function createDefaultFormatter(formatString: string, allowFormatBeautification: boolean = false): IValueFormatter {\r\n            let formatBeaut: string = allowFormatBeautification ? locale.beautify(formatString) : formatString;\r\n            return {\r\n                format: function (value: any): string {\r\n                    if (value == null)\r\n                        return locale.null;\r\n\r\n                    return formatCore(value, formatBeaut);\r\n                }\r\n            };\r\n        }\r\n\r\n        /** Creates an IValueFormatter to be used for a range of values. */\r\n        export function create(options: ValueFormatterOptions): IValueFormatter {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\r\n\r\n            if (shouldUseNumericDisplayUnits(options)) {\r\n                let displayUnitSystem = createDisplayUnitSystem(options.displayUnitSystemType);\r\n\r\n                let singleValueFormattingMode = !!options.formatSingleValues;\r\n\r\n                displayUnitSystem.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\r\n\r\n                let forcePrecision = options.precision != null;\r\n\r\n                let decimals: number;\r\n\r\n                if (forcePrecision)\r\n                    decimals = -options.precision;\r\n                else if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 1)\r\n                    decimals = -MaxScaledDecimalPlaces;\r\n\r\n                // Detect axis precision\r\n                if (options.detectAxisPrecision) {\r\n                    // Trailing zeroes\r\n                    forcePrecision = true;\r\n\r\n                    let axisValue = options.value;\r\n                    if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 0)\r\n                        axisValue = axisValue / displayUnitSystem.displayUnit.value;\r\n\r\n                    if (Double.isInteger(axisValue))\r\n                        decimals = 0;\r\n                    else\r\n                        decimals = Double.log10(axisValue);\r\n                }\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        let formattedValue: string = getStringFormat(value, true /*nullsAreBlank*/);\r\n                        if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                            return formattedValue;\r\n\r\n                        // Round to Double.DEFAULT_PRECISION\r\n                        if (value && !displayUnitSystem.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision)\r\n                            value = Double.roundToPrecision(value);\r\n\r\n                        return singleValueFormattingMode ?\r\n                            displayUnitSystem.formatSingleValue(value, format, decimals, forcePrecision) :\r\n                            displayUnitSystem.format(value, format, decimals, forcePrecision);\r\n                    },\r\n                    displayUnit: displayUnitSystem.displayUnit,\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\r\n                let unit = DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        if (value == null)\r\n                            return locale.null;\r\n\r\n                        let formatString = formattingService.dateFormatString(unit);\r\n                        return formatCore(value, formatString);\r\n                    },\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            return createDefaultFormatter(format);\r\n        }\r\n\r\n        export function format(value: any, format?: string, allowFormatBeautification?: boolean): string {\r\n            if (value == null)\r\n                return locale.null;\r\n\r\n            return formatCore(\r\n                value,\r\n                !!allowFormatBeautification ? locale.beautify(format) : format);\r\n        }\r\n\r\n        /**\r\n         * Value formatting function to handle variant measures.\r\n         * For a Date/Time value within a non-date/time field, it's formatted with the default date/time formatString instead of as a number\r\n         * @param {any} value Value to be formatted\r\n         * @param {DataViewMetadataColumn} column Field which the value belongs to\r\n         * @param {DataViewObjectPropertyIdentifier} formatStringProp formatString Property ID\r\n         * @param {boolean} nullsAreBlank? Whether to show \"(Blank)\" instead of empty string for null values\r\n         * @returns Formatted value\r\n         */\r\n        export function formatVariantMeasureValue(value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier, nullsAreBlank?: boolean): string {\r\n            // If column type is not datetime, but the value is of time datetime,\r\n            // then use the default date format string\r\n            if (!(column && column.type && column.type.dateTime) && value instanceof Date) {\r\n                let valueFormat = getFormatString(DateTimeMetadataColumn, null, false);\r\n                return formatCore(value, valueFormat, nullsAreBlank);\r\n            }\r\n            else {\r\n                return formatCore(value, getFormatString(column, formatStringProp), nullsAreBlank);\r\n            }\r\n        }\r\n\r\n        function createDisplayUnitSystem(displayUnitSystemType?: DisplayUnitSystemType): DisplayUnitSystem {\r\n            if (displayUnitSystemType == null)\r\n                return new DefaultDisplayUnitSystem(locale.describe);\r\n\r\n            switch (displayUnitSystemType) {\r\n                case DisplayUnitSystemType.Default:\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.WholeUnits:\r\n                    return new WholeUnitsDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.Verbose:\r\n                    return new NoDisplayUnitSystem();\r\n                case DisplayUnitSystemType.DataLabels:\r\n                    return new DataLabelsDisplayUnitSystem(locale.describe);\r\n                default:\r\n                    debug.assertFail('Unknown display unit system type');\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n            }\r\n        }\r\n\r\n        function shouldUseNumericDisplayUnits(options: ValueFormatterOptions): boolean {\r\n            let value = options.value;\r\n            let value2 = options.value2;\r\n            let format = options.format;\r\n            // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\r\n            if (options.formatSingleValues && format) {\r\n\r\n                if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\r\n\r\n                    let isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\r\n\r\n                    if (isCustomFormat) {\r\n                        let precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\r\n\r\n                        if (precision < MinPrecisionForDisplayUnits)\r\n                            return false;\r\n                    }\r\n                    else if (Double.isInteger(value))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            if ((typeof value === 'number') || (typeof value2 === 'number')) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        function shouldUseDateUnits(value: any, value2?: any, tickCount?: number): boolean {\r\n            // must check both value and value2 because we'll need to get an interval for date units\r\n            return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\r\n        }\r\n\r\n        /*\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Column format\r\n         *  2. Default PowerView policy for column type\r\n         */\r\n        export function getFormatString(column: DataViewMetadataColumn, formatStringProperty: DataViewObjectPropertyIdentifier, suppressTypeFallback?: boolean): string {\r\n            if (column) {\r\n                if (formatStringProperty) {\r\n                    let propertyValue = DataViewObjects.getValue<string>(column.objects, formatStringProperty);\r\n                    if (propertyValue)\r\n                        return propertyValue;\r\n                }\r\n\r\n                if (!suppressTypeFallback) {\r\n                    let columnType = column.type;\r\n                    if (columnType) {\r\n                        if (columnType.dateTime)\r\n                            return DefaultDateFormat;\r\n                        if (columnType.integer)\r\n                            return DefaultIntegerFormat;\r\n                        if (columnType.numeric)\r\n                            return DefaultNumericFormat;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function formatListCompound(strings: string[], conjunction: string): string {\r\n            let result: string;\r\n\r\n            if (!strings) {\r\n                return null;\r\n            }\r\n\r\n            let length = strings.length;\r\n            if (length > 0) {\r\n                result = strings[0];\r\n                let lastIndex = length - 1;\r\n                for (let i = 1, len = lastIndex; i < len; i++) {\r\n                    let value = strings[i];\r\n                    result = StringExtensions.format(locale.restatementComma, result, value);\r\n                }\r\n\r\n                if (length > 1) {\r\n                    let value = strings[lastIndex];\r\n                    result = StringExtensions.format(conjunction, result, value);\r\n                }\r\n            }\r\n            else {\r\n                result = null;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., and C'  */\r\n        export function formatListAnd(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundAnd);\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., or C' */\r\n        export function formatListOr(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundOr);\r\n        }\r\n\r\n        function formatCore(value: any, format: string, nullsAreBlank?: boolean): string {\r\n            let formattedValue = getStringFormat(value, nullsAreBlank ? nullsAreBlank : false /*nullsAreBlank*/);\r\n\r\n            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                return formattedValue;\r\n\r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        function getStringFormat(value: any, nullsAreBlank: boolean): string {\r\n            if (value == null && nullsAreBlank)\r\n                return locale.null;\r\n\r\n            if (value === true)\r\n                return locale.true;\r\n\r\n            if (value === false)\r\n                return locale.false;\r\n\r\n            if (typeof value === 'number' && isNaN(value))\r\n                return locale.NaN;\r\n\r\n            if (value === Number.NEGATIVE_INFINITY)\r\n                return locale.negativeInfinity;\r\n\r\n            if (value === Number.POSITIVE_INFINITY)\r\n                return locale.infinity;\r\n\r\n            return '';\r\n        }\r\n\r\n        export function getDisplayUnits(displayUnitSystemType: DisplayUnitSystemType): DisplayUnit[] {\r\n            let displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\r\n            return displayUnitSystem.units;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataRoleHelper {\r\n        export function getMeasureIndexOfRole(grouped: DataViewValueColumnGroup[], roleName: string): number {\r\n            if (!_.isEmpty(grouped)) {\r\n                let firstGroup = grouped[0];\r\n                if (firstGroup.values && firstGroup.values.length > 0) {\r\n                    for (let i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                        let value = firstGroup.values[i];\r\n                        if (value && value.source) {\r\n                            if (hasRole(value.source, roleName))\r\n                                return i;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function getCategoryIndexOfRole(categories: DataViewCategoryColumn[], roleName: string): number {\r\n            if (!_.isEmpty(categories)) {\r\n                for (let i = 0, ilen = categories.length; i < ilen; i++) {\r\n                    if (hasRole(categories[i].source, roleName))\r\n                        return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function hasRole(column: DataViewMetadataColumn, name: string): boolean {\r\n            let roles = column.roles;\r\n            return roles && roles[name];\r\n        }\r\n\r\n        export function hasRoleInDataView(dataView: DataView, name: string): boolean {\r\n            return dataView != null\r\n                && dataView.metadata != null\r\n                && dataView.metadata.columns\r\n                && _.any(dataView.metadata.columns, c => c.roles && c.roles[name] !== undefined);\r\n        }\r\n        \r\n        export function hasRoleInValueColumn(valueColumn: DataViewValueColumn, name: string): boolean {\r\n            return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\r\n\r\n    export function createIDataViewCategoricalReader(dataView: DataView): IDataViewCategoricalReader {\r\n        return new DataViewCategoricalReader(dataView);\r\n    }\r\n\r\n    export interface IDataViewCategoricalReader {\r\n        // Category functions\r\n        hasCategories(): boolean;\r\n        getCategoryCount(): number;\r\n        getCategoryValues(roleName: string): any;\r\n        getCategoryValue(roleName: string, categoryIndex: number): any;\r\n        getCategoryColumn(roleName: string): DataViewCategoryColumn;\r\n        getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn;\r\n        getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[];\r\n        getCategoryDisplayName(roleName: string): string;\r\n        hasCompositeCategories(): boolean;\r\n        hasCategoryWithRole(roleName: string): boolean;\r\n        getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects;\r\n        // Value functions\r\n        hasValues(roleName: string): boolean;\r\n        hasHighlights(roleName: string): boolean;\r\n        /**\r\n         * Obtains the value for the given role name, category index, and series index.\r\n         *\r\n         * Note: in cases where have multiple values in a role where the multiple values\r\n         * are not being used to create a static series, the first is obtained. (this is\r\n         * a rare case)\r\n         */\r\n        getValue(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains the highlighted value for the given role name, category index, and series index.\r\n         *\r\n         * Note: in cases where have multiple values in a role where the multiple values\r\n         * are not being used to create a static series, the first is obtained. (this is\r\n         * a rare case)\r\n         */\r\n        getHighlight(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains all the values for the given role name, category index, and series index, drawing\r\n         * from each of the value columns at that intersection.  Used when you have multiple\r\n         * values in a role that are not conceptually a static series.\r\n         */\r\n        getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex?: number): any[];\r\n        /**\r\n        * Obtains all meta data for the given role name, category index, and series index, drawing\r\n        * from each of the value columns at that intersection.  Used when you have multiple\r\n        * values in a role that are not conceptually a static series.\r\n        */\r\n        getAllValueMetadataColumnsForRole(roleName: string, seriesIndex: number): DataViewMetadataColumn[];\r\n        /**\r\n         * Obtains all the highlight values for the given role name, category index, and series index, drawing\r\n         * from each of the value columns at that intersection.  Used when you have multiple\r\n         * values in a role that are not conceptually a static series.\r\n         */\r\n        getAllHighlightsForRole(roleName: string, categoryIndex: number, seriesIndex?: number): any[];\r\n        /**\r\n         * Obtains the first non-null value for the given role name and category index.\r\n         * It should mainly be used for values that are expected to be the same across\r\n         * series, but avoids false nulls when the data is sparse.\r\n         */\r\n        getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any;\r\n        getMeasureQueryName(roleName: string): string;\r\n        getValueColumn(roleName: string, seriesIndex?: number): DataViewValueColumn;\r\n        getValueMetadataColumn(roleName: string, seriesIndex?: number): DataViewMetadataColumn;\r\n        getAllValueMetadataColumnsForRole(roleName: string, seriesIndex: number): DataViewMetadataColumn[];\r\n        getValueDisplayName(roleName: string, seriesIndex?: number): string;\r\n        // Series Methods\r\n        hasDynamicSeries(): boolean;\r\n        /**\r\n         * Get the series count.  This requires a value role name for cases where you may\r\n         * have a static series, but is not required if the only series you expect are dynamic\r\n         * or single series. \r\n         * \r\n         * @param valueRoleName The role of the value for which a static series may exist\r\n         */\r\n        getSeriesCount(valueRoleName?: string): number;\r\n        getSeriesObjects(seriesIndex: number): DataViewObjects;\r\n        getSeriesValueColumns(): DataViewValueColumns;\r\n        getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup;\r\n        getSeriesMetadataColumn(): DataViewMetadataColumn;\r\n        getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[];\r\n        getSeriesName(seriesIndex: number): PrimitiveValue;\r\n        getSeriesDisplayName(): string;\r\n    }\r\n\r\n    /**\r\n     * A mapping used to map indeces within a specific roleName to an index into the values\r\n     * of a grouped.  This is used so that you can iterate over values within a role without\r\n     * expensive filtering or extra traversal.\r\n     */ \r\n    interface RoleIndexMapping {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    class DataViewCategoricalReader implements IDataViewCategoricalReader {\r\n        private dataView: DataView;\r\n        private categories: DataViewCategoryColumn[];\r\n        private grouped: DataViewValueColumnGroup[];\r\n        private dataHasDynamicSeries: boolean;\r\n        private valueRoleIndexMapping: RoleIndexMapping;\r\n        \r\n        // Validation variables\r\n        private hasValidCategories: boolean;\r\n        private hasAnyValidValues: boolean;\r\n\r\n        constructor(dataView: DataView) {\r\n            debug.assertValue(dataView, 'dataView');\r\n            this.dataView = dataView;\r\n            // Validate categories\r\n            let categorical: DataViewCategorical;\r\n            if (dataView)\r\n                categorical = dataView.categorical;\r\n            let categories: DataViewCategoryColumn[];\r\n            if (categorical)\r\n                categories = this.categories = categorical.categories;\r\n            this.hasValidCategories = !_.isEmpty(categories);\r\n\r\n            // Validate values\r\n            let values: DataViewValueColumns;\r\n            if (categorical)\r\n                values = categorical.values;\r\n            // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\r\n            // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\r\n            this.hasAnyValidValues = false;\r\n            if (values != null) {\r\n                let grouped = dataView.categorical.values.grouped();\r\n\r\n                if (grouped.length > 0) {\r\n                    this.hasAnyValidValues = true;\r\n                    this.grouped = grouped;\r\n\r\n                    // Iterate through the first group's values to populate the valueRoleIndexMapping\r\n                    let valueRoleIndexMapping: RoleIndexMapping = {};\r\n                    let firstGroupValues = grouped[0].values;\r\n                    for (let valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\r\n                        let valueRoles = firstGroupValues[valueIndex].source.roles;\r\n                        for (let role in valueRoles) {\r\n                            if (valueRoles[role]) {\r\n                                if (!valueRoleIndexMapping[role])\r\n                                    valueRoleIndexMapping[role] = [];\r\n                                valueRoleIndexMapping[role].push(valueIndex);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.valueRoleIndexMapping = valueRoleIndexMapping;\r\n                }\r\n            }\r\n\r\n            if (this.hasAnyValidValues)\r\n                this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\r\n        }\r\n\r\n        // Category methods\r\n        \r\n        public hasCategories(): boolean {\r\n            return this.hasValidCategories;\r\n        }\r\n\r\n        public getCategoryCount(): number {\r\n            if (this.hasValidCategories)\r\n                return this.categories[0].values.length;\r\n            else\r\n                return 0;\r\n        }\r\n\r\n        public getCategoryValues(roleName: string): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryValue(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values[categoryIndex] : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumn(roleName: string): DataViewCategoryColumn {\r\n            if (this.hasValidCategories)\r\n                return this.getCategoryFromRole(roleName);\r\n        }\r\n\r\n        public getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.source : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[] {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.identityFields : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryDisplayName(roleName: string): string {\r\n            if (this.hasValidCategories) {\r\n                let targetColumn = this.getCategoryColumn(roleName);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        public hasCompositeCategories(): boolean {\r\n            if (this.hasValidCategories)\r\n                return this.categories.length > 1;\r\n        }\r\n\r\n        public hasCategoryWithRole(roleName: string): boolean {\r\n            return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\r\n        }\r\n\r\n        public getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects {\r\n            if (this.hasValidCategories) {\r\n                let category = this.getCategoryFromRole(roleName);\r\n                if (category && category.objects) {\r\n                    return category.objects[categoryIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        private getCategoryFromRole(roleName: string): DataViewCategoryColumn {\r\n            let categories = this.categories;\r\n            return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\r\n        }\r\n\r\n        // Value and measure methods\r\n\r\n        public hasValues(roleName: string): boolean {\r\n            return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\r\n        }\r\n\r\n        public hasHighlights(roleName: string): boolean {\r\n            if (this.hasValues(roleName)) {\r\n                return !_.isEmpty(this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].highlights);\r\n            }\r\n            return false;\r\n        }\r\n        \r\n        public getValue(roleName: string, categoryIndex: number, seriesIndex: number = 0): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    // For dynamic series, we only ever obtain the first value column from a role\r\n                    return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, false /* getHighlight */);\r\n                }\r\n                else {\r\n                    // For static series or single series, we obtain value columns from the first series\r\n                    //    and use the seriesIndex to index into the value columns within the role\r\n                    return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, false /* getHighlight */);\r\n                }\r\n            }\r\n        }\r\n\r\n        public getHighlight(roleName: string, categoryIndex: number, seriesIndex: number = 0): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    // For dynamic series, we only ever obtain the first value column from a role\r\n                    return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, true /* getHighlight */);\r\n                }\r\n                else {\r\n                    // For static series or single series, we obtain value columns from the first series\r\n                    //    and use the seriesIndex to index into the value columns within the role\r\n                    return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, true /* getHighlight */);\r\n                }\r\n            }\r\n        }\r\n\r\n        public getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex: number = 0): any[] {\r\n            if (this.hasValues(roleName)) {\r\n                let valuesInRole = [];\r\n                for (let roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, false /* getHighlight */));\r\n                }\r\n                return valuesInRole;\r\n            }\r\n        }\r\n\r\n        public getAllHighlightsForRole(roleName: string, categoryIndex: number, seriesIndex: number = 0): any[] {\r\n            if (this.hasValues(roleName)) {\r\n                let valuesInRole = [];\r\n                for (let roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, true /* getHighlight */));\r\n                }\r\n                return valuesInRole;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Obtains the value from grouped.\r\n         *\r\n         * Grouped:             [0] [1] [2] [3] (seriesIndex)\r\n         *                         /   \\\r\n         * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\r\n         *                    /    \\ \\  \\           \r\n         * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\r\n         * \r\n         *--------------------------------|\r\n         *                      |Category |\r\n         * Series|Value Columns |A B C D E|\r\n         *--------------------------------|\r\n         *      0|col0 (tooltip)|         |\r\n         *       |col1 (value)  |         |\r\n         *       |col2 (value)  |         |\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      1|col0 (tooltip)|         |\r\n         *       |col1 (value)  |0 1 2 3 4|\r\n         *       |col2 (value)  |5 6 7 8 9|\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      2|col0 (tooltip)|...      |\r\n         * \r\n         * valueColumnIndexInRole is for indexing into the values for a single role\r\n         * valueColumnIndex is for indexing into the entire value array including\r\n         * all roles\r\n         * \r\n         * The valueRoleIndexMapping converts roleValueIndex and role (value role\r\n         * with an index of 1) into groupedValueIndex (2)\r\n         *\r\n         * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\r\n         * the second value column with role \"value\" (which is converted to a\r\n         * groupedValueIndex of 2) and the fourth value within that value column.\r\n         */\r\n        private getValueInternal(roleName: string, categoryIndex: number, groupIndex: number, valueColumnIndexInRole: number, getHighlight: boolean): any {\r\n            if (this.hasValues(roleName)) {\r\n                let valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\r\n                let groupedValues = this.grouped[groupIndex].values[valueColumnIndex];\r\n                return getHighlight ? groupedValues.highlights[categoryIndex] : groupedValues.values[categoryIndex];\r\n            }\r\n        }\r\n\r\n        public getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (!this.dataHasDynamicSeries) {\r\n                    debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\r\n                    return this.getValue(roleName, categoryIndex);\r\n                }\r\n                for (let seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\r\n                    let value = this.getValue(roleName, categoryIndex, seriesIndex);\r\n                    if (value != null) {\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public getMeasureQueryName(roleName: string): string {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\r\n        }\r\n\r\n        public getValueColumn(roleName: string, seriesIndex: number = 0): DataViewValueColumn {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\r\n                }\r\n                else {\r\n                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][seriesIndex]];\r\n                }\r\n            }\r\n        }\r\n        \r\n        public getValueMetadataColumn(roleName: string, seriesIndex: number = 0): DataViewMetadataColumn {\r\n            let valueColumn = this.getValueColumn(roleName, seriesIndex);\r\n            if (valueColumn) {\r\n                return valueColumn.source;\r\n            }\r\n        }\r\n\r\n        public getAllValueMetadataColumnsForRole(roleName: string, seriesIndex: number = 0): DataViewMetadataColumn[] {\r\n            if (this.hasValues(roleName)) {\r\n                let metadata = [];\r\n                for (let roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    let column = this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][roleValueIndex]].source;\r\n                    metadata.push(column);\r\n                }\r\n                return metadata;\r\n            }\r\n        }\r\n\r\n        public getValueDisplayName(roleName: string, seriesIndex?: number): string {\r\n            if (this.hasValues(roleName)) {\r\n                let targetColumn = this.getValueColumn(roleName, seriesIndex);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Series methods\r\n\r\n        public hasDynamicSeries(): boolean {\r\n            return this.dataHasDynamicSeries;\r\n        }\r\n\r\n        public getSeriesCount(valueRoleName?: string): number {\r\n            if (!this.hasAnyValidValues)\r\n                return;\r\n\r\n            if (this.dataHasDynamicSeries) {\r\n                return this.grouped.length;\r\n            }\r\n            else {\r\n                let roleIndexMap = valueRoleName && this.valueRoleIndexMapping[valueRoleName];\r\n\r\n                if (roleIndexMap)\r\n                    return roleIndexMap.length;\r\n\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        public getSeriesObjects(seriesIndex: number): DataViewObjects {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].objects;\r\n        }\r\n\r\n        public getSeriesValueColumns(): DataViewValueColumns {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values;\r\n        }\r\n\r\n        public getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex];\r\n        }\r\n\r\n        public getSeriesMetadataColumn(): DataViewMetadataColumn {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.source;\r\n        }\r\n\r\n        public getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[] {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.identityFields;\r\n        }\r\n\r\n        public getSeriesName(seriesIndex: number): PrimitiveValue {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].name;\r\n        }\r\n\r\n        public getSeriesDisplayName(): string {\r\n            if (this.hasAnyValidValues && this.dataHasDynamicSeries)\r\n                return this.dataView.categorical.values.source.displayName;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n    import valueFormatter = powerbi.visuals.valueFormatter;\r\n\r\n    export module DataViewConcatenateCategoricalColumns {\r\n\r\n        /* Represents a collection of DataViewCategoryColumn that are tied to the same role. */\r\n        interface CategoryColumnsByRole {\r\n            /* The name of the role shared by all the objects in the categories property. */\r\n            roleName: string;\r\n\r\n            /**\r\n             * The list of columns that are tied to roleName, in the same order as they appear\r\n             * in the categories property of their owner DataViewCategorical object.\r\n             */\r\n            categories: DataViewCategoryColumn[];\r\n        }\r\n\r\n        export function detectAndApply(\r\n            dataView: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            selects: DataViewSelectTransform[],\r\n            projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n\r\n            let result = dataView;\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            if (dataViewCategorical) {\r\n                let concatenationSource: CategoryColumnsByRole = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\r\n\r\n                if (concatenationSource) {\r\n                    // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\r\n                    let columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\r\n                    if (columnsSortedByProjectionOrdering.length >= 2) {\r\n                        let activeItemsToIgnoreInConcatenation =\r\n                            _.chain(projectionActiveItems[concatenationSource.roleName])\r\n                                .filter((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.suppressConcat)\r\n                                .map((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.queryRef)\r\n                                .value();\r\n\r\n                        result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\r\n        export function applyToPlayChartCategorical(\r\n            metadata: DataViewMetadata,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            categoryRoleName: string,\r\n            categorical: DataViewCategorical): DataView {\r\n            debug.assertValue(metadata, 'metadata');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let result: DataView;\r\n            if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\r\n                // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\r\n                // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\r\n                // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\r\n                // use inherit() rather than inheritSingle() here.\r\n                let transformingColumns = inherit(metadata.columns);\r\n                let transformingMetadata = inherit(metadata, m => { m.columns = transformingColumns; });\r\n\r\n                let transformingDataView = { metadata: transformingMetadata, categorical: categorical };\r\n                result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\r\n            }\r\n            else {\r\n                result = { metadata: metadata, categorical: categorical };\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the role and its assocated category columns (from dataViewCategorical.categories)\r\n         * that should be concatenated for the case of hierarchical group.\r\n         *\r\n         * Note: In the future if we support sibling hierarchical groups in categorical,\r\n         * change the return type to CategoryColumnsByRole[] and update detection logic.\r\n         */\r\n        function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical: DataViewCategorical, metadata: DataViewMetadata, dataViewMappings: DataViewMapping[], selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): CategoryColumnsByRole {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\r\n\r\n            let result: CategoryColumnsByRole;\r\n\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\r\n            let projections = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let supportedRoleMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // The following code will choose a role name only if all supportedRoleMappings share the same role for Categorical Category.\r\n            // Handling multiple supportedRoleMappings is necessary for TransformActions with splits, which can happen in scenarios such as:\r\n            // 1. combo chart with a field for both Line and Column values, and\r\n            // 2. chart with regression line enabled.\r\n            // In case 1, you can pretty much get exactly the one from supportedRoleMappings for which this code is currently processing for,\r\n            // by looking at the index of the current split in DataViewTransformActions.splits.\r\n            // In case 2, however, supportedRoleMappings.length will be different than DataViewTransformActions.splits.length, hence it is\r\n            // not straight forward to figure out for which one in supportedRoleMappings is this code currently processing.\r\n            // SO... This code will just choose the category role name if it is consistent across all supportedRoleMappings.\r\n\r\n            let isEveryRoleMappingForCategorical = !_.isEmpty(supportedRoleMappings) &&\r\n                _.every(supportedRoleMappings, (roleMapping) => !!roleMapping.categorical);\r\n\r\n            if (isEveryRoleMappingForCategorical) {\r\n                let targetRoleName = getSingleCategoryRoleNameInEveryRoleMapping(supportedRoleMappings);\r\n                if (targetRoleName &&\r\n                    isVisualExpectingMaxOneCategoryColumn(targetRoleName, supportedRoleMappings)) {\r\n\r\n                    let categoryColumnsForTargetRole: DataViewCategoryColumn[] = _.filter(\r\n                        dataViewCategorical.categories,\r\n                        (categoryColumn: DataViewCategoryColumn) => categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName]);\r\n\r\n                    // There is no need to concatenate columns unless there is actually more than one column\r\n                    if (categoryColumnsForTargetRole.length >= 2) {\r\n                        // At least for now, we expect all category columns for the same role to have the same number of value entries.\r\n                        // If that's not the case, we won't run the concatenate logic for that role at all...\r\n                        let areValuesCountsEqual: boolean = _.every(\r\n                            categoryColumnsForTargetRole,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.values.length === categoryColumnsForTargetRole[0].values.length);\r\n                        \r\n                        if (areValuesCountsEqual) {\r\n                            result = {\r\n                                roleName: targetRoleName,\r\n                                categories: categoryColumnsForTargetRole,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** If all mappings in the specified roleMappings have the same single role name for their categorical category roles, return that role name, else returns undefined. */\r\n        function getSingleCategoryRoleNameInEveryRoleMapping(categoricalRoleMappings: DataViewMapping[]): string {\r\n            debug.assertNonEmpty(categoricalRoleMappings, 'categoricalRoleMappings');\r\n            debug.assert(_.every(categoricalRoleMappings, (roleMapping) => !!roleMapping.categorical), 'All mappings in categoricalRoleMappings must contain a DataViewCategoricalMapping');\r\n\r\n            let result: string;\r\n\r\n            // With \"list\" in role mapping, it is possible to have multiple role names for category.\r\n            // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\r\n            // We can change this if we want to support independent (sibling) group hierarchies in categorical.\r\n            let uniqueCategoryRoles: string[] = _.chain(categoricalRoleMappings)\r\n                .map((roleMapping) => {\r\n                    let categoryRoles = getAllRolesInCategories(roleMapping.categorical);\r\n                    return categoryRoles.length === 1 ? categoryRoles[0] : undefined;\r\n                })\r\n                .uniq() // Note: _.uniq() does not treat two arrays with same elements as equal\r\n                .value();\r\n            \r\n\r\n            let isSameCategoryRoleNameInAllRoleMappings = uniqueCategoryRoles.length === 1 && !_.isUndefined(uniqueCategoryRoles[0]);\r\n            if (isSameCategoryRoleNameInAllRoleMappings) {\r\n                result = uniqueCategoryRoles[0];\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function isVisualExpectingMaxOneCategoryColumn(categoricalRoleName: string, roleMappings: DataViewMapping[]): boolean {\r\n            debug.assertValue(categoricalRoleName, 'categoricalRoleName');\r\n            debug.assertNonEmpty(roleMappings, 'roleMappings');\r\n\r\n            let isVisualExpectingMaxOneCategoryColumn = _.every(\r\n                roleMappings,\r\n                (roleMapping) => {\r\n                    return !_.isEmpty(roleMapping.conditions) &&\r\n                        _.every(roleMapping.conditions, condition => condition[categoricalRoleName] && condition[categoricalRoleName].max === 1);\r\n                });\r\n\r\n            return isVisualExpectingMaxOneCategoryColumn;\r\n        }\r\n\r\n        /**\r\n         * Returns the array of role names that are mapped to categorical categories.\r\n         * Returns an empty array if none exists.\r\n         */\r\n        function getAllRolesInCategories(categoricalRoleMapping: DataViewCategoricalMapping): string[] {\r\n            debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\r\n\r\n            let roleNames: string[] = [];\r\n            DataViewMapping.visitCategoricalCategories(\r\n                categoricalRoleMapping.categories,\r\n                {\r\n                    visitRole: (roleName: string) => {\r\n                        roleNames.push(roleName);\r\n                    }\r\n                });\r\n\r\n            return roleNames;\r\n        }\r\n\r\n        function applyConcatenation(dataView: DataView, objectDescriptors: DataViewObjectDescriptors, roleName: string, columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let formatStringPropId: DataViewObjectPropertyIdentifier = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            let concatenatedValues: string[] = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\r\n\r\n            let columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, categoryColumn => categoryColumn.source);\r\n            let concatenatedColumnMetadata: DataViewMetadataColumn = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\r\n            let transformedDataView = inheritSingle(dataView);\r\n            addToMetadata(transformedDataView, concatenatedColumnMetadata);\r\n\r\n            let concatenatedCategoryColumn: DataViewCategoryColumn = createConcatenatedCategoryColumn(\r\n                columnsSortedByProjectionOrdering,\r\n                concatenatedColumnMetadata,\r\n                concatenatedValues);\r\n\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            let transformedCategoricalCategories: DataViewCategoryColumn[] = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\r\n            transformedCategoricalCategories.push(concatenatedCategoryColumn);\r\n\r\n            let transformedCategorical: DataViewCategorical = inheritSingle(dataViewCategorical);\r\n            transformedCategorical.categories = transformedCategoricalCategories;\r\n            transformedDataView.categorical = transformedCategorical;\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        function concatenateValues(columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[], formatStringPropId: DataViewObjectPropertyIdentifier): string[] {\r\n            debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\r\n            debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\r\n            debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\r\n\r\n            let concatenatedValues: string[] = [];\r\n\r\n            // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\r\n            for (let categoryColumn of columnsSortedByProjectionOrdering) {\r\n                let formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\r\n\r\n                for (let i = 0, len = categoryColumn.values.length; i < len; i++) {\r\n                    if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\r\n                        let value = categoryColumn.values && categoryColumn.values[i];\r\n                        let formattedValue = valueFormatter.format(value, formatString);\r\n                        concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return concatenatedValues;\r\n        }\r\n\r\n        /**\r\n        * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\r\n        */\r\n        function sortColumnsByProjectionOrdering(projectionOrdering: DataViewProjectionOrdering, roleName: string, columns: DataViewCategoryColumn[]): DataViewCategoryColumn[] {\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            let columnsInProjectionOrdering: DataViewCategoryColumn[];\r\n\r\n            if (projectionOrdering) {\r\n                // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\r\n                let columnsByIndex: { [index: number]: DataViewCategoricalColumn } = {};\r\n                for (let column of columns) {\r\n                    if (column.source.roles[roleName]) {\r\n                        debug.assert(!columnsByIndex[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\r\n                        columnsByIndex[column.source.index] = column;\r\n                    }\r\n                }\r\n\r\n                let columnIndicesInProjectionOrdering: number[] = projectionOrdering[roleName];\r\n\r\n                columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\r\n                    .map(columnIndex => columnsByIndex[columnIndex])\r\n                    .filter((column: DataViewCategoricalColumn) => !!column)\r\n                    .value();\r\n            }\r\n            else {\r\n                // If projectionOrder is unspecified, just return the columns for the specified role in their current order\r\n                columnsInProjectionOrdering = _.filter(columns, column => column.source.roles[roleName]);\r\n            }\r\n\r\n            return columnsInProjectionOrdering;\r\n        }\r\n\r\n        /**\r\n         * Creates the column metadata that will back the column with the concatenated values. \r\n         */\r\n        function createConcatenatedColumnMetadata(roleName: string, sourceColumnsSortedByProjectionOrdering: DataViewMetadataColumn[], queryRefsToIgnore?: string[]): DataViewMetadataColumn {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\r\n            debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(c => c.isMeasure).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\r\n\r\n            let concatenatedDisplayName: string;\r\n\r\n            for (let columnSource of sourceColumnsSortedByProjectionOrdering) {\r\n                if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\r\n                    concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\r\n                }\r\n            }\r\n\r\n            let newRoles: { [name: string]: boolean } = {};\r\n            newRoles[roleName] = true;\r\n\r\n            let newColumnMetadata: DataViewMetadataColumn = {\r\n                displayName: concatenatedDisplayName,\r\n                roles: newRoles,\r\n                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)\r\n            };\r\n\r\n            let columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\r\n            if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\r\n                newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\r\n            }\r\n\r\n            // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\r\n            // If queryName is not set at all, the column chart visual will only render column for the first group instance.\r\n            // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\r\n            newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\r\n\r\n            return newColumnMetadata;\r\n        }\r\n\r\n        function addToMetadata(transformedDataView: DataView, newColumn: DataViewMetadataColumn): void {\r\n            debug.assertValue(transformedDataView, 'transformedDataView');\r\n            debug.assertValue(newColumn, 'newColumn');\r\n\r\n            let transformedColumns = inheritSingle(transformedDataView.metadata.columns);\r\n            transformedColumns.push(newColumn);\r\n\r\n            let transformedMetadata = inheritSingle(transformedDataView.metadata);\r\n            transformedMetadata.columns = transformedColumns;\r\n\r\n            transformedDataView.metadata = transformedMetadata;\r\n        }\r\n\r\n        function createConcatenatedCategoryColumn(\r\n            sourceColumnsSortedByProjectionOrdering: DataViewCategoryColumn[],\r\n            columnMetadata: DataViewMetadataColumn,\r\n            concatenatedValues: string[]): DataViewCategoryColumn {\r\n            debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let newCategoryColumn: DataViewCategoryColumn = {\r\n                source: columnMetadata,\r\n                values: concatenatedValues\r\n            };\r\n\r\n            // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\r\n            // So, we'll just take the identities and identityFields from the first column\r\n            let firstColumn = sourceColumnsSortedByProjectionOrdering[0];\r\n\r\n            if (firstColumn.identity) {\r\n                newCategoryColumn.identity = firstColumn.identity;\r\n            }\r\n\r\n            if (firstColumn.identityFields) {\r\n                newCategoryColumn.identityFields = firstColumn.identityFields;\r\n            }\r\n\r\n            // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\r\n            if (firstColumn.objects) {\r\n                newCategoryColumn.objects = firstColumn.objects;\r\n            }\r\n\r\n            return newCategoryColumn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export const enum RoleItemContext {\r\n        CategoricalValue,\r\n        CategoricalValueGroup,\r\n    }\r\n\r\n    export interface IDataViewMappingVisitor {\r\n        visitRole(role: string, context?: RoleItemContext): void;\r\n        visitReduction?(reductionAlgorithm?: ReductionAlgorithm): void;\r\n    }\r\n\r\n    export module DataViewMapping {\r\n        export function visitMapping(mapping: DataViewMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let categorical = mapping.categorical;\r\n            if (categorical)\r\n                visitCategorical(categorical, visitor);\r\n\r\n            let table = mapping.table;\r\n            if (table)\r\n                visitTable(table, visitor);\r\n\r\n            let matrix = mapping.matrix;\r\n            if (matrix)\r\n                visitMatrix(matrix, visitor);\r\n\r\n            let tree = mapping.tree;\r\n            if (tree)\r\n                visitTree(tree, visitor);\r\n            \r\n            let single = mapping.single;\r\n            if (single)\r\n                visitSingle(single, visitor);\r\n        }\r\n\r\n        export function visitCategorical(mapping: DataViewCategoricalMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitCategoricalCategories(mapping.categories, visitor);\r\n\r\n            visitCategoricalValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitCategoricalCategories(mapping: DataViewRoleMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitCategoricalValues(mapping: DataViewRoleMapping | DataViewGroupedRoleMapping | DataViewListRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n\r\n                let groupedRoleMapping = <DataViewGroupedRoleMapping>mapping;\r\n                visitGrouped(groupedRoleMapping, visitor);\r\n\r\n                let group = groupedRoleMapping.group;\r\n                if (group) {\r\n                    for (let item of group.select) {\r\n                        visitBind(<DataViewRoleBindMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                        visitFor(<DataViewRoleForMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitTable(mapping: DataViewTableMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let rows = mapping.rows;\r\n            visitBind(<DataViewRoleBindMapping>rows, visitor);\r\n            visitFor(<DataViewRoleForMapping>rows, visitor);\r\n            visitList(<DataViewListRoleMapping>rows, visitor);\r\n\r\n            visitReduction(rows, visitor);\r\n        }\r\n\r\n        function visitMatrix(mapping: DataViewMatrixMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitMatrixItems(mapping.rows, visitor);\r\n            visitMatrixItems(mapping.columns, visitor);\r\n            visitMatrixItems(mapping.values, visitor);\r\n        }\r\n\r\n        /**\r\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         *\r\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         * @param visitor The visitor.\r\n         */\r\n        export function visitMatrixItems(mapping: DataViewRoleForMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitTree(mapping: DataViewTreeMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitTreeNodes(mapping.nodes, visitor);\r\n            visitTreeValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitTreeNodes(mapping: DataViewRoleForMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitTreeValues(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitBind(mapping: DataViewRoleBindMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let bind = mapping.bind;\r\n            if (bind) {\r\n                if (context != null)\r\n                    visitor.visitRole(bind.to, context);\r\n                else\r\n                    visitor.visitRole(bind.to);\r\n            }\r\n        }\r\n\r\n        function visitFor(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let forValue = mapping.for;\r\n            if (forValue) {\r\n                if (context != null)\r\n                    visitor.visitRole(forValue.in, context);\r\n                else\r\n                    visitor.visitRole(forValue.in);\r\n            }\r\n        }\r\n\r\n        function visitList(mapping: DataViewListRoleMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let select = mapping.select;\r\n            if (select) {\r\n                for (let item of select) {\r\n                    visitBind(<DataViewRoleBindMapping>item, visitor, context);\r\n                    visitFor(<DataViewRoleForMapping>item, visitor, context);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitGrouped(mapping: DataViewGroupedRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (!mapping)\r\n                return;\r\n\r\n            let group = mapping.group;\r\n            if (group) {\r\n                visitor.visitRole(group.by);\r\n\r\n                visitReduction(group, visitor);\r\n            }\r\n        }\r\n\r\n        function visitReduction(mapping: HasReductionAlgorithm, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (visitor.visitReduction) {\r\n                let reductionAlgorithm = mapping.dataReductionAlgorithm;\r\n                if (reductionAlgorithm) {\r\n                    visitor.visitReduction(reductionAlgorithm);\r\n                }\r\n            }\r\n        }\r\n\r\n        function visitSingle(mapping: DataViewSingleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitor.visitRole(mapping.role);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inheritSingle = Prototype.inheritSingle;\r\n\r\n    export interface DataViewNormalizeValuesApplyOptions {\r\n        dataview: DataView;\r\n        dataViewMappings: DataViewMapping[];\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a column is tied to any role that has required type(s).\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns true iff the column in the specified columnIndex is tied to any role that has required type(s), i.e. if the value in that column potentially needs to get normalized.\r\n     */\r\n    export interface IMetadataColumnFilter {\r\n        (columnIndex: number): boolean;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff the specified value is of matching type as required by the role assigned to the column associated with this filter object.\r\n     */\r\n    export interface IColumnValueFilter {\r\n        (value: any): boolean;\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns false iff the specified value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     */\r\n    export interface IValueFilter {\r\n        (columnIndex: number, value: any): boolean;\r\n    }\r\n\r\n    export module DataViewNormalizeValues {\r\n        export function apply(options: DataViewNormalizeValuesApplyOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let rolesToNormalize = _.filter(options.dataRoles, role => !_.isEmpty(role.requiredTypes));\r\n\r\n            filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\r\n        }\r\n\r\n        export function filterVariantMeasures(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[]): void {\r\n            debug.assertValue(dataview, 'dataview');\r\n\r\n            // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\r\n                return;\r\n\r\n            let columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\r\n            let valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\r\n\r\n            let usedMappings = {};\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                // Get dataview specified in mappings which are also in dataview\r\n                for (let dataViewMappingProp in dataViewMapping) {\r\n                    if (dataview[dataViewMappingProp] != null)\r\n                        usedMappings[dataViewMappingProp] = true;\r\n                }\r\n            }\r\n\r\n            if (usedMappings['categorical'])\r\n                filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\r\n            if (usedMappings['table'])\r\n                filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\r\n            if (usedMappings['tree'])\r\n                filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\r\n            if (usedMappings['matrix'])\r\n                filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\r\n            if (usedMappings['single'])\r\n                filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\r\n        }\r\n\r\n        export function generateMetadataColumnFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IMetadataColumnFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => false;\r\n\r\n            let columnsToNormalize = {};\r\n            for (let column of columns) {\r\n                let roles = column.roles;\r\n                if (!roles)\r\n                    continue;\r\n                for (let role of rolesToNormalize) {\r\n                    if (!roles[role.name])\r\n                        continue;\r\n                    columnsToNormalize[column.index] = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return (columnIndex: number) => {\r\n                if (isNaN(columnIndex))\r\n                    return false;\r\n\r\n                return !!columnsToNormalize[columnIndex];\r\n            };\r\n        }\r\n\r\n        export function generateValueFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IValueFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => true;\r\n\r\n            let columnValueFilters: IColumnValueFilter[] = [];\r\n\r\n            // Build columnValueFilters based on role requiredTypes\r\n            for (let column of columns) {\r\n                let columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\r\n\r\n                if (columnValueFilter)\r\n                    columnValueFilters[column.index] = columnValueFilter;\r\n            }\r\n\r\n            return <IValueFilter>(columnIndex: number, value: any) => {\r\n                if (columnValueFilters[columnIndex])\r\n                    return columnValueFilters[columnIndex](value);\r\n\r\n                return true;\r\n            };\r\n        }\r\n\r\n        function generateColumnValueFilter(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): IColumnValueFilter {\r\n            let requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\r\n\r\n            if (_.isEmpty(requiredTypes))\r\n                return;\r\n\r\n            return (value: any): boolean => {\r\n                return doesValueMatchTypes(value, requiredTypes);\r\n            };\r\n        }\r\n\r\n        export function getColumnRequiredTypes(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): ValueType[] {\r\n            let requiredTypes = [];\r\n            let columnRoles = column && column.roles;\r\n\r\n            if (!columnRoles)\r\n                return requiredTypes;\r\n\r\n            for (let role of rolesToNormalize) {\r\n                if (!columnRoles[role.name])\r\n                    continue;\r\n                for (let typeDescriptor of role.requiredTypes) {\r\n                    let type = ValueType.fromDescriptor(typeDescriptor);\r\n                    requiredTypes.push(type);\r\n                }\r\n            }\r\n\r\n            return requiredTypes;\r\n        }\r\n\r\n        function filterVariantMeasuresCategorical(dataview: DataViewCategorical, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let values = dataview && dataview.values;\r\n            if (!values)\r\n                return;\r\n\r\n            let valuesGrouped = values.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            for (let valueGroup of valuesGrouped) {\r\n                let valuesInGroup = valueGroup.values;\r\n                for (let valueColumn of valuesInGroup) {\r\n                    let columnIndex = valueColumn.source.index;\r\n                    if (!columnFilter(columnIndex))\r\n                        continue;\r\n\r\n                    for (let i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\r\n                        valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTable(dataview: DataViewTable, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let columns = dataview && dataview.columns;\r\n\r\n            if (!columns)\r\n                return;\r\n\r\n            let filteredColumns = [];\r\n            for (let column of columns) {\r\n                if (columnFilter(column.index))\r\n                    filteredColumns.push(column.index);\r\n            }\r\n\r\n            let rows = dataview.rows;\r\n            for (let i = 0, ilen = rows.length; i < ilen; i++) {\r\n                for (let index of filteredColumns) {\r\n                    rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTreeNode(node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let columnIndex in node.values) {\r\n                    // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\r\n                    if (columnFilter(<any>columnIndex)) {\r\n                        // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\r\n                        if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\r\n                            node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', <any>columnIndex, valueFilter);\r\n                        else // if node.values[columnIndex] is a primitive value\r\n                            node.values = normalizeVariant(node.values, columnIndex, <any>columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresMatrix(dataview: DataViewMatrix, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let root = dataview && dataview.rows && dataview.rows.root;\r\n\r\n            if (!root)\r\n                return;\r\n\r\n            // Recurse into rows.children\r\n            // e.g. rows.children -> .children -> .children.values\r\n            filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\r\n        }\r\n\r\n        function filterVariantMeasuresMatrixRecursive(dataviewMatrix: DataViewMatrix, node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let id in node.values) {\r\n                    // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\r\n                    let nodeValue: DataViewMatrixNodeValue = node.values[id];\r\n\r\n                    // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\r\n                    let valueSourceIndex: number = nodeValue.valueSourceIndex || 0;\r\n\r\n                    // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\r\n                    let columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\r\n\r\n                    if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\r\n                        node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresSingle(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[], valueFilter: IValueFilter): void {\r\n            if (!dataview.single)\r\n                return;\r\n\r\n            let roleNames: string[] = [];\r\n            for (let role of rolesToNormalize) {\r\n                if (role.name)\r\n                    roleNames.push(role.name);\r\n            }\r\n\r\n            let columns = dataview.metadata.columns;\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                let roleName = dataViewMapping.single.role;\r\n                if (roleNames.indexOf(roleName) !== -1) {\r\n                    let column = firstColumnByRoleName(columns, roleName);\r\n                    if (column)\r\n                        dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        export function normalizeVariant<T>(object: T, key: string|number, columnIndex: number, valueFilter: IValueFilter): T {\r\n            if (!object)\r\n                return;\r\n\r\n            let value = object[key];\r\n            if (value !== null && !valueFilter(columnIndex, value)) {\r\n                object = inheritSingle(object);\r\n                object[key] = null;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        function doesValueMatchTypes<T>(value: T, types: ValueType[]): boolean {\r\n            for (let type of types) {\r\n                if (type.numeric || type.integer)\r\n                    return typeof (value) === 'number';\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function firstColumnByRoleName(columns: DataViewMetadataColumn[], roleName: string): DataViewMetadataColumn {\r\n            for (let column of columns) {\r\n                let columnRoles = column && column.roles;\r\n                if (columnRoles && columnRoles[roleName])\r\n                    return column;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewObjects {\r\n        /** Gets the value of the given object/property pair. */\r\n        export function getValue<T>(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultValue?: T): T {\r\n            debug.assertAnyValue(objects, 'objects');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            if (!objects)\r\n                return defaultValue;\r\n\r\n            let objectOrMap = objects[propertyId.objectName];\r\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\r\n\r\n            let object = <DataViewObject>objectOrMap;\r\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\r\n        }\r\n\r\n        /** Gets an object from objects. */\r\n        export function getObject(objects: DataViewObjects, objectName: string, defaultValue?: DataViewObject): DataViewObject {\r\n            if (objects && objects[objectName]) {\r\n                let object = <DataViewObject>objects[objectName];\r\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\r\n                return object;\r\n            }\r\n            else {\r\n                return defaultValue;\r\n            }\r\n        }\r\n\r\n        /** Gets a map of user-defined objects. */\r\n        export function getUserDefinedObjects(objects: DataViewObjects, objectName: string): DataViewObjectMap {\r\n            if (objects && objects[objectName]) {\r\n                let map = <DataViewObjectMap>objects[objectName];\r\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\r\n                return map;\r\n            }\r\n        }\r\n\r\n        /** Gets the solid color from a fill property. */\r\n        export function getFillColor(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultColor?: string): string {\r\n            let value: Fill = getValue(objects, propertyId);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n\r\n        /** Returns true if the given object represents a collection of user-defined objects */\r\n        export function isUserDefined(objectOrMap: DataViewObject | DataViewObjectMap): boolean {\r\n            return _.isArray(objectOrMap);\r\n        }\r\n    }\r\n\r\n    export module DataViewObject {\r\n        export function getValue<T>(object: DataViewObject, propertyName: string, defaultValue?: T): T {\r\n            debug.assertAnyValue(object, 'object');\r\n            debug.assertValue(propertyName, 'propertyName');\r\n\r\n            if (!object)\r\n                return defaultValue;\r\n\r\n            let propertyValue = <T>object[propertyName];\r\n            if (propertyValue === undefined)\r\n                return defaultValue;\r\n\r\n            return propertyValue;\r\n        }\r\n\r\n        /** Gets the solid color from a fill property using only a propertyName */\r\n        export function getFillColorByPropertyName(objects: DataViewObjects, propertyName: string, defaultColor?: string): string {\r\n            let value: Fill = DataViewObject.getValue(objects, propertyName);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import JsonComparer = jsCommon.JsonComparer;\r\n\r\n    /** Defines the values for particular objects. */\r\n    export interface DataViewObjectDefinitions {\r\n        [objectName: string]: DataViewObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinition {\r\n        selector?: Selector;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export interface DataViewObjectPropertyDefinitions {\r\n        [name: string]: DataViewObjectPropertyDefinition;\r\n    }\r\n\r\n    export type DataViewObjectPropertyDefinition = SQExpr | StructuralObjectDefinition;\r\n\r\n    export module DataViewObjectDefinitions {\r\n\r\n        /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\r\n        export function ensure(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                defns[objectName] = defnsForObject = [];\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n\r\n            let newDefn: DataViewObjectDefinition = {\r\n                selector: selector,\r\n                properties: {},\r\n            };\r\n            defnsForObject.push(newDefn);\r\n\r\n            return newDefn;\r\n        }\r\n\r\n        export function deleteProperty(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector,\r\n            propertyName: string): void {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defn = getObjectDefinition(defns, objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\r\n        }\r\n        \r\n        export function setValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n            debug.assertValue(defns, 'defns');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        export function getValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinition {\r\n\r\n            let properties = getPropertyContainer(defns, propertyId, selector);\r\n            if (!properties)\r\n                return;\r\n\r\n            return properties[propertyId.propertyName];\r\n        }\r\n\r\n        export function getPropertyContainer(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinitions {\r\n\r\n            let defn = getObjectDefinition(defns, propertyId.objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            return defn.properties;\r\n        }\r\n\r\n        export function getObjectDefinition(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertAnyValue(defns, 'defns');\r\n            debug.assertValue(objectName, 'objectName');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!defns)\r\n                return;\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                return;\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n        }\r\n\r\n        export function propertiesAreEqual(a: DataViewObjectPropertyDefinition, b: DataViewObjectPropertyDefinition): boolean {\r\n            if (a instanceof SemanticFilter && b instanceof SemanticFilter) {\r\n                return SemanticFilter.isSameFilter(<SemanticFilter>a, <SemanticFilter>b);\r\n            }\r\n\r\n            return JsonComparer.equals(a, b);\r\n        }\r\n\r\n        export function allPropertiesAreEqual(a: DataViewObjectPropertyDefinitions, b: DataViewObjectPropertyDefinitions): boolean {\r\n            debug.assertValue(a, 'a');\r\n            debug.assertValue(b, 'b');\r\n\r\n            if (Object.keys(a).length !== Object.keys(b).length)\r\n                return false;\r\n\r\n            for (let property in a) {\r\n                if (!propertiesAreEqual(a[property], b[property]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function encodePropertyValue(value: DataViewPropertyValue, valueTypeDescriptor: ValueTypeDescriptor): DataViewObjectPropertyDefinition {\r\n            debug.assertAnyValue(value, 'value');\r\n            debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\r\n\r\n            if (valueTypeDescriptor.bool) {\r\n                if (typeof (value) !== 'boolean')\r\n                    value = false; // This is fallback, which doesn't really belong here.\r\n\r\n                return SQExprBuilder.boolean(<boolean>value);\r\n            }\r\n            else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\r\n                return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.numeric) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).fill) {\r\n                if (value) {\r\n                    return {\r\n                        solid: { color: SQExprBuilder.text(<string>value) }\r\n                    };\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.formatting) {\r\n                if (valueTypeDescriptor.formatting.labelDisplayUnits) {\r\n                    return SQExprBuilder.double(+value);\r\n                }\r\n                else {\r\n                    return SQExprBuilder.text(<string>value);\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.enumeration) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n                else\r\n                    return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.misc) {\r\n                if (value) {\r\n                    value = SQExprBuilder.text(<string>value);\r\n                } else {\r\n                    value = null;\r\n                }\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).image) {\r\n                if (value) {\r\n                    let imageValue = <ImageValue>value;\r\n                    let imageDefinition: ImageDefinition = {\r\n                        name: SQExprBuilder.text(imageValue.name),\r\n                        url: SQExprBuilder.text(imageValue.url),\r\n                    };\r\n\r\n                    if (imageValue.scaling)\r\n                        imageDefinition.scaling = SQExprBuilder.text(imageValue.scaling);\r\n\r\n                    return imageDefinition;\r\n                }\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        export function clone(original: DataViewObjectDefinitions): DataViewObjectDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            let cloned: DataViewObjectDefinitions = {};\r\n\r\n            for (let objectName in original) {\r\n                let originalDefns = original[objectName];\r\n                if (_.isEmpty(originalDefns))\r\n                    continue;\r\n\r\n                let clonedDefns: DataViewObjectDefinition[] = [];\r\n                for (let originalDefn of originalDefns) {\r\n                    clonedDefns.push({\r\n                        properties: cloneProperties(originalDefn.properties),\r\n                        selector: originalDefn.selector,\r\n                    });\r\n                }\r\n                cloned[objectName] = clonedDefns;\r\n            }\r\n\r\n            return cloned;\r\n        }\r\n\r\n        function cloneProperties(original: DataViewObjectPropertyDefinitions): DataViewObjectPropertyDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\r\n            return _.clone(original);\r\n        }\r\n    }\r\n\r\n    export module DataViewObjectDefinition {\r\n\r\n        export function deleteSingleProperty(\r\n            defn: DataViewObjectDefinition,\r\n            propertyName: string): void {\r\n\r\n            //note: We decided that delete is acceptable here and that we don't need optimization here\r\n            delete defn.properties[propertyName];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module DataViewObjectDescriptors {\r\n        /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\r\n        export function findFormatString(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let formattingTypeDesc = ValueType.fromDescriptor(propDesc.type).formatting;\r\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\r\n        export function findFilterOutput(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && propType.filter && !propType.filter.selfFilter;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the self filter property. */\r\n        export function findSelfFilter(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && propType.filter && propType.filter.selfFilter;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the self filter enabled property. */\r\n        export function findSelfFilterEnabled(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: ValueTypeDescriptor = propDesc.type;\r\n                    return propType && propType.operations && propType.operations.searchEnabled;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\r\n        export function findDefaultValue(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.expression && propType.expression.defaultValue;\r\n                });\r\n        }\r\n\r\n        function findProperty(descriptors: DataViewObjectDescriptors, propPredicate: (propDesc: DataViewObjectPropertyDescriptor) => boolean): DataViewObjectPropertyIdentifier {\r\n            debug.assertAnyValue(descriptors, 'descriptors');\r\n            debug.assertAnyValue(propPredicate, 'propPredicate');\r\n\r\n            if (!descriptors)\r\n                return;\r\n\r\n            for (let objectName in descriptors) {\r\n                let objPropDescs = descriptors[objectName].properties;\r\n\r\n                for (let propertyName in objPropDescs) {\r\n                    if (propPredicate(objPropDescs[propertyName])) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n*  Power BI Visualizations\r\n*\r\n*  Copyright (c) Microsoft Corporation\r\n*  All rights reserved. \r\n *  MIT License\r\n*\r\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n*  in the Software without restriction, including without limitation the rights\r\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*  copies of the Software, and to permit persons to whom the Software is\r\n*  furnished to do so, subject to the following conditions:\r\n*   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n*   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n*  THE SOFTWARE.\r\n*/\r\n\r\nmodule powerbi.data {\r\n    export interface DataViewObjectDefinitionsByRepetition {\r\n        metadataOnce?: DataViewObjectDefinitionsForSelector;\r\n        userDefined?: DataViewObjectDefinitionsForSelector[];\r\n        metadata?: DataViewObjectDefinitionsForSelector[];\r\n        data: DataViewObjectDefinitionsForSelectorWithRule[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelector {\r\n        selector?: Selector;\r\n        objects: DataViewNamedObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelectorWithRule extends DataViewObjectDefinitionsForSelector {\r\n        rules?: RuleEvaluation[];\r\n    }\r\n\r\n    export interface DataViewNamedObjectDefinition {\r\n        name: string;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export module DataViewObjectEvaluationUtils {\r\n        export function evaluateDataViewObjects(\r\n            evalContext: IEvalContext,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewObjects {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let objects: DataViewObjects;\r\n\r\n            for (let j = 0, jlen = objectDefns.length; j < jlen; j++) {\r\n                let objectDefinition = objectDefns[j],\r\n                    objectName = objectDefinition.name;\r\n\r\n                let evaluatedObject: DataViewObject = DataViewObjectEvaluator.run(\r\n                    evalContext,\r\n                    objectDescriptors[objectName],\r\n                    objectDefinition.properties);\r\n\r\n                if (!evaluatedObject)\r\n                    continue;\r\n\r\n                if (!objects)\r\n                    objects = {};\r\n\r\n                // NOTE: this currently has last-object-wins semantics.\r\n                objects[objectName] = evaluatedObject;\r\n            }\r\n\r\n            return objects;\r\n        }\r\n\r\n        export function groupObjectsBySelector(objectDefinitions: DataViewObjectDefinitions): DataViewObjectDefinitionsByRepetition {\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n\r\n            let grouped: DataViewObjectDefinitionsByRepetition = {\r\n                data: [],\r\n            };\r\n\r\n            if (objectDefinitions) {\r\n                for (let objectName in objectDefinitions) {\r\n                    let objectDefnList = objectDefinitions[objectName];\r\n\r\n                    for (let i = 0, len = objectDefnList.length; i < len; i++) {\r\n                        let objectDefn = objectDefnList[i];\r\n\r\n                        ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\r\n                            name: objectName,\r\n                            properties: objectDefn.properties,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return grouped;\r\n        }\r\n\r\n        function ensureDefinitionListForSelector(grouped: DataViewObjectDefinitionsByRepetition, selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(grouped, 'grouped');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!selector) {\r\n                if (!grouped.metadataOnce)\r\n                    grouped.metadataOnce = { objects: [] };\r\n                return grouped.metadataOnce;\r\n            }\r\n\r\n            let groupedObjects: DataViewObjectDefinitionsForSelector[];\r\n            if (selector.data) {\r\n                groupedObjects = grouped.data;\r\n            }\r\n            else if (selector.metadata) {\r\n                if (!grouped.metadata)\r\n                    grouped.metadata = [];\r\n                groupedObjects = grouped.metadata;\r\n            }\r\n            else if (selector.id) {\r\n                if (!grouped.userDefined)\r\n                    grouped.userDefined = [];\r\n                groupedObjects = grouped.userDefined;\r\n            }\r\n\r\n            debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\r\n\r\n            for (let item of groupedObjects) {\r\n                if (Selector.equals(selector, item.selector))\r\n                    return item;\r\n            }\r\n\r\n            let item: DataViewObjectDefinitionsForSelector = {\r\n                selector: selector,\r\n                objects: [],\r\n            };\r\n            groupedObjects.push(item);\r\n\r\n            return item;\r\n        }\r\n\r\n        export function addImplicitObjects(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            if (selectTransforms) {\r\n                addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n                addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n            }\r\n        }\r\n\r\n        function addDefaultFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let formatStringProp = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            if (!formatStringProp)\r\n                return;\r\n\r\n            for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n                let selectTransform = selectTransforms[selectIdx];\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyFormatString(\r\n                    objectsForAllSelectors,\r\n                    formatStringProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\r\n            }\r\n        }\r\n\r\n        /** Registers properties for default value, if the properties are not explicitly provided. */\r\n        function addDefaultValue (\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let defaultValueProp = DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\r\n            if (!defaultValueProp)\r\n                return;\r\n\r\n            for (let selectTransform of selectTransforms) {\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyDefaultValue(\r\n                    objectsForAllSelectors,\r\n                    defaultValueProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.defaultValue);\r\n            }\r\n        }\r\n\r\n        function getColumnFormatForIndex(columns: DataViewMetadataColumn[], selectIdx: number): string {\r\n            for (let columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\r\n                let column = columns[columnIdx];\r\n                if (!column || column.index !== selectIdx)\r\n                    continue;\r\n\r\n                return column.format;\r\n            }\r\n        }\r\n\r\n        function applyFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            formatStringProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            formatStringValue: string): void {\r\n            if (!formatStringValue)\r\n                return;\r\n\r\n            // There is a format string specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                formatStringProp,\r\n                { metadata: queryName },\r\n                SQExprBuilder.text(formatStringValue));\r\n        }\r\n\r\n        function applyDefaultValue(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            defaultValueProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            defaultValue: DefaultValueDefinition): void {\r\n            if (!defaultValue)\r\n                return;\r\n\r\n            // There is a default value specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                defaultValueProp,\r\n                { metadata: queryName },\r\n                defaultValue);\r\n        }\r\n\r\n        function applyMetadataProperty(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n\r\n            let objectDefns: DataViewObjectDefinitionsForSelector[];\r\n            if (selector) {\r\n                let metadataObjects = objectsForAllSelectors.metadata;\r\n                if (!metadataObjects)\r\n                    metadataObjects = objectsForAllSelectors.metadata = [];\r\n                objectDefns = metadataObjects;\r\n            }\r\n            else {\r\n                let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n                if (!metadataOnce)\r\n                    metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\r\n                objectDefns = [metadataOnce];\r\n            }\r\n\r\n            let targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\r\n            let targetObjectDefn: DataViewNamedObjectDefinition;\r\n            if (targetMetadataObject) {\r\n                let targetObjectDefns = targetMetadataObject.objects;\r\n                targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\r\n                if (targetObjectDefn) {\r\n                    if (targetObjectDefn.properties[propertyId.propertyName])\r\n                        return;\r\n                }\r\n                else {\r\n                    targetObjectDefn = {\r\n                        name: propertyId.objectName,\r\n                        properties: {},\r\n                    };\r\n                    targetObjectDefns.push(targetObjectDefn);\r\n                }\r\n            }\r\n            else {\r\n                targetObjectDefn = {\r\n                    name: propertyId.objectName,\r\n                    properties: {}\r\n                };\r\n\r\n                objectDefns.push({\r\n                    selector: selector,\r\n                    objects: [targetObjectDefn],\r\n                });\r\n            }\r\n\r\n            targetObjectDefn.properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        function findWithMatchingSelector(objects: DataViewObjectDefinitionsForSelector[], selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(objects, 'objects');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            for (let i = 0, len = objects.length; i < len; i++) {\r\n                let object = objects[i];\r\n                if (Selector.equals(object.selector, selector))\r\n                    return object;\r\n            }\r\n        }\r\n\r\n        function findExistingObject(objectDefns: DataViewNamedObjectDefinition[], objectName: string): DataViewNamedObjectDefinition {\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(objectName, 'objectName');\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefn = objectDefns[i];\r\n\r\n                if (objectDefn.name === objectName)\r\n                    return objectDefn;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n \r\n\r\nmodule powerbi.data {\r\n    /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\r\n    export module DataViewObjectEvaluator {\r\n        const colorValueType: ValueType = ValueType.fromDescriptor({ formatting: { color: true } });\r\n        const numericType: ValueType = ValueType.fromDescriptor({ numeric: true });\r\n        const textType: ValueType = ValueType.fromDescriptor({ text: true });\r\n\r\n        export function run(\r\n            evalContext: IEvalContext,\r\n            objectDescriptor: DataViewObjectDescriptor,\r\n            propertyDefinitions: DataViewObjectPropertyDefinitions): DataViewObject {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\r\n            debug.assertValue(propertyDefinitions, 'propertyDefinitions');\r\n\r\n            if (!objectDescriptor)\r\n                return;\r\n\r\n            let object: DataViewObject,\r\n                propertyDescriptors = objectDescriptor.properties;\r\n            for (let propertyName in propertyDefinitions) {\r\n                let propertyDefinition = propertyDefinitions[propertyName],\r\n                    propertyDescriptor = propertyDescriptors[propertyName];\r\n\r\n                if (!propertyDescriptor)\r\n                    continue;\r\n\r\n                let propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\r\n                if (propertyValue === undefined)\r\n                    continue;\r\n\r\n                if (!object)\r\n                    object = {};\r\n                object[propertyName] = propertyValue;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        /** Note: Exported for testability */\r\n        export function evaluateProperty(\r\n            evalContext: IEvalContext,\r\n            propertyDescriptor: DataViewObjectPropertyDescriptor,\r\n            propertyDefinition: DataViewObjectPropertyDefinition): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(propertyDescriptor, 'propertyDescriptor');\r\n            debug.assertValue(propertyDefinition, 'propertyDefinition');\r\n\r\n            let structuralType = <StructuralTypeDescriptor>propertyDescriptor.type;\r\n            if (structuralType && structuralType.expression)\r\n                return propertyDefinition;\r\n\r\n            let value = evaluateValue(evalContext, <any>propertyDefinition, ValueType.fromDescriptor(propertyDescriptor.type));\r\n            if (value !== undefined || (propertyDefinition instanceof RuleEvaluation))\r\n                return value;\r\n\r\n            return evaluateFill(evalContext, <FillDefinition>propertyDefinition, structuralType)\r\n                || evaluateFillRule(evalContext, <FillRuleDefinition>propertyDefinition, structuralType)\r\n                || evaluateImage(evalContext, <ImageDefinition>propertyDefinition, structuralType)\r\n                || evaluateParagraphs(evalContext, <ParagraphsDefinition>propertyDefinition, structuralType)\r\n                || propertyDefinition;\r\n        }\r\n\r\n        function evaluateFill(evalContext: IEvalContext, fillDefn: FillDefinition, type: StructuralTypeDescriptor): Fill {\r\n            let fillType = type.fill;\r\n            if (!fillType)\r\n                return;\r\n\r\n            if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\r\n                return {\r\n                    solid: {\r\n                        color: evaluateValue(evalContext, fillDefn.solid.color, ValueType.fromExtendedType(ExtendedType.Color)),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateFillRule(evalContext: IEvalContext, fillRuleDefn: FillRuleDefinition, type: StructuralTypeDescriptor): FillRule {\r\n            if (!type.fillRule)\r\n                return;\r\n\r\n            if (fillRuleDefn.linearGradient2) {\r\n                let linearGradient2 = fillRuleDefn.linearGradient2;\r\n                return {\r\n                    linearGradient2: {\r\n                        min: evaluateColorStop(evalContext, linearGradient2.min),\r\n                        max: evaluateColorStop(evalContext, linearGradient2.max),\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (fillRuleDefn.linearGradient3) {\r\n                let linearGradient3 = fillRuleDefn.linearGradient3;\r\n                return {\r\n                    linearGradient3: {\r\n                        min: evaluateColorStop(evalContext, linearGradient3.min),\r\n                        mid: evaluateColorStop(evalContext, linearGradient3.mid),\r\n                        max: evaluateColorStop(evalContext, linearGradient3.max),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateColorStop(evalContext: IEvalContext, colorStop: RuleColorStopDefinition): RuleColorStop {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(colorStop, 'colorStop');\r\n\r\n            let step: RuleColorStop = {\r\n                color: evaluateValue(evalContext, colorStop.color, colorValueType),\r\n            };\r\n\r\n            let value = evaluateValue(evalContext, colorStop.value, numericType);\r\n            if (value != null)\r\n                step.value = value;\r\n\r\n            return step;\r\n        }\r\n\r\n        function evaluateImage(evalContext: IEvalContext, definition: ImageDefinition, type: StructuralTypeDescriptor): ImageValue {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.image || !definition)\r\n                return;\r\n\r\n            let value: ImageValue = {\r\n                name: evaluateValue(evalContext, definition.name, textType),\r\n                url: evaluateValue(evalContext, definition.url, ValueType.fromDescriptor(ImageDefinition.urlType)),\r\n            };\r\n\r\n            if (definition.scaling)\r\n                value.scaling = evaluateValue(evalContext, definition.scaling, textType);\r\n\r\n            return value;\r\n        }\r\n\r\n        function evaluateParagraphs(evalContext: IEvalContext, definition: ParagraphsDefinition, type: StructuralTypeDescriptor): Paragraphs {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.paragraphs || !definition)\r\n                return;\r\n\r\n            return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\r\n        }\r\n\r\n        function evaluateParagraph(evalContext: IEvalContext, definition: ParagraphDefinition): Paragraph {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: Paragraph;\r\n\r\n            let definitionTextRuns = definition.textRuns;\r\n            let evaluatedTextRuns: TextRun[] = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\r\n            if (definitionTextRuns !== evaluatedTextRuns) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.textRuns = evaluatedTextRuns;\r\n            }\r\n\r\n            return evaluated || <Paragraph>definition;\r\n        }\r\n\r\n        function evaluateTextRun(evalContext: IEvalContext, definition: TextRunDefinition): TextRun {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: TextRun;\r\n\r\n            let definitionValue = definition.value;\r\n            let evaluatedValue = evaluateValue(evalContext, <any> definitionValue, textType);\r\n            if (evaluatedValue !== undefined) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.value = evaluatedValue;\r\n            }\r\n\r\n            return evaluated || <TextRun>definition;\r\n        }\r\n\r\n        /**\r\n         * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\r\n         * other than the input to it.\r\n         */\r\n        function evaluateArrayCopyOnChange<TDefinition, TEvaluated>(\r\n            evalContext: IEvalContext,\r\n            definitions: TDefinition[],\r\n            evaluator: (ctx: IEvalContext, defn: TDefinition) => TEvaluated): TEvaluated[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definitions, 'definitions');\r\n            debug.assertValue(evaluator, 'evaluator');\r\n\r\n            let evaluatedValues: TEvaluated[];\r\n\r\n            for (let i = 0, len = definitions.length; i < len; i++) {\r\n                let definition = definitions[i];\r\n                let evaluated: TEvaluated = evaluator(evalContext, definition);\r\n\r\n                // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\r\n                // between TEvaluated & TDefinition\r\n                if (!evaluatedValues && <any>definition !== evaluated) {\r\n                    evaluatedValues = _.take(<TEvaluated[]><any>definitions, i);\r\n                }\r\n\r\n                if (evaluatedValues) {\r\n                    evaluatedValues.push(evaluated);\r\n                }\r\n            }\r\n\r\n            return evaluatedValues || <TEvaluated[]><any>definitions;\r\n        }\r\n\r\n        function evaluateValue(evalContext: IEvalContext, definition: SQExpr | RuleEvaluation, valueType: ValueType): any {\r\n            if (definition instanceof SQExpr)\r\n                return ExpressionEvaluator.evaluate(definition, evalContext);\r\n\r\n            if (definition instanceof RuleEvaluation)\r\n                return definition.evaluate(evalContext);\r\n        }\r\n\r\n        /** Responsible for evaluating SQExprs into values. */\r\n        class ExpressionEvaluator extends DefaultSQExprVisitorWithArg<PrimitiveValue, IEvalContext> {\r\n            private static instance: ExpressionEvaluator = new ExpressionEvaluator();\r\n\r\n            public static evaluate(expr: SQExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                if (expr == null)\r\n                    return;\r\n\r\n                return expr.accept(ExpressionEvaluator.instance, evalContext);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return expr.value;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitFillRule(expr: SQFillRuleExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                let inputValue = expr.input.accept(this, evalContext);\r\n                if (inputValue !== undefined) {\r\n                    let colorAllocator = evalContext.getColorAllocator(expr);\r\n                    if (colorAllocator) {\r\n                        return colorAllocator.color(inputValue);\r\n                    }\r\n                }\r\n            }\r\n\r\n            public visitSelectRef(expr: SQSelectRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n        }\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n\r\n    export module DataViewPivotCategorical {\r\n        /**\r\n         * Pivots categories in a categorical DataView into valueGroupings.\r\n         * This is akin to a mathematical matrix transpose.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return null;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return null;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values) || values.source)\r\n                return null;\r\n\r\n            let category = categories[0],\r\n                categoryIdentities = category.identity,\r\n                categoryValues = category.values,\r\n                pivotedColumns: DataViewMetadataColumn[] = [],\r\n                pivotedValues: DataViewValueColumn[] = [];\r\n            for (let rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\r\n                let categoryValue = categoryValues[rowIdx],\r\n                    categoryIdentity = categoryIdentities[rowIdx];\r\n                for (let colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\r\n                    let value = values[colIdx],\r\n                        pivotedColumn = inherit(value.source);\r\n\r\n                    // A value has a series group, which is not implemented for pivoting -- just give up.\r\n                    if (value.identity)\r\n                        return null;\r\n\r\n                    pivotedColumn.groupName = categoryValue;\r\n                    let pivotedValue: DataViewValueColumn = {\r\n                        source: pivotedColumn,\r\n                        values: [value.values[rowIdx]],\r\n                        identity: categoryIdentity,\r\n                        min: value.min,\r\n                        max: value.max,\r\n                        subtotal: value.subtotal\r\n                    };\r\n\r\n                    let highlights = value.highlights;\r\n                    if (highlights) {\r\n                        pivotedValue.highlights = [highlights[rowIdx]];\r\n                    }\r\n\r\n                    pivotedColumns.push(pivotedColumn);\r\n                    pivotedValues.push(pivotedValue);\r\n                }\r\n            }\r\n\r\n            let pivotedMetadata = inherit(dataView.metadata);\r\n            pivotedMetadata.columns = pivotedColumns;\r\n\r\n            values = DataViewTransform.createValueColumns(pivotedValues, <SQExpr[]>category.identityFields, category.source);\r\n            return {\r\n                metadata: pivotedMetadata,\r\n                categorical: {\r\n                    values: values,\r\n                },\r\n                matrix: dataView.matrix\r\n            };\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewPivotMatrix {\r\n        /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\r\n        export function apply(dataViewMatrix: DataViewMatrix, context: MatrixTransformationContext): void {\r\n            debug.assertValue(dataViewMatrix, 'dataViewMatrix');\r\n\r\n            if (!context.columnHierarchyRewritten)\r\n                dataViewMatrix.columns = Prototype.inherit(dataViewMatrix.columns);\r\n            let columns = dataViewMatrix.columns;\r\n\r\n            if (!context.rowHierarchyRewritten)\r\n                dataViewMatrix.rows = Prototype.inherit(dataViewMatrix.rows);\r\n            let rows = dataViewMatrix.rows;\r\n\r\n            if (columns.levels.length > 1)\r\n                return;\r\n\r\n            let pivotedRowNode: DataViewMatrixNode = {\r\n                level: 0\r\n            };\r\n\r\n            let columnLeafNodes: DataViewMatrixNode[] = columns.root.children;\r\n            let measureCount = columnLeafNodes.length;\r\n\r\n            // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\r\n            // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\r\n            // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \r\n            // in a matrix with 2+ column fields and 2+ measure fields.\r\n            // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\r\n            // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\r\n            let pivotResultMeasureHeaderLevel = rows.levels.length;\r\n\r\n            if (measureCount > 0) {\r\n                let index = 0;\r\n                let callback = function (node: DataViewMatrixNode) {\r\n                    // Collect values and remove them from row leaves\r\n                    if (node.values) {\r\n                        if (!pivotedRowNode.values)\r\n                            pivotedRowNode.values = {};\r\n\r\n                        for (let i = 0; i < measureCount; i++)\r\n                            pivotedRowNode.values[index++] = node.values[i];\r\n\r\n                        delete node.values;\r\n                    }\r\n\r\n                    // Create measure headers if there are more than one measures\r\n                    if (measureCount > 1) {\r\n                        if (!node.children)\r\n                            node.children = [];\r\n\r\n                        for (let j = 0; j < measureCount; j++) {\r\n                            let measureHeaderLeaf: DataViewMatrixNode = { level: pivotResultMeasureHeaderLevel };\r\n\r\n                            // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\r\n                            let columnLeafNode = columnLeafNodes[j];\r\n                            measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\r\n\r\n                            if (node.isSubtotal)\r\n                                measureHeaderLeaf.isSubtotal = true;\r\n\r\n                            node.children.push(measureHeaderLeaf);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                if (context.hierarchyTreesRewritten) {\r\n                    forEachLeaf(rows.root, callback);\r\n                }\r\n                else {\r\n                    dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\r\n                }\r\n            }\r\n            else {\r\n                if (!context.hierarchyTreesRewritten) {\r\n                    dataViewMatrix.columns.root = cloneTree(rows.root);\r\n                }\r\n            }\r\n\r\n            if (measureCount > 1) {\r\n                // Keep measure headers, but move them to the innermost level\r\n                let level: DataViewHierarchyLevel = { sources: columns.levels[0].sources };\r\n                rows.levels.push(level);\r\n\r\n                columns.levels.length = 0;\r\n            }\r\n\r\n            if (context.hierarchyTreesRewritten) {\r\n                dataViewMatrix.columns.root = rows.root;\r\n                dataViewMatrix.rows.root = {\r\n                    children: [pivotedRowNode]\r\n                };\r\n            }\r\n            else {\r\n                let updatedRowRoot = Prototype.inherit(dataViewMatrix.rows.root);\r\n                updatedRowRoot.children = [pivotedRowNode];\r\n                dataViewMatrix.rows.root = updatedRowRoot;\r\n            }\r\n\r\n            dataViewMatrix.columns.levels = rows.levels;\r\n            dataViewMatrix.rows.levels = [];\r\n        }\r\n\r\n        function forEachLeaf(root: DataViewMatrixNode, callback: (node: DataViewMatrixNode) => void): void {\r\n            let children = root.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachLeaf(children[i], callback);\r\n\r\n                return;\r\n            }\r\n\r\n            callback(root);\r\n        }\r\n\r\n        export function cloneTree(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            return cloneTreeExecuteOnLeaf(node);\r\n        }\r\n\r\n        export function cloneTreeExecuteOnLeaf(node: DataViewMatrixNode, callback?: (node: DataViewMatrixNode) => void): DataViewMatrixNode {\r\n            let updatedNode = Prototype.inherit(node);\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                let newChildren: DataViewTreeNode[] = [];\r\n\r\n                for (let i = 0, ilen = children.length; i < ilen; i++) {\r\n                    let updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\r\n                    newChildren.push(updatedChild);\r\n                }\r\n                updatedNode.children = newChildren;\r\n            }\r\n            else {\r\n                if (callback)\r\n                    callback(updatedNode);\r\n            }\r\n\r\n            return updatedNode;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewSelfCrossJoin {\r\n        /**\r\n         * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\r\n         * to itself as a value grouping.\r\n         * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            if (!dataView.categorical)\r\n                return;\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\r\n                return;\r\n            if (dataViewCategorical.values && dataViewCategorical.values.source)\r\n                return;\r\n\r\n            return applyCategorical(dataView.metadata, dataViewCategorical);\r\n        }\r\n\r\n        function applyCategorical(dataViewMetadata: DataViewMetadata, dataViewCategorical: DataViewCategorical): DataView {\r\n            debug.assertValue(dataViewMetadata, 'dataViewMetadata');\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\r\n\r\n            let category = dataViewCategorical.categories[0],\r\n                categoryValues = category.values,\r\n                categoryLength = categoryValues.length;\r\n\r\n            if (categoryLength === 0)\r\n                return;\r\n\r\n            let valuesArray: DataViewValueColumn[] = dataViewCategorical.values\r\n                ? dataViewCategorical.values.grouped()[0].values\r\n                : [];\r\n            let transformedDataView = createCategoricalDataViewBuilder()\r\n                .withCategories(dataViewCategorical.categories)\r\n                .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\r\n                .build();\r\n\r\n            dataViewMetadata = Prototype.inherit(dataViewMetadata);\r\n            dataViewMetadata.columns = transformedDataView.metadata.columns;\r\n\r\n            return {\r\n                metadata: dataViewMetadata,\r\n                categorical: transformedDataView.categorical,\r\n            };\r\n        }\r\n\r\n        function createGroupedValues(\r\n            category: DataViewCategoryColumn,\r\n            categoryValues: any[],\r\n            categoryLength: number,\r\n            valuesArray: DataViewValueColumn[]): DataViewBuilderGroupedValuesOptions {\r\n            debug.assertValue(category, 'category');\r\n            debug.assertValue(categoryValues, 'categoryValues');\r\n            debug.assertValue(categoryLength, 'categoryLength');\r\n            debug.assertValue(valuesArray, 'valuesArray');\r\n\r\n            let nullValuesArray: any[] = createNullValues(categoryLength),\r\n                valuesArrayLen = valuesArray.length,\r\n                seriesData: DataViewBuilderSeriesData[][] = [];\r\n\r\n            for (let i = 0; i < categoryLength; i++) {\r\n                let seriesDataItem: DataViewBuilderSeriesData[] = [];\r\n\r\n                for (let j = 0; j < valuesArrayLen; j++) {\r\n                    let originalValueColumn = valuesArray[j],\r\n                        originalHighlightValues = originalValueColumn.highlights;\r\n\r\n                    let seriesDataItemCategory: DataViewBuilderSeriesData = {\r\n                        values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\r\n                    };\r\n                    if (originalHighlightValues)\r\n                        seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\r\n\r\n                    seriesDataItem.push(seriesDataItemCategory);\r\n                }\r\n\r\n                seriesData.push(seriesDataItem);\r\n            }\r\n\r\n            return {\r\n                groupColumn: {\r\n                    source: category.source,\r\n                    identityFrom: { fields: <SQExpr[]>category.identityFields, identities: category.identity },\r\n                    values: category.values,\r\n                },\r\n                valueColumns: _.map(valuesArray, v => <DataViewBuilderColumnOptions>{ source: v.source }),\r\n                data: seriesData,\r\n            };\r\n        }\r\n    }\r\n\r\n    function createNullValues(length: number): any[] {\r\n        debug.assertValue(length, 'length');\r\n\r\n        let array = new Array(length);\r\n        for (let i = 0; i < length; i++)\r\n            array[i] = null;\r\n        return array;\r\n    }\r\n\r\n    function inheritArrayWithValue(nullValues: any[], original: any[], index: number): any[] {\r\n        let inherited = Prototype.inherit(nullValues);\r\n        inherited[index] = original[index];\r\n\r\n        return inherited;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\r\n    import inheritSingle = powerbi.Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export module DataViewPivotCategoricalToPrimaryGroups {\r\n\r\n        /**\r\n         * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\r\n         * pivot the secondary before the primary.\r\n         */\r\n        export function pivotBinding(binding: DataShapeBinding, allMappings: CompiledDataViewMapping[], finalMapping: CompiledDataViewMapping, defaultDataVolume: number): void {\r\n            // unpivot is inferred from result in DataViewTransform.apply but it does not have the\r\n            // compiled mappings available, let alone the merged mapping, only the original\r\n            // DataViewMappings. to keep that inference easy, only apply pivot when there's\r\n            // only one matching mapping\r\n            if (!allMappings || allMappings.length !== 1)\r\n                return;\r\n\r\n            if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\r\n                return;\r\n\r\n            if (!binding)\r\n                return;\r\n\r\n            if (!canPivotCategorical(binding, finalMapping))\r\n                return;\r\n\r\n            // pivot secondary onto front of primary\r\n            binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\r\n\r\n            binding.Secondary = undefined;\r\n        \r\n            // set primary to pivot reduction\r\n            binding.DataReduction = {\r\n                Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\r\n                DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\r\n            };\r\n        }\r\n\r\n        /** narrowly targets scatter chart scenario for now to keep code simple */\r\n        function isPivotableAxis(axis: powerbi.data.DataShapeBindingAxis): boolean {\r\n            return axis\r\n                && axis.Groupings\r\n                && axis.Groupings.length === 1\r\n                && !_.isEmpty(axis.Groupings[0].Projections)\r\n                && !axis.Groupings[0].Subtotal\r\n                && _.isEmpty(axis.Groupings[0].SuppressedProjections);\r\n        }\r\n\r\n        function canPivotCategorical(binding: DataShapeBinding, mapping: CompiledDataViewMapping): boolean {\r\n            if (!isPivotableAxis(binding.Primary))\r\n                return false;\r\n            if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\r\n                return false;\r\n\r\n            // don't pivot if either axis has a data reduction\r\n            if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        export function unpivotResult(oldDataView: DataView, selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\r\n                return oldDataView;\r\n\r\n            // This returns a subsetted version of the DataView rather than using prototypal inheritance because\r\n            // any dataviews in the old one (including ones invented after this code is written) will correspond\r\n            // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\r\n            // querying code made.\r\n            let newDataView: DataView = {\r\n                metadata: {\r\n                    columns: ArrayExtensions.copy(oldDataView.metadata.columns),\r\n                },\r\n            };\r\n            \r\n            // preserve view types that aren't affected by pivoting\r\n            if (oldDataView.single)\r\n                newDataView.single = oldDataView.single;\r\n            if (oldDataView.table)\r\n                newDataView.table = oldDataView.table;\r\n\r\n            // other views are derived from matrix\r\n            if (oldDataView.matrix) {\r\n                let newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\r\n\r\n                // categorical only if there's data\r\n                if (!_.isEmpty(newDataViewMatrix.valueSources)) {\r\n                    // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \r\n                    // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\r\n                    // this.canPivotCategorical() would have returned false in the first place for this query.\r\n                    let hasCompositeGroupInSeries = utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\r\n                    if (!hasCompositeGroupInSeries) {\r\n                        newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return newDataView;\r\n        }\r\n\r\n        /**\r\n         * Infer from the query result and the visual mappings whether the query was pivoted.\r\n         * Narrowly targets scatter chart scenario for now to keep code simple\r\n         */\r\n        function inferUnpivotTransform(selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], dataView: DataView, projectionActiveItems: DataViewProjectionActiveItems): boolean {\r\n            if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\r\n                return false;\r\n\r\n            // select applicable mappings based on select roles\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\r\n            let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let supportedDataViewMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\r\n            if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\r\n                return false;\r\n\r\n            let categoricalMapping = supportedDataViewMappings[0].categorical;\r\n            if (!categoricalMapping)\r\n                return false;\r\n\r\n            // pivoted query will have produced a matrix\r\n            let matrixDataview = dataView.matrix;\r\n            if (!matrixDataview)\r\n                return false;\r\n\r\n            // matrix must have two levels of grouping\r\n            if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\r\n                return false;\r\n            \r\n            // get category and value grouping roles\r\n            let categoryGroups: string[] = [];\r\n            let valueGroups: string[] = [];\r\n\r\n            let addGroupingRole = (roleName: string, groups: string[]) => {\r\n                let roleProjections: QueryProjectionCollection = projections[roleName];\r\n                if (!roleProjections)\r\n                    return;\r\n\r\n                for (let roleProjection of roleProjections.all()) {\r\n                    if (roleKinds[roleProjection.queryRef] === VisualDataRoleKind.Grouping)\r\n                        groups.push(roleProjection.queryRef);\r\n                }\r\n            };\r\n\r\n            DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, categoryGroups); }\r\n            });\r\n\r\n            DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, valueGroups); }\r\n            });\r\n\r\n            // need both for pivot to have been done\r\n            if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\r\n                return false;\r\n\r\n            // if there was a pivot, there won't be any measures left in the columns\r\n            for (let level of matrixDataview.columns.levels) {\r\n                for (let source of level.sources) {\r\n                    if (!source.isMeasure)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        interface DataViewMatrixNodeValues {\r\n            [id: number]: DataViewMatrixNodeValue;\r\n        }\r\n\r\n        /**\r\n         * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\r\n         * this function changes that so that the categories become the rows and the series the columns.\r\n         */\r\n        function unpivotMatrix(oldMatrix: DataViewMatrix): DataViewMatrix {\r\n            let oldRows = oldMatrix.rows;\r\n            let oldRoot = oldRows.root;\r\n            let oldChildren = oldRoot.children;\r\n\r\n            // series are the outer grouping\r\n            let series: DataViewMatrixNode[] = [];\r\n            let seriesIdLevel = oldRows.levels[0];\r\n            let seriesIdFields = oldRoot.childIdentityFields;\r\n\r\n            // categories are the inner grouping. \r\n            let categoryIndex: _.Dictionary<number> = {};\r\n            let categories: DataViewMatrixNode[] = [];\r\n            let categoryIdLevel = oldRows.levels[1];\r\n            let categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\r\n\r\n            let measureCount = oldMatrix.valueSources.length;\r\n\r\n            // within each series value, the category list may not be complete so cannot simply use the inner loop index\r\n            // to reference it.\r\n            let findCategory = (identity: DataViewScopeIdentity) => {\r\n                let index = categoryIndex[identity.key];\r\n\r\n                debug.assert(index !== undefined, \"findcat() !== undefined\");\r\n\r\n                return index;\r\n            };\r\n\r\n            // collect series and categories from the row hierarchy\r\n            if (oldChildren) {\r\n                let addCategory = (categoryNode: DataViewMatrixNode) => {\r\n                    let key = categoryNode.identity.key;\r\n                    let index = categoryIndex[key];\r\n                    if (index === undefined) {\r\n                        index = categories.length;\r\n                        categoryIndex[key] = index;\r\n                        categories.push(categoryNode);\r\n                    }\r\n                };\r\n\r\n                for (let seriesNode of oldChildren) {\r\n                    series.push(seriesNode);\r\n\r\n                    for (let categoryNode of seriesNode.children) {\r\n                        addCategory(categoryNode);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // extract intersection values from pivoted matrix\r\n            // values will be indexed by categories then series\r\n            let matrixValues: DataViewMatrixNodeValues[][] = new Array<DataViewMatrixNodeValues[]>(categories.length);\r\n            for (let j = 0; j < series.length; ++j) { // outer is series\r\n                let seriesNode = oldChildren[j];\r\n                for (let categoryNode of seriesNode.children) { // inner is categories but maybe a subset\r\n                    let i = findCategory(categoryNode.identity); // must lookup actual category index\r\n\r\n                    if (!matrixValues[i])\r\n                        matrixValues[i] = new Array<DataViewMatrixNodeValues>(series.length);\r\n\r\n                    matrixValues[i][j] = categoryNode.values;\r\n                }\r\n            }\r\n\r\n            // columns of the unpivoted matrix are the series\r\n            let newColumns: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(series, s => {\r\n                        let inheritedNode = inheritSingle(s);\r\n                        inheritedNode.level = 0; // s.level should already be 0, but just in case...\r\n                        inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\r\n                        inheritedNode.childIdentityFields = undefined;\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: seriesIdFields,\r\n                },\r\n                levels: [\r\n                    seriesIdLevel,\r\n                    \r\n                ],\r\n            };\r\n\r\n            // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\r\n            if (measureCount > 0) {\r\n                let newColChildren: DataViewMatrixNode[] = _.map(oldMatrix.columns.root.children, (srcnode: DataViewMatrixNode) => {\r\n                    let dstnode: DataViewMatrixNode = { level: 1 };\r\n                    if (srcnode.levelSourceIndex)\r\n                        dstnode.levelSourceIndex = srcnode.levelSourceIndex;\r\n                    return dstnode;\r\n                });\r\n\r\n                for (let i = 0; i < newColumns.root.children.length; ++i)\r\n                    newColumns.root.children[i].children = newColChildren;\r\n\r\n                newColumns.levels.push(oldMatrix.columns.levels[0]);\r\n            }\r\n\r\n            // rows of the unpivoted matrix are the categories\r\n            let newRows: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(categories, c => {\r\n                        let inheritedNode = inheritSingle(c);\r\n                        inheritedNode.level = 0;\r\n                        inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\r\n                        inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: categoryIdFields,\r\n                },\r\n                levels: [\r\n                    categoryIdLevel,\r\n                ],\r\n            };\r\n\r\n            // put values into rows\r\n            if (measureCount > 0) {\r\n                for (let i = 0; i < categories.length; ++i) {\r\n                    let row = newRows.root.children[i];\r\n                    let rowValues: DataViewMatrixNodeValues = {};\r\n\r\n                    for (let j = 0; j < series.length; ++j) {\r\n                        let mvalues = matrixValues[i] && matrixValues[i][j];\r\n                        for (let k = 0; k < measureCount; ++k) {\r\n                            let l = j * measureCount + k;\r\n                            rowValues[l] = !mvalues\r\n                                ? ( k === 0 ? { value: null } : { value: null, valueSourceIndex: k } )\r\n                                : mvalues[k];\r\n                        }\r\n                    }\r\n\r\n                    row.values = rowValues;\r\n                }\r\n            }\r\n\r\n            let newMatrix: DataViewMatrix = {\r\n                rows: newRows,\r\n                columns: newColumns,\r\n                valueSources: oldMatrix.valueSources,\r\n            };\r\n\r\n            return newMatrix;\r\n        }\r\n\r\n        /** build a categorical data view from an unpivoted matrix. */\r\n        function categoricalFromUnpivotedMatrix(matrix: DataViewMatrix, columnMetadata: DataViewMetadataColumn[]): DataViewCategorical {\r\n            let seriesCount = matrix.columns.root.children.length;\r\n            let measureMetadata = matrix.valueSources;\r\n            let measureCount = measureMetadata.length;\r\n\r\n            let categories: DataViewCategoryColumn[] = createCategoryColumnsFromUnpivotedMatrix(matrix);\r\n\r\n            // create grouped values\r\n            let groups: DataViewValueColumnGroup[] = [];\r\n            for (let j = 0; j < seriesCount; ++j) {\r\n                let seriesColumn = matrix.columns.root.children[j];\r\n                let group: DataViewValueColumnGroup = {\r\n                    values: [],\r\n                    identity: seriesColumn.identity,\r\n                    name: seriesColumn.value || null,\r\n                };\r\n\r\n                groups.push(group);\r\n\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    let valueColumnMetadataSrc = measureMetadata[k];\r\n                    let valueColumnMetadataDst: DataViewMetadataColumn = <DataViewMetadataColumn>{};\r\n                    for (let key in valueColumnMetadataSrc)\r\n                        valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\r\n                    valueColumnMetadataDst.groupName = group.name;\r\n\r\n                    columnMetadata.push(valueColumnMetadataDst);\r\n\r\n                    let valueColumn: DataViewValueColumn = {\r\n                        source: valueColumnMetadataDst,\r\n                        values: [],\r\n                        identity: group.identity,\r\n                    };\r\n\r\n                    group.values.push(valueColumn);\r\n\r\n                    // grab measure values in the group from across rows of matrix\r\n                    let index = k + j * measureCount;\r\n\r\n                    for (let categoryNode of matrix.rows.root.children) {\r\n                        let value = categoryNode.values[index].value;\r\n\r\n                        valueColumn.values.push(value);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // and now ungrouped\r\n            let values: DataViewValueColumns = <DataViewValueColumns>[];\r\n            for (let group of groups) {\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    values.push(group.values[k]);\r\n                }\r\n            }\r\n\r\n            values.grouped = () => groups;\r\n            values.identityFields = matrix.columns.root.childIdentityFields;\r\n            values.source = matrix.columns.levels[0].sources[0];\r\n\r\n            // final assembly\r\n            let categorical: DataViewCategorical = {\r\n                categories: categories,\r\n                values: values,\r\n            };\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix: DataViewMatrix): DataViewCategoryColumn[] {\r\n            debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\r\n            debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1),\r\n                'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\r\n\r\n            // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \r\n            // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \r\n            // same amongst the resulting DataViewCategoryColumns.\r\n            let categoryIdentity = _.map(unpivotedMatrix.rows.root.children, x => x.identity);\r\n            let categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\r\n            let categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\r\n\r\n            let categories: DataViewCategoryColumn[] = [];\r\n            for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\r\n                let groupLevelValues = _.map(unpivotedMatrix.rows.root.children, (categoryNode: DataViewMatrixNode) => {\r\n                    let levelValues: DataViewMatrixGroupValue[] = categoryNode.levelValues;\r\n\r\n                    // Please refer to the interface comments on when this is undefined... But in today's code\r\n                    // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \r\n                    if (levelValues !== undefined) {\r\n                        debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i),\r\n                            'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\r\n                        return levelValues[i].value;\r\n                    }\r\n                });\r\n\r\n                categories.push({\r\n                    source: categorySourceColumns[i],\r\n                    values: groupLevelValues,\r\n                    identity: categoryIdentity,\r\n                    identityFields: categoryIdentityFields,\r\n                });\r\n            }\r\n\r\n            return categories;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n    import INumberDictionary = jsCommon.INumberDictionary;\r\n\r\n    export interface DataViewTransformApplyOptions {\r\n        prototype: DataView;\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        dataViewMappings?: DataViewMapping[];\r\n        transforms: DataViewTransformActions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /** Describes the Transform actions to be done to a prototype DataView. */\r\n    export interface DataViewTransformActions {\r\n        /** Describes transform metadata for each semantic query select item, as the arrays align, by index. */\r\n        selects?: DataViewSelectTransform[];\r\n\r\n        /** Describes the DataViewObject definitions. */\r\n        objects?: DataViewObjectDefinitions;\r\n\r\n        /** Describes the splitting of a single input DataView into multiple DataViews. */\r\n        splits?: DataViewSplitTransform[];\r\n\r\n        /** Describes the projection metadata which includes projection ordering and active items. */\r\n        roles?: DataViewRoleTransformMetadata;\r\n    }\r\n\r\n    export interface DataViewSplitTransform {\r\n        selects: INumberDictionary<boolean>;\r\n    }\r\n\r\n    export interface DataViewProjectionOrdering {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItemInfo {\r\n        queryRef: string;\r\n\r\n        /** Describes if the active item should be ignored in concatenation.\r\n            If the active item has a drill filter, it will not be used in concatenation.\r\n            If the value of suppressConcat is true, the activeItem will be ommitted from concatenation. */\r\n        suppressConcat?: boolean;\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItems {\r\n        [roleName: string]: DataViewProjectionActiveItemInfo[];\r\n    }\r\n\r\n    export interface DataViewRoleTransformMetadata {\r\n        /** Describes the order of selects (referenced by query index) in each role. */\r\n        ordering?: DataViewProjectionOrdering;\r\n\r\n        /** Describes the active items in each role. */\r\n        activeItems?: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export interface MatrixTransformationContext {\r\n        rowHierarchyRewritten: boolean;\r\n        columnHierarchyRewritten: boolean;\r\n        hierarchyTreesRewritten: boolean;\r\n    }\r\n\r\n    interface ValueRewrite<T> {\r\n        from: T;\r\n        to: T;\r\n    }\r\n\r\n    interface NumberToNumberMapping {\r\n        [position: number]: number;\r\n    }\r\n\r\n    const enum CategoricalDataViewTransformation {\r\n        None,\r\n        Pivot,\r\n        SelfCrossJoin,\r\n    }\r\n\r\n    export const enum StandardDataViewKinds {\r\n        None = 0,\r\n        Categorical = 1,\r\n        Matrix = 1 << 1,\r\n        Single = 1 << 2,\r\n        Table = 1 << 3,\r\n        Tree = 1 << 4,\r\n    }\r\n\r\n    // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n    export module DataViewTransform {\r\n        const fillRulePropertyDescriptor: DataViewObjectPropertyDescriptor = { type: { fillRule: {} } };\r\n\r\n        const enum ColumnIdentifierKind {\r\n            QueryName,\r\n            Role,\r\n        }\r\n\r\n        export function apply(options: DataViewTransformApplyOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\r\n\r\n            let prototype = options.prototype,\r\n                objectDescriptors = options.objectDescriptors,\r\n                dataViewMappings = options.dataViewMappings,\r\n                transforms = options.transforms,\r\n                projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems,\r\n                colorAllocatorFactory = options.colorAllocatorFactory,\r\n                dataRoles = options.dataRoles;\r\n\r\n            if (!prototype)\r\n                return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\r\n\r\n            if (!transforms)\r\n                return [prototype];\r\n\r\n            // Transform Query DataView\r\n            prototype = DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\r\n            let visualDataViews: DataView[] = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\r\n\r\n            // Transform and generate derived visual DataViews\r\n            visualDataViews = DataViewRegression.run({\r\n                dataViewMappings: dataViewMappings,\r\n                visualDataViews: visualDataViews,\r\n                dataRoles: dataRoles,\r\n                objectDescriptors: objectDescriptors,\r\n                objectDefinitions: transforms.objects,\r\n                colorAllocatorFactory: colorAllocatorFactory,\r\n                transformSelects: transforms.selects,\r\n                metadata: prototype.metadata,\r\n                projectionActiveItems: projectionActiveItems,\r\n            });\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        function transformQueryToVisualDataView(\r\n            prototype: DataView,\r\n            transforms: DataViewTransformActions,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            dataViewMappings: DataViewMapping[],\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[]): DataView[] {\r\n            let transformedDataViews: DataView[] = [];\r\n            let splits = transforms.splits;\r\n            if (_.isEmpty(splits)) {\r\n                transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\r\n            } else {\r\n                for (let split of splits) {\r\n                    let transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\r\n                    transformedDataViews.push(transformed);\r\n                }\r\n            }\r\n            return transformedDataViews;\r\n        }\r\n\r\n        function transformEmptyDataView(objectDescriptors: DataViewObjectDescriptors, transforms: DataViewTransformActions, colorAllocatorFactory: IColorAllocatorFactory): DataView[] {\r\n            if (transforms && transforms.objects) {\r\n                let emptyDataView: DataView = {\r\n                    metadata: {\r\n                        columns: [],\r\n                    }\r\n                };\r\n\r\n                transformObjects(\r\n                    emptyDataView,\r\n                    StandardDataViewKinds.None,\r\n                    objectDescriptors,\r\n                    transforms.objects,\r\n                    transforms.selects,\r\n                    colorAllocatorFactory);\r\n\r\n                return [emptyDataView];\r\n            }\r\n\r\n            return [];\r\n        }\r\n\r\n        function transformDataView(\r\n            prototype: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            transforms: DataViewTransformActions,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[],\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(transforms, 'transforms');\r\n            debug.assert(!selectsToInclude ||\r\n                _.filter(\r\n                    Object.keys(selectsToInclude),\r\n                    (selectIndex) => selectsToInclude[selectIndex] && (!transforms.selects || !transforms.selects[selectIndex]))\r\n                    .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0\r\n                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');\r\n\r\n            let targetKinds = getTargetKinds(roleMappings);\r\n            let transformed = inherit(prototype);\r\n            transformed.metadata = inherit(prototype.metadata);\r\n\r\n            let projectionOrdering = transforms.roles && transforms.roles.ordering;\r\n            let projectionActiveItems = transforms.roles && transforms.roles.activeItems;\r\n            transformed = transformSelects(transformed, targetKinds, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\r\n            transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\r\n\r\n            // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\r\n            transformed = DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\r\n\r\n            DataViewNormalizeValues.apply({\r\n                dataview: transformed,\r\n                dataViewMappings: roleMappings,\r\n                dataRoles: dataRoles,\r\n            });\r\n\r\n            return transformed;\r\n        }\r\n\r\n        function getTargetKinds(roleMappings: DataViewMapping[]): StandardDataViewKinds {\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n\r\n            if (!roleMappings)\r\n                return StandardDataViewKinds.None;\r\n\r\n            let result = StandardDataViewKinds.None;\r\n            for (let roleMapping of roleMappings) {\r\n                if (roleMapping.categorical)\r\n                    result |= StandardDataViewKinds.Categorical;\r\n                if (roleMapping.matrix)\r\n                    result |= StandardDataViewKinds.Matrix;\r\n                if (roleMapping.single)\r\n                    result |= StandardDataViewKinds.Single;\r\n                if (roleMapping.table)\r\n                    result |= StandardDataViewKinds.Table;\r\n                if (roleMapping.tree)\r\n                    result |= StandardDataViewKinds.Tree;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function transformSelects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            roleMappings: DataViewMapping[],\r\n            selectTransforms: DataViewSelectTransform[],\r\n            projectionOrdering?: DataViewProjectionOrdering,\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n\r\n            let columnRewrites: ValueRewrite<DataViewMetadataColumn>[] = [];\r\n            if (selectTransforms) {\r\n                dataView.metadata.columns = applyTransformsToColumns(\r\n                    dataView.metadata.columns,\r\n                    selectTransforms,\r\n                    columnRewrites);\r\n            }\r\n\r\n            // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\r\n\r\n            if (dataView.categorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                // NOTE: This is slightly DSR-specific.\r\n                dataView = pivotIfNecessary(dataView, roleMappings);\r\n            }\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a matrix.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (dataView.matrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let matrixTransformationContext: MatrixTransformationContext = {\r\n                    rowHierarchyRewritten: false,\r\n                    columnHierarchyRewritten: false,\r\n                    hierarchyTreesRewritten: false\r\n                };\r\n                dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                if (shouldPivotMatrix(dataView.matrix, roleMappings))\r\n                    DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\r\n            }\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a table.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (dataView.table && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                dataView.table = applyRewritesToTable(dataView.table, columnRewrites, projectionOrdering);\r\n            }\r\n\r\n            return dataView;\r\n        }\r\n\r\n        function applyTransformsToColumns(\r\n            prototypeColumns: DataViewMetadataColumn[],\r\n            selects: DataViewSelectTransform[],\r\n            rewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn[] {\r\n            debug.assertValue(prototypeColumns, 'columns');\r\n\r\n            if (!selects)\r\n                return prototypeColumns;\r\n\r\n            //column may contain undefined entries\r\n            let columns = inherit(prototypeColumns);\r\n\r\n            for (let i = 0, len = prototypeColumns.length; i < len; i++) {\r\n                let prototypeColumn = prototypeColumns[i];\r\n                let select = selects[prototypeColumn.index];\r\n                if (!select)\r\n                    continue;\r\n\r\n                let column: DataViewMetadataColumn = columns[i] = inherit(prototypeColumn);\r\n\r\n                if (select.roles)\r\n                    column.roles = select.roles;\r\n                if (select.type)\r\n                    column.type = select.type;\r\n                column.format = getFormatForColumn(select, column);\r\n\r\n                if (select.displayName)\r\n                    column.displayName = select.displayName;\r\n                if (select.queryName)\r\n                    column.queryName = select.queryName;\r\n                if (select.kpi)\r\n                    column.kpi = select.kpi;\r\n                if (select.sort)\r\n                    column.sort = select.sort;\r\n                if (select.discourageAggregationAcrossGroups)\r\n                    column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\r\n\r\n                rewrites.push({\r\n                    from: prototypeColumn,\r\n                    to: column,\r\n                });\r\n            }\r\n\r\n            return columns;\r\n        }\r\n\r\n        /**\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Select format\r\n         *  2. Column format\r\n         */\r\n        function getFormatForColumn(select: DataViewSelectTransform, column: DataViewMetadataColumn): string {\r\n            // TODO: we already copied the select.Format to column.format, we probably don't need this check\r\n            return select.format || column.format;\r\n        }\r\n\r\n        function applyRewritesToCategorical(prototype: DataViewCategorical, columnRewrites: ValueRewrite<DataViewMetadataColumn>[], selectsToInclude?: INumberDictionary<boolean>): DataViewCategorical {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let categorical = inherit(prototype);\r\n\r\n            function override(value: { source?: DataViewMetadataColumn }) {\r\n                let rewrittenSource = findOverride(value.source, columnRewrites);\r\n                if (rewrittenSource) {\r\n                    let rewritten = inherit(value);\r\n                    rewritten.source = rewrittenSource;\r\n                    return rewritten;\r\n                }\r\n            }\r\n\r\n            let categories = Prototype.overrideArray(prototype.categories, override);\r\n            if (categories)\r\n                categorical.categories = categories;\r\n\r\n            let valuesOverride = Prototype.overrideArray(prototype.values, override);\r\n            let valueColumns = valuesOverride || prototype.values;\r\n\r\n            if (valueColumns) {\r\n                if (valueColumns.source) {\r\n                    if (selectsToInclude && !selectsToInclude[valueColumns.source.index]) {\r\n                        // if processing a split and this is the split without series...\r\n                        valueColumns.source = undefined;\r\n                    }\r\n                    else {\r\n                        let rewrittenValuesSource = findOverride(valueColumns.source, columnRewrites);\r\n                        if (rewrittenValuesSource)\r\n                            valueColumns.source = rewrittenValuesSource;\r\n                    }\r\n                }\r\n\r\n                if (selectsToInclude) {\r\n                    // Apply selectsToInclude to values by removing value columns not included\r\n                    for (let i = valueColumns.length - 1; i >= 0; i--) {\r\n                        if (!selectsToInclude[valueColumns[i].source.index]) {\r\n                            valueColumns.splice(i, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let isDynamicSeries = !!valueColumns.source;\r\n\r\n                debug.assert((prototype.values.length === 1) && (_.isEmpty(prototype.values[0].values)) ||\r\n                    _.every(valueColumns, (valueColumn) => isDynamicSeries === !!valueColumn.identity),\r\n                    'After applying selectsToInclude, all remaining DataViewValueColumn objects should have a consistent scope type (static vs. dynamic) with the parent DataViewValueColumns object.');\r\n                    \r\n                // Dynamic or not, always update the return values of grouped() to have the rewritten 'source' property\r\n                let seriesGroups: DataViewValueColumnGroup[];\r\n                if (isDynamicSeries) {\r\n                    // We have a dynamic series, so update the return value of grouped() to have the DataViewValueColumn objects with rewritten 'source'.\r\n                    // Also, exclude any column that belongs to a static series.\r\n                    seriesGroups = inherit(valueColumns.grouped());\r\n                    \r\n                    let nextSeriesGroupIndex = 0;\r\n                    let currentSeriesGroup: DataViewValueColumnGroup;\r\n                    for (let i = 0, ilen = valueColumns.length; i < ilen; i++) {\r\n                        let currentValueColumn = valueColumns[i];\r\n                        if (!currentSeriesGroup || (currentValueColumn.identity !== currentSeriesGroup.identity)) {\r\n                            currentSeriesGroup = inherit(seriesGroups[nextSeriesGroupIndex]);\r\n                            seriesGroups[nextSeriesGroupIndex] = currentSeriesGroup;\r\n                            currentSeriesGroup.values = [];\r\n                            nextSeriesGroupIndex++;\r\n                            debug.assert(currentValueColumn.identity === currentSeriesGroup.identity, 'expecting the value columns are sequenced by series groups');\r\n                        }\r\n                        currentSeriesGroup.values.push(currentValueColumn);\r\n                    }\r\n                }\r\n                else {\r\n                    // We are in a static series, so we should throw away the grouped and recreate it using the static values\r\n                    //   which have already been filtered\r\n                    seriesGroups = [{ values: valueColumns }];\r\n                }\r\n\r\n                valueColumns.grouped = () => seriesGroups;\r\n                categorical.values = valueColumns;\r\n            }\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function applyRewritesToTable(\r\n            prototype: DataViewTable,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            projectionOrdering: DataViewProjectionOrdering): DataViewTable {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let table = inherit(prototype);\r\n\r\n            // Copy the rewritten columns into the table view\r\n            let override = (metadata: DataViewMetadataColumn) => findOverride(metadata, columnRewrites);\r\n            let columns = Prototype.overrideArray(prototype.columns, override);\r\n            if (columns)\r\n                table.columns = columns;\r\n\r\n            if (!projectionOrdering)\r\n                return table;\r\n\r\n            let newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\r\n            if (!newToOldPositions)\r\n                return table;\r\n\r\n            // Reorder the columns\r\n            let columnsClone = columns.slice(0);\r\n            let keys = Object.keys(newToOldPositions);\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let sourceColumn = columnsClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === columns.length)\r\n                    columns.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < columns.length, 'The column index is out of range for reordering.');\r\n                    columns[i] = sourceColumn;\r\n                }\r\n            }\r\n\r\n            // Reorder the rows\r\n            let rows = Prototype.overrideArray(table.rows,\r\n                (row: any[]) => {\r\n                    let newRow: any[] = [];\r\n                    for (let i = 0, len = keys.length; i < len; ++i)\r\n                        newRow[i] = row[newToOldPositions[keys[i]]];\r\n\r\n                    return newRow;\r\n                });\r\n\r\n            if (rows)\r\n                table.rows = rows;\r\n\r\n            return table;\r\n        }\r\n\r\n        /** Creates a mapping of new position to original position. */\r\n        function createTableColumnPositionMapping(\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n            let roles = Object.keys(projectionOrdering);\r\n\r\n            // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\r\n            if (roles.length !== 1)\r\n                return;\r\n\r\n            let role = roles[0],\r\n                originalOrder = _.map(columnRewrites, (rewrite: ValueRewrite<DataViewMetadataColumn>) => rewrite.from.index),\r\n                newOrder = projectionOrdering[role];\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        function applyRewritesToMatrix(\r\n            prototype: DataViewMatrix,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            context: MatrixTransformationContext): DataViewMatrix {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n            debug.assertValue(roleMappings, 'roleMappings');\r\n            \r\n            let firstRoleMappingWithMatrix = _.find(roleMappings, (roleMapping) => !!roleMapping.matrix);\r\n            debug.assertValue(firstRoleMappingWithMatrix, 'roleMappings - at least one role mapping is expected to target DataViewMatrix');\r\n\r\n            let matrixMapping = firstRoleMappingWithMatrix.matrix;\r\n            let matrix = inherit(prototype);\r\n\r\n            function override(metadata: DataViewMetadataColumn) {\r\n                return findOverride(metadata, columnRewrites);\r\n            }\r\n\r\n            function overrideHierarchy(hierarchy: DataViewHierarchy): DataViewHierarchy {\r\n                let rewrittenHierarchy: DataViewHierarchy = null;\r\n\r\n                let newLevels = Prototype.overrideArray(\r\n                    hierarchy.levels,\r\n                    (level: DataViewHierarchyLevel) => {\r\n                        let newLevel: DataViewHierarchyLevel = null;\r\n                        let levelSources = Prototype.overrideArray(level.sources, override);\r\n                        if (levelSources)\r\n                            newLevel = ensureRewritten<DataViewHierarchyLevel>(newLevel, level, h => h.sources = levelSources);\r\n\r\n                        return newLevel;\r\n                    });\r\n                if (newLevels)\r\n                    rewrittenHierarchy = ensureRewritten<DataViewHierarchy>(rewrittenHierarchy, hierarchy, r => r.levels = newLevels);\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n\r\n            let rows = overrideHierarchy(matrix.rows);\r\n            if (rows) {\r\n                matrix.rows = rows;\r\n                context.rowHierarchyRewritten = true;\r\n            }\r\n\r\n            let columns = overrideHierarchy(matrix.columns);\r\n            if (columns) {\r\n                matrix.columns = columns;\r\n                context.columnHierarchyRewritten = true;\r\n            }\r\n\r\n            let valueSources = Prototype.overrideArray(matrix.valueSources, override);\r\n            if (valueSources) {\r\n                matrix.valueSources = valueSources;\r\n\r\n                // Only need to reorder if we have more than one value source, and they are all bound to the same role\r\n                let matrixValues = <DataViewRoleForMapping>matrixMapping.values;\r\n                if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\r\n                    let columnLevels = columns.levels.length;\r\n                    if (columnLevels > 0) {\r\n                        let newToOldPositions = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\r\n                        if (newToOldPositions) {\r\n                            let keys = Object.keys(newToOldPositions);\r\n                            let numKeys = keys.length;\r\n\r\n                            // Reorder the value columns\r\n                            columns.root = DataViewPivotMatrix.cloneTree(columns.root);\r\n                            if (columnLevels === 1)\r\n                                reorderChildNodes(columns.root, newToOldPositions);\r\n                            else\r\n                                forEachNodeAtLevel(columns.root, columnLevels - 2, (node: DataViewMatrixNode) => reorderChildNodes(node, newToOldPositions));\r\n\r\n                            // Reorder the value rows\r\n                            matrix.rows.root = DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, (node: DataViewMatrixNode) => {\r\n\r\n                                if (!node.values)\r\n                                    return;\r\n\r\n                                let newValues: { [id: number]: DataViewTreeNodeValue } = {};\r\n\r\n                                let iterations = Object.keys(node.values).length / numKeys;\r\n                                for (let i = 0, len = iterations; i < len; i++) {\r\n                                    let offset = i * numKeys;\r\n                                    for (let keysIndex = 0; keysIndex < numKeys; keysIndex++)\r\n                                        newValues[offset + keysIndex] = node.values[offset + newToOldPositions[keys[keysIndex]]];\r\n                                }\r\n\r\n                                node.values = newValues;\r\n                            });\r\n\r\n                            context.hierarchyTreesRewritten = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\r\n\r\n            return matrix;\r\n        }\r\n\r\n        function reorderChildNodes(node: DataViewMatrixNode, newToOldPositions: NumberToNumberMapping): void {\r\n            let keys = Object.keys(newToOldPositions);\r\n            let numKeys = keys.length;\r\n            let children = node.children;\r\n\r\n            let childrenClone = children.slice(0);\r\n            for (let i = 0, len = numKeys; i < len; i++) {\r\n                let sourceColumn = childrenClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === children.length)\r\n                    children.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < children.length, 'The column index is out of range for reordering.');\r\n                    children[i] = sourceColumn;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\r\n         * and values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified prototype is necessary.\r\n         */\r\n        function reorderMatrixCompositeGroups(\r\n            prototype: DataViewMatrix,\r\n            supportedDataViewMapping: DataViewMatrixMapping,\r\n            projection: DataViewProjectionOrdering): DataViewMatrix {\r\n\r\n            let transformedDataView: DataViewMatrix;\r\n\r\n            if (prototype && supportedDataViewMapping && projection) {\r\n\r\n                // reorder levelValues in any composite groups in rows hierarchy\r\n                let transformedRowsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedRowsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedRowsHierarchy || prototype.rows,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                // reorder levelValues in any composite groups in columns hierarchy\r\n                let transformedColumnsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedColumnsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedColumnsHierarchy || prototype.columns,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                if (transformedRowsHierarchy || transformedColumnsHierarchy) {\r\n                    transformedDataView = inheritSingle(prototype);\r\n                    transformedDataView.rows = transformedRowsHierarchy || transformedDataView.rows;\r\n                    transformedDataView.columns = transformedColumnsHierarchy || transformedDataView.columns;\r\n                }\r\n            }\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\r\n         * values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\r\n         */\r\n        function reorderMatrixHierarchyCompositeGroups(\r\n            matrixHierarchy: DataViewHierarchy,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): DataViewHierarchy {\r\n            debug.assertValue(matrixHierarchy, 'matrixHierarchy');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n\r\n            let transformedHierarchy: DataViewHierarchy;\r\n            let selectIndicesInProjectionOrder: number[] = projection[hierarchyRole];\r\n\r\n            // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\r\n            let hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\r\n            if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\r\n                for (let i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\r\n                    var hierarchyLevel: DataViewHierarchyLevel = matrixHierarchy.levels[i];\r\n\r\n                    // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\r\n                    let newToOldLevelSourceIndicesMapping: NumberToNumberMapping =\r\n                        createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\r\n\r\n                    if (newToOldLevelSourceIndicesMapping) {\r\n                        if (_.isUndefined(transformedHierarchy)) {\r\n                            // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\r\n                            // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\r\n                            transformedHierarchy = inheritSingle(matrixHierarchy);\r\n                            transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\r\n\r\n                            // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\r\n                            // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\r\n                            // happen in other hierarchy levels in the later iterations of this for-loop.\r\n                            transformedHierarchy.root = utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\r\n                        }\r\n\r\n                        // reorder the metadata columns in the sources array at that level\r\n                        let transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\r\n                        transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\r\n\r\n                        // reorder the level values in the composite group nodes at the current hierarchy level\r\n                        reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return transformedHierarchy;\r\n        }\r\n\r\n        /**\r\n         * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\r\n         * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\r\n         *\r\n         * The returned value maps level source indices from the new target order (calculated from projection order)\r\n         * back to the original order as they appear in the specified hierarchyLevel's sources.\r\n         * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\r\n         *\r\n         * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\r\n         *\r\n         * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\r\n         * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\r\n         * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\r\n         */\r\n        function createMatrixHierarchyLevelSourcesPositionMapping(\r\n            hierarchyLevel: DataViewHierarchyLevel,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): NumberToNumberMapping {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n            debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\r\n\r\n            let newToOldLevelSourceIndicesMapping: NumberToNumberMapping;\r\n            let levelSourceColumns = hierarchyLevel.sources;\r\n\r\n            if (levelSourceColumns && levelSourceColumns.length >= 2) {\r\n                // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\r\n\r\n                let columnsForHierarchyRoleOrderedByLevelSourceIndex = utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(\r\n                    levelSourceColumns,\r\n                    projection,\r\n                    hierarchyRole);\r\n\r\n                if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\r\n                    // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\r\n                    let columnsForHierarchyRoleOrderedByProjection = _.sortBy(\r\n                        columnsForHierarchyRoleOrderedByLevelSourceIndex,\r\n                        columnInfo => columnInfo.projectionOrderIndex);\r\n\r\n                    newToOldLevelSourceIndicesMapping = createOrderMapping(\r\n                        _.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, columnInfo => columnInfo.sourceIndex),\r\n                        _.map(columnsForHierarchyRoleOrderedByProjection, columnInfo => columnInfo.sourceIndex));\r\n                }\r\n            }\r\n\r\n            return newToOldLevelSourceIndicesMapping;\r\n        }\r\n\r\n        /**\r\n         * Applies re-ordering on the specified transformingHierarchyLevel's sources.\r\n         * Returns the same object as the specified transformingHierarchyLevel.\r\n         */\r\n        function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel: DataViewHierarchyLevel, newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewHierarchyLevel {\r\n            debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let originalLevelSources = transformingHierarchyLevel.sources;\r\n\r\n            transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\r\n\r\n            let newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\r\n            for (let i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\r\n                let newLevelSourceIndex = newLevelSourceIndices[i];\r\n                let oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\r\n\r\n                debug.assert(oldLevelSourceIndex < originalLevelSources.length,\r\n                    'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\r\n\r\n                transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\r\n            }\r\n\r\n            return transformingHierarchyLevel;\r\n        }\r\n\r\n        /**\r\n         * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\r\n         * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\r\n         *\r\n         * Returns the same object as the specified transformingHierarchyRootNode.\r\n         */\r\n        function reorderMatrixHierarchyLevelValues(\r\n            transformingHierarchyRootNode: DataViewMatrixNode,\r\n            transformingHierarchyLevelIndex: number,\r\n            newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewMatrixNode {\r\n            debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let oldToNewLevelSourceIndicesMapping: NumberToNumberMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\r\n\r\n            forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, (transformingMatrixNode: DataViewMatrixNode) => {\r\n                let originalLevelValues = transformingMatrixNode.levelValues;\r\n\r\n                // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\r\n                // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\r\n                // The following code isn't correct in the special case where a column is projected twice in this composite group,\r\n                // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\r\n                // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\r\n\r\n                if (!_.isEmpty(originalLevelValues)) {\r\n                    // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\r\n                    // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\r\n                    // because we don't want to accidentally modify the array AND its value references in Query DataView\r\n                    let newlyOrderedLevelValues = _.sortBy(originalLevelValues, levelValue => oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]);\r\n\r\n                    for (let i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\r\n                        let transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\r\n                        transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\r\n                        newlyOrderedLevelValues[i] = transformingLevelValue;\r\n                    }\r\n\r\n                    transformingMatrixNode.levelValues = newlyOrderedLevelValues;\r\n\r\n                    // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\r\n                    // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\r\n                    let newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\r\n                    if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\r\n                        transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\r\n                    }\r\n                    if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\r\n                        transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return transformingHierarchyRootNode;\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of new position to original position.\r\n         *\r\n         * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\r\n         * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\r\n         * - the value in the key-value pair is the index of the particular column in the original order\r\n         */\r\n        function createMatrixValuesPositionMapping(\r\n            matrixValues: DataViewRoleForMapping,\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            valueSources: DataViewMetadataColumn[],\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n\r\n            let role = matrixValues.for.in;\r\n            let newOrder = projectionOrdering[role];\r\n\r\n            let originalOrder = _.chain(columnRewrites)\r\n                .filter(rewrite => _.contains(valueSources, rewrite.to))\r\n                .map(rewrite => rewrite.from.index)\r\n                .value();\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\r\n         * originalOrder array.\r\n         * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\r\n         * under the context of the caller code), e.g. the Select Index in projection ordering array.\r\n         * Also, the specified originalOrder must contain every value that exists in newOrder.\r\n         *\r\n         * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\r\n         * key-value pair, each of which represents the new and old indices of a particular column:\r\n         * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\r\n         * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\r\n         *\r\n         * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\r\n         *\r\n         * If the specified originalOrder and newOrder are same, then this function returns undefined.\r\n         *\r\n         * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\r\n         * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\r\n         */\r\n        function createOrderMapping(originalOrder: number[], newOrder: number[]): NumberToNumberMapping {\r\n            // Optimization: avoid rewriting if the current order is correct\r\n            if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, (x: number, y: number) => x === y))\r\n                return;\r\n\r\n            let mapping: NumberToNumberMapping = {};\r\n            for (let i = 0, len = newOrder.length; i < len; ++i) {\r\n                let newPosition = newOrder[i];\r\n                mapping[i] = originalOrder.indexOf(newPosition);\r\n            }\r\n\r\n            return mapping;\r\n        }\r\n\r\n        function createReversedMapping(mapping: NumberToNumberMapping): NumberToNumberMapping {\r\n            debug.assertValue(mapping, 'mapping');\r\n\r\n            let reversed: NumberToNumberMapping = {};\r\n\r\n            for (let key in mapping) {\r\n                // Note: key is a string after we get it out from mapping, thus we need to parse it\r\n                // back into a number before putting it as the value in the reversed mapping\r\n                let value = mapping[key];\r\n                let keyAsNumber = parseInt(key, 10);\r\n                reversed[value] = keyAsNumber;\r\n            }\r\n\r\n            debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length,\r\n                'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\r\n\r\n            return reversed;\r\n        }\r\n\r\n        export function forEachNodeAtLevel(node: DataViewMatrixNode, targetLevel: number, callback: (node: DataViewMatrixNode) => void): void {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(targetLevel >= 0, 'argetLevel >= 0');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            if (node.level === targetLevel) {\r\n                callback(node);\r\n                return;\r\n            }\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachNodeAtLevel(children[i], targetLevel, callback);\r\n            }\r\n        }\r\n\r\n        function findOverride(source: DataViewMetadataColumn, columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn {\r\n            for (let i = 0, len = columnRewrites.length; i < len; i++) {\r\n                let columnRewrite = columnRewrites[i];\r\n                if (columnRewrite.from === source)\r\n                    return columnRewrite.to;\r\n            }\r\n        }\r\n\r\n        function ensureRewritten<T>(rewritten: T, prototype: T, callback?: (rewritten: T) => void): T {\r\n            if (!rewritten)\r\n                rewritten = inherit(prototype);\r\n\r\n            if (callback)\r\n                callback(rewritten);\r\n\r\n            return rewritten;\r\n        }\r\n\r\n        export function transformObjects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!objectDescriptors)\r\n                return;\r\n\r\n            let objectsForAllSelectors = DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\r\n            DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\r\n\r\n            let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n            let dataObjects = objectsForAllSelectors.data;\r\n            if (metadataOnce)\r\n                evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\r\n\r\n            let metadataObjects = objectsForAllSelectors.metadata;\r\n            if (metadataObjects) {\r\n                for (let i = 0, len = metadataObjects.length; i < len; i++) {\r\n                    let metadataObject = metadataObjects[i];\r\n                    let objectDefns = metadataObject.objects;\r\n                    let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                    evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\r\n                }\r\n            }\r\n\r\n            for (let i = 0, len = dataObjects.length; i < len; i++) {\r\n                let dataObject = dataObjects[i];\r\n                let objectDefns = dataObject.objects;\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\r\n            }\r\n\r\n            let userDefined = objectsForAllSelectors.userDefined;\r\n            if (userDefined) {\r\n                // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\r\n                evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\r\n            }\r\n        }\r\n\r\n        function evaluateUserDefinedObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewObjectDefinitionsForSelector[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let dataViewObjects: DataViewObjects = dataView.metadata.objects;\r\n            if (!dataViewObjects) {\r\n                dataViewObjects = dataView.metadata.objects = {};\r\n            }\r\n\r\n            for (let objectDefn of objectDefns) {\r\n                let id = objectDefn.selector.id;\r\n\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\r\n                let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n                let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName];\r\n\r\n                    let map = <DataViewObjectMap>dataViewObjects[objectName];\r\n                    if (!map)\r\n                        map = dataViewObjects[objectName] = [];\r\n                    debug.assert(DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\r\n\r\n                    // NOTE: We do not check for duplicate ids.\r\n                    map.push({ id: id, object: object });\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Evaluates and sets properties on the DataView metadata. */\r\n        function evaluateMetadataObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            dataObjects: DataViewObjectDefinitionsForSelectorWithRule[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(dataObjects, 'dataObjects');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n            let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n            if (objects) {\r\n                dataView.metadata.objects = objects;\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName],\r\n                        objectDesc = objectDescriptors[objectName];\r\n\r\n                    for (let propertyName in object) {\r\n                        let propertyDesc = objectDesc.properties[propertyName],\r\n                            ruleDesc = propertyDesc.rule;\r\n                        if (!ruleDesc)\r\n                            continue;\r\n\r\n                        let definition = createRuleEvaluationInstance(\r\n                            dataView,\r\n                            colorAllocatorFactory,\r\n                            ruleDesc,\r\n                            objectName,\r\n                            object[propertyName],\r\n                            propertyDesc.type);\r\n                        if (!definition)\r\n                            continue;\r\n\r\n                        dataObjects.push(definition);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstance(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            objectName: string,\r\n            propertyValue: DataViewPropertyValue,\r\n            ruleType: StructuralTypeDescriptor): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n            debug.assertValue(ruleType, 'ruleType');\r\n\r\n            let ruleOutput = ruleDesc.output;\r\n            if (!ruleOutput)\r\n                return;\r\n\r\n            let selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\r\n            if (!selectorToCreate)\r\n                return;\r\n\r\n            if (ruleType.fillRule) {\r\n                return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, <FillRule>propertyValue);\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstanceFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            selectorToCreate: Selector,\r\n            objectName: string,\r\n            propertyValue: FillRule): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(selectorToCreate, 'selectorToCreate');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, ColumnIdentifierKind.Role, propertyValue);\r\n\r\n            if (!colorAllocator)\r\n                return;\r\n\r\n            let rule = new ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\r\n            let fillRuleProperties: DataViewObjectPropertyDefinitions = {};\r\n            fillRuleProperties[ruleDesc.output.property] = {\r\n                solid: { color: rule }\r\n            };\r\n\r\n            return {\r\n                selector: selectorToCreate,\r\n                rules: [rule],\r\n                objects: [{\r\n                    name: objectName,\r\n                    properties: fillRuleProperties,\r\n                }]\r\n            };\r\n        }\r\n\r\n        function tryCreateColorAllocatorForFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValue: FillRule): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            if (propertyValue.linearGradient2)\r\n                return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\r\n\r\n            if (propertyValue.linearGradient3)\r\n                return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient2(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient2: LinearGradient2): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient2, 'linearGradient2');\r\n\r\n            linearGradient2 = propertyValueFillRule.linearGradient2;\r\n            if (linearGradient2.min.value === undefined ||\r\n                linearGradient2.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                if (linearGradient2.min.value === undefined)\r\n                    linearGradient2.min.value = inputRange.min;\r\n                if (linearGradient2.max.value === undefined)\r\n                    linearGradient2.max.value = inputRange.max;\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient3(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient3: LinearGradient3): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient3, 'linearGradient3');\r\n\r\n            let splitScales: boolean;\r\n            linearGradient3 = propertyValueFillRule.linearGradient3;\r\n            if (linearGradient3.min.value === undefined ||\r\n                linearGradient3.mid.value === undefined ||\r\n                linearGradient3.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                splitScales =\r\n                linearGradient3.min.value === undefined &&\r\n                linearGradient3.max.value === undefined &&\r\n                linearGradient3.mid.value !== undefined;\r\n\r\n                if (linearGradient3.min.value === undefined) {\r\n                    linearGradient3.min.value = inputRange.min;\r\n                }\r\n                if (linearGradient3.max.value === undefined) {\r\n                    linearGradient3.max.value = inputRange.max;\r\n                }\r\n                if (linearGradient3.mid.value === undefined) {\r\n                    let midValue: number = (linearGradient3.max.value + linearGradient3.min.value) / 2;\r\n                    linearGradient3.mid.value = midValue;\r\n                }\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\r\n        }\r\n\r\n        function populateColorAllocatorCache(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): IColorAllocatorCache {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let cache = createColorAllocatorCache();\r\n            let staticEvalContext = createStaticEvalContext();\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefnProperties = objectDefns[i].properties;\r\n\r\n                for (let propertyName in objectDefnProperties) {\r\n                    let fillProperty = <FillDefinition>objectDefnProperties[propertyName];\r\n                    if (fillProperty &&\r\n                        fillProperty.solid &&\r\n                        fillProperty.solid.color &&\r\n                        fillProperty.solid.color.kind === SQExprKind.FillRule) {\r\n\r\n                        let fillRuleExpr = <SQFillRuleExpr>fillProperty.solid.color;\r\n\r\n                        let inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\r\n                        if (!inputExprQueryName)\r\n                            continue;\r\n\r\n                        let fillRule = DataViewObjectEvaluator.evaluateProperty(\r\n                            staticEvalContext,\r\n                            fillRulePropertyDescriptor,\r\n                            fillRuleExpr.rule);\r\n\r\n                        let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, ColumnIdentifierKind.QueryName, fillRule);\r\n                        if (colorAllocator)\r\n                            cache.register(fillRuleExpr, colorAllocator);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return cache;\r\n        }\r\n\r\n        function evaluateDataRepetition(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\r\n\r\n            let containsWildcard = Selector.containsWildcard(selector);\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                // 1) Match against categories\r\n                evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // 2) Match against valueGrouping\r\n                evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewMatrix = dataView.matrix;\r\n            if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenMatrix) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.matrix = rewrittenMatrix;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewTable = dataView.table;\r\n            if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                let rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\r\n                let rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenTable) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.table = rewrittenTable;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n        }\r\n\r\n        function rewriteTableRoleSelector(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            if (Selector.hasRoleWildcard(selector)) {\r\n                selector = findSelectorForRoleWildcard(dataViewTable, selector);\r\n            }\r\n\r\n            return selector;\r\n        }\r\n\r\n        function findSelectorForRoleWildcard(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            let resultingSelector: Selector = {\r\n                data: [],\r\n                id: selector.id,\r\n                metadata: selector.metadata\r\n            };\r\n\r\n            for (let dataSelector of selector.data) {\r\n                if (Selector.isRoleWildcard(dataSelector)) {\r\n                    let selectorRoles = dataSelector.roles;\r\n                    let allColumnsBelongToSelectorRole: boolean = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\r\n                    let exprs = dataViewTable.identityFields;\r\n                    if (allColumnsBelongToSelectorRole && exprs) {\r\n                        resultingSelector.data.push(DataViewScopeWildcard.fromExprs(<SQExpr[]>exprs));\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\r\n                    resultingSelector.data.push(dataSelector);\r\n                }\r\n            }\r\n\r\n            return resultingSelector;\r\n        }\r\n\r\n        function isUniqueDataSelector(dataSelectors: DataRepetitionSelector[], newSelector: DataRepetitionSelector): boolean {\r\n            if (_.isEmpty(dataSelectors))\r\n                return true;\r\n\r\n            return !_.any(dataSelectors, (dataSelector: DataRepetitionSelector) => dataSelector.key === newSelector.key);\r\n        }\r\n\r\n        function allColumnsBelongToRole(columns: DataViewMetadataColumn[], selectorRoles: string[]): boolean {\r\n            for (let column of columns) {\r\n                var roles = column.roles;\r\n                if (!roles || !_.any(selectorRoles, (selectorRole) => roles[selectorRole]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalCategory(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\r\n                return;\r\n\r\n            let targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\r\n            if (!targetColumn)\r\n                return;\r\n\r\n            let identities = targetColumn.identities,\r\n                foundMatch: boolean,\r\n                evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            if (!identities)\r\n                return;\r\n\r\n            debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\r\n\r\n            for (let i = 0, len = identities.length; i < len; i++) {\r\n                let identity = identities[i];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(i);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n                        if (!targetColumn.column.objects) {\r\n                            targetColumn.column.objects = [];\r\n                            targetColumn.column.objects.length = len;\r\n                        }\r\n                        targetColumn.column.objects[i] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n\r\n                    foundMatch = true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalValueGrouping(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let dataViewCategoricalValues = dataViewCategorical.values;\r\n            if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\r\n                return;\r\n\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[dataViewCategoricalValues.identityFields]))\r\n                return;\r\n\r\n            let valuesGrouped = dataViewCategoricalValues.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\r\n            // This should be enhanced in the future.\r\n            let evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            let foundMatch: boolean;\r\n            for (let i = 0, len = valuesGrouped.length; i < len; i++) {\r\n                let valueGroup = valuesGrouped[i];\r\n                let selectorMetadata = selector.metadata;\r\n                let valuesInGroup = valueGroup.values;\r\n                if (containsWildcard || Selector.matchesData(selector, [valueGroup.identity])) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n\r\n                        if (selectorMetadata) {\r\n                            for (let j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\r\n                                let valueColumn = valuesInGroup[j],\r\n                                    valueSource = valueColumn.source;\r\n                                if (valueSource.queryName === selectorMetadata) {\r\n                                    let valueSourceOverwrite = Prototype.inherit(valueSource);\r\n                                    valueSourceOverwrite.objects = objects;\r\n                                    valueColumn.source = valueSourceOverwrite;\r\n\r\n                                    foundMatch = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            valueGroup.objects = objects;\r\n                            setGrouped(dataViewCategoricalValues, valuesGrouped);\r\n\r\n                            foundMatch = true;\r\n                        }\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrix(\r\n            dataViewMatrix: DataViewMatrix,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewMatrix {\r\n\r\n            let evalContext = createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\r\n            let rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            let rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n\r\n            if (rewrittenRows || rewrittenCols) {\r\n                let rewrittenMatrix = inheritSingle(dataViewMatrix);\r\n\r\n                if (rewrittenRows)\r\n                    rewrittenMatrix.rows = rewrittenRows;\r\n                if (rewrittenCols)\r\n                    rewrittenMatrix.columns = rewrittenCols;\r\n\r\n                return rewrittenMatrix;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixHierarchy(\r\n            evalContext: IEvalContext,\r\n            dataViewMatrixHierarchy: DataViewHierarchy,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewHierarchy {\r\n            debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (!dataViewMatrixHierarchy)\r\n                return;\r\n\r\n            let root = dataViewMatrixHierarchy.root;\r\n            if (!root)\r\n                return;\r\n\r\n            let rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            if (rewrittenRoot) {\r\n                let rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\r\n                rewrittenHierarchy.root = rewrittenRoot;\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixNode(\r\n            evalContext: IEvalContext,\r\n            dataViewNode: DataViewMatrixNode,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewMatrixNode {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(dataViewNode, 'dataViewNode');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let childNodes = dataViewNode.children;\r\n            if (!childNodes)\r\n                return;\r\n\r\n            let rewrittenNode: DataViewMatrixNode;\r\n            let shouldSearchChildren: boolean;\r\n            let childIdentityFields = dataViewNode.childIdentityFields;\r\n            if (childIdentityFields) {\r\n                // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\r\n                shouldSearchChildren = Selector.matchesKeys(selector, <SQExpr[][]>[childIdentityFields]);\r\n            }\r\n\r\n            for (let i = 0, len = childNodes.length; i < len; i++) {\r\n                let childNode = childNodes[i],\r\n                    identity = childNode.identity,\r\n                    rewrittenChildNode: DataViewMatrixNode = null;\r\n\r\n                if (shouldSearchChildren) {\r\n                    if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                        // TODO: Need to initialize context for rule-based properties.  Rule-based properties\r\n                        // (such as fillRule/gradients) are not currently implemented.\r\n\r\n                        let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                        if (objects) {\r\n                            rewrittenChildNode = inheritSingle(childNode);\r\n                            rewrittenChildNode.objects = objects;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rewrittenChildNode = evaluateDataRepetitionMatrixNode(\r\n                        evalContext,\r\n                        childNode,\r\n                        objectDescriptors,\r\n                        selector,\r\n                        rules,\r\n                        containsWildcard,\r\n                        objectDefns);\r\n                }\r\n\r\n                if (rewrittenChildNode) {\r\n                    if (!rewrittenNode)\r\n                        rewrittenNode = inheritNodeAndChildren(dataViewNode);\r\n                    rewrittenNode.children[i] = rewrittenChildNode;\r\n\r\n                    if (!containsWildcard) {\r\n                        // NOTE: once we find a match for a non-wildcard selector, stop looking.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return rewrittenNode;\r\n        }\r\n\r\n        function inheritNodeAndChildren(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            if (Object.getPrototypeOf(node) !== Object.prototype) {\r\n                return node;\r\n            }\r\n\r\n            let inherited = inheritSingle(node);\r\n            inherited.children = inherit(node.children);\r\n            return inherited;\r\n        }\r\n\r\n        function evaluateDataRepetitionTable(\r\n            dataViewTable: DataViewTable,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewTable {\r\n            debug.assertValue(dataViewTable, 'dataViewTable');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let evalContext = createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\r\n            let rewrittenRows = evaluateDataRepetitionTableRows(\r\n                evalContext,\r\n                dataViewTable.columns,\r\n                dataViewTable.rows,\r\n                dataViewTable.identity,\r\n                dataViewTable.identityFields,\r\n                objectDescriptors,\r\n                selector,\r\n                rules,\r\n                containsWildcard,\r\n                objectDefns);\r\n\r\n            if (rewrittenRows) {\r\n                let rewrittenTable = inheritSingle(dataViewTable);\r\n                rewrittenTable.rows = rewrittenRows;\r\n\r\n                return rewrittenTable;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionTableRows(\r\n            evalContext: ITableEvalContext,\r\n            columns: DataViewMetadataColumn[],\r\n            rows: DataViewTableRow[],\r\n            identities: DataViewScopeIdentity[],\r\n            identityFields: ISQExpr[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewTableRow[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(rows, 'rows');\r\n            debug.assertAnyValue(identities, 'identities');\r\n            debug.assertAnyValue(identityFields, 'identityFields');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (_.isEmpty(identities) || _.isEmpty(identityFields))\r\n                return;\r\n\r\n            if (!selector.metadata ||\r\n                !Selector.matchesKeys(selector, <SQExpr[][]>[identityFields]))\r\n                return;\r\n\r\n            let colIdx = _.findIndex(columns, col => col.queryName === selector.metadata);\r\n            if (colIdx < 0)\r\n                return;\r\n\r\n            debug.assert(rows.length === identities.length, 'row length mismatch');\r\n            let colLen = columns.length;\r\n            let inheritedRows: DataViewTableRow[];\r\n\r\n            for (let rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\r\n                let identity = identities[rowIdx];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(rowIdx);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        if (!inheritedRows)\r\n                            inheritedRows = inheritSingle(rows);\r\n\r\n                        let inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\r\n                        let objectsForColumns = inheritedRow.objects;\r\n                        if (!objectsForColumns)\r\n                            inheritedRow.objects = objectsForColumns = new Array(colLen);\r\n\r\n                        objectsForColumns[colIdx] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return inheritedRows;\r\n        }\r\n\r\n        function evaluateMetadataRepetition(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n            // revisit this, likely when we do lazy evaluation of DataView.\r\n            let columns = dataView.metadata.columns,\r\n                metadataId = selector.metadata,\r\n                evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n                if (column.queryName === metadataId) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects)\r\n                        column.objects = objects;\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Attempts to find a column that can possibly match the selector. */\r\n        function findSelectedCategoricalColumn(dataViewCategorical: DataViewCategorical, selector: Selector) {\r\n            debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\r\n\r\n            let categoricalColumn = dataViewCategorical.categories[0];\r\n            if (!categoricalColumn.identityFields)\r\n                return;\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[categoricalColumn.identityFields]))\r\n                return;\r\n\r\n            let identities = categoricalColumn.identity,\r\n                targetColumn: DataViewCategoricalColumn = categoricalColumn;\r\n\r\n            let selectedMetadataId = selector.metadata;\r\n            if (selectedMetadataId) {\r\n                let valueColumns = dataViewCategorical.values;\r\n                if (valueColumns) {\r\n                    for (let i = 0, len = valueColumns.length; i < len; i++) {\r\n                        let valueColumn = valueColumns[i];\r\n                        if (valueColumn.source.queryName === selectedMetadataId) {\r\n                            targetColumn = valueColumn;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                column: targetColumn,\r\n                identities: identities,\r\n            };\r\n        }\r\n\r\n        function findSelectorForRuleInput(dataView: DataView, selectorRoles: string[]): Selector {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectorRoles, 'selectorRoles');\r\n\r\n            if (selectorRoles.length !== 1)\r\n                return;\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let categories = dataViewCategorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let categoryColumn = categories[0],\r\n                categoryRoles = categoryColumn.source.roles,\r\n                categoryIdentityFields = categoryColumn.identityFields;\r\n            if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\r\n                return;\r\n\r\n            return { data: [DataViewScopeWildcard.fromExprs(<SQExpr[]>categoryIdentityFields)] };\r\n        }\r\n\r\n        function findFirstQueryNameForExpr(selectTransforms: DataViewSelectTransform[], expr: SQExpr): string {\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (SQExpr.isSelectRef(expr))\r\n                return expr.expressionName;\r\n\r\n            if (!selectTransforms)\r\n                return;\r\n\r\n            for (let i = 0, len = selectTransforms.length; i < len; i++) {\r\n                let select = selectTransforms[i],\r\n                    columnExpr = select.expr;\r\n\r\n                if (!columnExpr || !SQExpr.equals(expr, select.expr))\r\n                    continue;\r\n\r\n                return select.queryName;\r\n            }\r\n        }\r\n\r\n        /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\r\n        function findRuleInputColumnNumberRange(dataView: DataView, identifier: string, identifierKind: ColumnIdentifierKind): NumberRange {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n\r\n            let columns = dataView.metadata.columns;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n\r\n                if (identifierKind === ColumnIdentifierKind.Role) {\r\n                    let valueColRoles = column.roles;\r\n\r\n                    if (!valueColRoles || !valueColRoles[identifier])\r\n                        continue;\r\n                }\r\n                else {\r\n                    debug.assert(identifierKind === ColumnIdentifierKind.QueryName, 'identifierKind === ColumnIdentifierKind.QueryName');\r\n\r\n                    if (column.queryName !== identifier)\r\n                        continue;\r\n                }\r\n\r\n                let aggregates = column.aggregates;\r\n                if (!aggregates)\r\n                    continue;\r\n\r\n                let min = <number>aggregates.min;\r\n                if (min === undefined)\r\n                    min = <number>aggregates.minLocal;\r\n                if (min === undefined)\r\n                    continue;\r\n\r\n                let max = <number>aggregates.max;\r\n                if (max === undefined)\r\n                    max = <number>aggregates.maxLocal;\r\n                if (max === undefined)\r\n                    continue;\r\n\r\n                return { min: min, max: max };\r\n            }\r\n        }\r\n\r\n        // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\r\n        export function createValueColumns(\r\n            values: DataViewValueColumn[] = [],\r\n            valueIdentityFields?: SQExpr[],\r\n            source?: DataViewMetadataColumn): DataViewValueColumns {\r\n            let result = <DataViewValueColumns>values;\r\n            setGrouped(<DataViewValueColumns>values);\r\n\r\n            if (valueIdentityFields)\r\n                result.identityFields = valueIdentityFields;\r\n\r\n            if (source)\r\n                result.source = source;\r\n\r\n            return result;\r\n        }\r\n\r\n        export function setGrouped(values: DataViewValueColumns, groupedResult?: DataViewValueColumnGroup[]): void {\r\n            values.grouped = groupedResult\r\n                ? () => groupedResult\r\n                : () => groupValues(values);\r\n        }\r\n\r\n        /** Group together the values with a common identity. */\r\n        function groupValues(values: DataViewValueColumn[]): DataViewValueColumnGroup[] {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let groups: DataViewValueColumnGroup[] = [],\r\n                currentGroup: DataViewValueColumnGroup;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n\r\n                if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                    currentGroup = {\r\n                        values: []\r\n                    };\r\n\r\n                    if (value.identity) {\r\n                        currentGroup.identity = value.identity;\r\n\r\n                        let source = value.source;\r\n\r\n                        // allow null, which will be formatted as (Blank).\r\n                        if (source.groupName !== undefined)\r\n                            currentGroup.name = source.groupName;\r\n                        else if (source.displayName)\r\n                            currentGroup.name = source.displayName;\r\n                    }\r\n\r\n                    groups.push(currentGroup);\r\n                }\r\n\r\n                currentGroup.values.push(value);\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function pivotIfNecessary(dataView: DataView, dataViewMappings: DataViewMapping[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let transformedDataView: DataView;\r\n            switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\r\n                case CategoricalDataViewTransformation.Pivot:\r\n                    transformedDataView = DataViewPivotCategorical.apply(dataView);\r\n                    break;\r\n\r\n                case CategoricalDataViewTransformation.SelfCrossJoin:\r\n                    transformedDataView = DataViewSelfCrossJoin.apply(dataView);\r\n                    break;\r\n            }\r\n\r\n            return transformedDataView || dataView;\r\n        }\r\n\r\n        function determineCategoricalTransformation(categorical: DataViewCategorical, dataViewMappings: DataViewMapping[]): CategoricalDataViewTransformation {\r\n            if (!categorical || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values))\r\n                return;\r\n\r\n            if (values.grouped().some(vg => !!vg.identity))\r\n                return;\r\n\r\n            // If we made it here, the DataView has a single category and no valueGrouping.\r\n            let categoryRoles = categories[0].source.roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingCategorical = dataViewMappings[i].categorical;\r\n                if (!roleMappingCategorical)\r\n                    continue;\r\n\r\n                if (!hasRolesGrouped(categoryRoles, <DataViewGroupedRoleMapping>roleMappingCategorical.values))\r\n                    continue;\r\n\r\n                // If we made it here, the DataView's single category has the value grouping role.\r\n                let categoriesMapping = roleMappingCategorical.categories;\r\n                let hasCategoryRole =\r\n                    hasRolesBind(categoryRoles, <DataViewRoleBindMappingWithReduction>categoriesMapping) ||\r\n                    hasRolesFor(categoryRoles, <DataViewRoleForMappingWithReduction>categoriesMapping);\r\n\r\n                if (hasCategoryRole)\r\n                    return CategoricalDataViewTransformation.SelfCrossJoin;\r\n\r\n                return CategoricalDataViewTransformation.Pivot;\r\n            }\r\n        }\r\n\r\n        function shouldPivotMatrix(matrix: DataViewMatrix, dataViewMappings: DataViewMapping[]): boolean {\r\n            if (!matrix || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let rowLevels = matrix.rows.levels;\r\n            if (rowLevels.length < 1)\r\n                return;\r\n\r\n            let rows = matrix.rows.root.children;\r\n            if (!rows || rows.length === 0)\r\n                return;\r\n\r\n            let rowRoles = rowLevels[0].sources[0].roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingMatrix = dataViewMappings[i].matrix;\r\n                if (!roleMappingMatrix)\r\n                    continue;\r\n\r\n                if (!hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.rows) &&\r\n                    hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.columns)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function hasRolesBind(roles: { [name: string]: boolean }, roleMapping: DataViewRoleBindMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.bind)\r\n                return roles[roleMapping.bind.to];\r\n        }\r\n\r\n        function hasRolesFor(roles: { [name: string]: boolean }, roleMapping: DataViewRoleForMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.for)\r\n                return roles[roleMapping.for.in];\r\n        }\r\n\r\n        function hasRolesGrouped(roles: { [name: string]: boolean }, roleMapping: DataViewGroupedRoleMapping): boolean {\r\n            if (roles && roleMapping && roleMapping.group)\r\n                return roles[roleMapping.group.by];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\r\n\r\n    export function createDisplayNameGetter(displayNameKey: string): (IStringResourceProvider) => string {\r\n        return (resourceProvider: IStringResourceProvider) => resourceProvider.get(displayNameKey);\r\n    }\r\n\r\n    export function getDisplayName(displayNameGetter: data.DisplayNameGetter, resourceProvider: jsCommon.IStringResourceProvider): string {\r\n        if (typeof displayNameGetter === 'function')\r\n            return displayNameGetter(resourceProvider);\r\n\r\n        if (typeof displayNameGetter === 'string')\r\n            return displayNameGetter;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    /** Enumeration of DateTimeUnits */\r\n    export enum DateTimeUnit {\r\n        Year,\r\n        Month,\r\n        Week,\r\n        Day,\r\n        Hour,\r\n        Minute,\r\n        Second,\r\n        Millisecond,\r\n    }\r\n\r\n    export interface IFormattingService {\r\n        /** \r\n         * Formats the value using provided format expression and culture\r\n         * @param value - value to be formatted and converted to string.\r\n         * @param format - format to be applied. If undefined or empty then generic format is used.        \r\n         */\r\n        formatValue(value: any, format?: string): string;\r\n\r\n        /** \r\n         * Replaces the indexed format tokens (for example {0:c2}) in the format string with the localized formatted arguments.\r\n         * @param formatWithIndexedTokens - format string with a set of indexed format tokens.\r\n         * @param args - array of values which should replace the tokens in the format string.\r\n         * @param culture - localization culture. If undefined then the current culture is used.\r\n         */\r\n        format(formatWithIndexedTokens: string, args: any[], culture?: string): string;\r\n\r\n        /** Gets a value indicating whether the specified format a standard numeric format specifier. */\r\n        isStandardNumberFormat(format: string): boolean;\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string): string;\r\n\r\n        /** Gets the format string to use for dates in particular units. */\r\n        dateFormatString(unit: DateTimeUnit): string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Represents common expression patterns for 'field' expressions such as columns, column aggregates, measures, etc. */\r\n    export interface FieldExprPattern {\r\n        column?: FieldExprColumnPattern;\r\n        columnAggr?: FieldExprColumnAggrPattern;\r\n        columnHierarchyLevelVariation?: FieldExprColumnHierarchyLevelVariationPattern;\r\n        entity?: FieldExprEntityPattern;\r\n        entityAggr?: FieldExprEntityAggrPattern;\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        hierarchyLevel?: FieldExprHierarchyLevelPattern;\r\n        hierarchyLevelAggr?: FieldExprHierarchyLevelAggrPattern;\r\n        measure?: FieldExprMeasurePattern;\r\n        percentile?: FieldExprPercentilePattern;\r\n        percentOfGrandTotal?: FieldExprPercentOfGrandTotalPattern;\r\n        selectRef?: FieldExprSelectRefPattern;\r\n    }\r\n\r\n    /** By design there is no default, no-op visitor. Components concerned with patterns need to be aware of all patterns as they are added. */\r\n    export interface IFieldExprPatternVisitor<T> {\r\n        visitColumn(column: FieldExprColumnPattern): T;\r\n        visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): T;\r\n        visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): T;\r\n        visitEntity(entity: FieldExprEntityPattern): T;\r\n        visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): T;\r\n        visitHierarchy(hierarchy: FieldExprHierarchyPattern): T;\r\n        visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): T;\r\n        visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): T;\r\n        visitMeasure(measure: FieldExprMeasurePattern): T;\r\n        visitPercentile(percentile: FieldExprPercentilePattern): T;\r\n        visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): T;\r\n        visitSelectRef(selectRef: FieldExprSelectRefPattern): T;\r\n    }\r\n\r\n    export interface FieldExprEntityPattern {\r\n        schema: string;\r\n        entity: string;\r\n        entityVar?: string;\r\n    }\r\n\r\n    export interface FieldExprEntityItemPattern extends FieldExprEntityPattern {\r\n    }\r\n\r\n    export interface FieldExprEntityPropertyPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n    }\r\n\r\n    export type FieldExprColumnPattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprMeasurePattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprHierarchyPattern = FieldExprEntityPropertyPattern;\r\n\r\n    export type FieldExprPropertyPattern = FieldExprColumnPattern | FieldExprMeasurePattern | FieldExprHierarchyPattern;\r\n\r\n    export interface FieldExprEntityAggrPattern extends FieldExprEntityPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnAggrPattern extends FieldExprColumnPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n        level: string;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelAggrPattern extends FieldExprHierarchyLevelPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnHierarchyLevelVariationPattern {\r\n        source: FieldExprColumnPattern;\r\n        level: FieldExprHierarchyLevelPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    export interface FieldExprPercentilePattern {\r\n        arg: FieldExprPattern;\r\n        k: number;\r\n        exclusive: boolean;\r\n    }\r\n\r\n    export interface FieldExprPercentOfGrandTotalPattern {\r\n        baseExpr: FieldExprPattern;\r\n    }\r\n\r\n    export interface FieldExprSelectRefPattern {\r\n        expressionName: string;\r\n    }\r\n\r\n    export module SQExprBuilder {\r\n        export function fieldExpr(fieldExpr: FieldExprPattern): SQExpr {\r\n            let sqExpr = FieldExprPattern.visit<SQExpr>(fieldExpr, FieldExprToSQExprVisitor.instance);\r\n            debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\r\n            return sqExpr;\r\n        }\r\n\r\n        export function fromColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromColumn(columnAggr), columnAggr.aggregate);\r\n        }\r\n\r\n        export function fromColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return columnRef(fromEntity(column), column.name);\r\n        }\r\n\r\n        export function fromEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n            return entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\r\n        }\r\n\r\n        export function fromEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromEntity(entityAggr), entityAggr.aggregate);\r\n        }\r\n\r\n        export function fromHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\r\n        }\r\n\r\n        export function fromHierarchyLevel(hierarchyLevelPattern: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n            return hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\r\n        }\r\n\r\n        export function fromHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n            return hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\r\n        }\r\n\r\n        class FieldExprToSQExprVisitor implements IFieldExprPatternVisitor<SQExpr> {\r\n            public static instance: FieldExprToSQExprVisitor = new FieldExprToSQExprVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n                return fromColumn(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n                return fromColumnAggr(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariationPattern: FieldExprColumnHierarchyLevelVariationPattern): SQPropertyVariationSourceExpr {\r\n                return propertyVariationSource(\r\n                    this.visitEntity(columnHierarchyLevelVariationPattern.source),\r\n                    columnHierarchyLevelVariationPattern.source.name,\r\n                    columnHierarchyLevelVariationPattern.level.name);\r\n            }\r\n\r\n            public visitEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n                return fromEntity(entityPattern);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n                return fromEntityAggr(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n                return fromHierarchy(hierarchyPattern);\r\n            }\r\n\r\n            public visitHierarchyLevel(level: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n                return fromHierarchyLevel(level);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n                return fromHierarchyLevelAggr(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): SQMeasureRefExpr {\r\n                return measureRef(this.visitEntity(measure), measure.name);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): SQPercentileExpr {\r\n                let arg = SQExprBuilder.fieldExpr(percentile.arg);\r\n                return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): SQArithmeticExpr {\r\n                let baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);\r\n                return arithmetic(\r\n                    baseSQExpr,\r\n                    SQExprBuilder.scopedEval(baseSQExpr, []),\r\n                    ArithmeticOperatorKind.Divide);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQSelectRefExpr {\r\n                return SQExprBuilder.selectRef(selectRef.expressionName);\r\n            }\r\n        }\r\n    }\r\n\r\n    export module SQExprConverter {\r\n        export function asFieldPattern(sqExpr: SQExpr): FieldExprPattern {\r\n            return sqExpr.accept(FieldExprPatternBuilder.instance);\r\n        }\r\n    }\r\n\r\n    interface FieldExprSourceVariationPattern {\r\n        column: FieldExprColumnPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    interface SourceExprPattern {\r\n        entity?: FieldExprEntityPattern;\r\n\r\n        // TODO: Change FieldExprHierarchyPattern to FieldExprHierarchyLevelPattern\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    interface HierarchySourceExprPattern {\r\n        hierarchy: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    class FieldExprPatternBuilder extends DefaultSQExprVisitor<FieldExprPattern> {\r\n        public static instance: FieldExprPatternBuilder = new FieldExprPatternBuilder();\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let columnRef = <FieldExprColumnPattern>sourceRef.entity;\r\n                columnRef.name = expr.ref;\r\n\r\n                return { column: columnRef };\r\n            }\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let measureRef = <FieldExprMeasurePattern>sourceRef.entity;\r\n                measureRef.name = expr.ref;\r\n\r\n                return { measure: measureRef };\r\n            }\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): FieldExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): FieldExprPattern {\r\n            let fieldPattern: FieldExprPattern = expr.arg.accept(this);\r\n            if (fieldPattern && fieldPattern.column) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.column;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.columnAggr) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.columnAggr;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.hierarchyLevel) {\r\n                let argAggr = <FieldExprHierarchyLevelAggrPattern>fieldPattern.hierarchyLevel;\r\n                argAggr.aggregate = expr.func;\r\n                return { hierarchyLevelAggr: argAggr };\r\n            }\r\n\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let argAggr = <FieldExprEntityAggrPattern>sourcePattern.entity;\r\n                argAggr.aggregate = expr.func;\r\n\r\n                return { entityAggr: argAggr };\r\n            }\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): FieldExprPattern {\r\n            return {\r\n                percentile: {\r\n                    arg: expr.arg.accept(this),\r\n                    k: expr.k,\r\n                    exclusive: expr.exclusive,\r\n                }\r\n            };\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): FieldExprPattern {\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let hierarchyRef = <FieldExprHierarchyPattern>(sourcePattern.entity);\r\n                hierarchyRef.name = expr.hierarchy;\r\n                return { hierarchy: hierarchyRef };\r\n            }\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): FieldExprPattern {\r\n            let hierarchySourceExprPattern: HierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\r\n            if (!hierarchySourceExprPattern)\r\n                return;\r\n\r\n            let hierarchyLevel: FieldExprHierarchyLevelPattern;\r\n            if (hierarchySourceExprPattern.hierarchy) {\r\n                hierarchyLevel = {\r\n                    entity: hierarchySourceExprPattern.hierarchy.entity,\r\n                    schema: hierarchySourceExprPattern.hierarchy.schema,\r\n                    name: hierarchySourceExprPattern.hierarchy.name,\r\n                    level: expr.level,\r\n                };\r\n            }\r\n\r\n            if (hierarchySourceExprPattern.variation) {\r\n                return {\r\n                    columnHierarchyLevelVariation: {\r\n                        source: {\r\n                            entity: hierarchySourceExprPattern.variation.column.entity,\r\n                            schema: hierarchySourceExprPattern.variation.column.schema,\r\n                            name: hierarchySourceExprPattern.variation.column.name,\r\n                        },\r\n                        level: hierarchyLevel,\r\n                        variationName: hierarchySourceExprPattern.variation.variationName,\r\n                    }\r\n                };\r\n            }\r\n\r\n            return { hierarchyLevel: hierarchyLevel };\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): FieldExprPattern {\r\n            let percentOfGrandTotalPattern: FieldExprPattern = {\r\n                percentOfGrandTotal: {\r\n                    baseExpr: expr.left.accept(this)\r\n                }\r\n            };\r\n\r\n            if (SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern))) {\r\n                return percentOfGrandTotalPattern;\r\n            }\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): FieldExprPattern {\r\n            return {\r\n                selectRef: {\r\n                    expressionName: expr.expressionName,\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    class SourceExprPatternBuilder extends DefaultSQExprVisitor<SourceExprPattern> {\r\n        public static instance: SourceExprPatternBuilder = new SourceExprPatternBuilder();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SourceExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SourceExprPattern {\r\n            let entityExpr = <SQEntityExpr>expr.arg;\r\n\r\n            if (entityExpr instanceof SQEntityExpr) {\r\n                let propertyVariationSource: FieldExprColumnPattern = {\r\n                    schema: entityExpr.schema,\r\n                    entity: entityExpr.entity,\r\n                    name: expr.property,\r\n                };\r\n\r\n                if (entityExpr.variable)\r\n                    propertyVariationSource.entityVar = entityExpr.variable;\r\n\r\n                return {\r\n                    variation: {\r\n                        column: propertyVariationSource,\r\n                        variationName: expr.name,\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    class HierarchyExprPatternBuiler extends DefaultSQExprVisitor<HierarchySourceExprPattern> {\r\n        public static instance: HierarchyExprPatternBuiler = new HierarchyExprPatternBuiler();\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): HierarchySourceExprPattern {\r\n            let exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            let hierarchyRef: FieldExprHierarchyPattern;\r\n            let variationRef: FieldExprSourceVariationPattern;\r\n\r\n            if (exprPattern.variation) {\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.variation.column.schema,\r\n                    entity: exprPattern.variation.column.entity,\r\n                };\r\n                variationRef = exprPattern.variation;\r\n            }\r\n            else\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.entity.schema,\r\n                    entity: exprPattern.entity.entity,\r\n                };\r\n\r\n            return {\r\n                hierarchy: hierarchyRef,\r\n                variation: variationRef\r\n            };\r\n        }\r\n    }\r\n\r\n    export module FieldExprPattern {\r\n\r\n        export function visit<T>(expr: SQExpr | FieldExprPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let fieldExprPattern = expr instanceof SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\r\n            debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\r\n\r\n            if (fieldExprPattern.column)\r\n                return visitColumn(fieldExprPattern.column, visitor);\r\n            if (fieldExprPattern.columnAggr)\r\n                return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation)\r\n                return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\r\n            if (fieldExprPattern.entity)\r\n                return visitEntity(fieldExprPattern.entity, visitor);\r\n            if (fieldExprPattern.entityAggr)\r\n                return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\r\n            if (fieldExprPattern.hierarchy)\r\n                return visitHierarchy(fieldExprPattern.hierarchy, visitor);\r\n            if (fieldExprPattern.hierarchyLevel)\r\n                return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\r\n            if (fieldExprPattern.hierarchyLevelAggr)\r\n                return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\r\n            if (fieldExprPattern.measure)\r\n                return visitMeasure(fieldExprPattern.measure, visitor);\r\n            if (fieldExprPattern.percentile)\r\n                return visitPercentile(fieldExprPattern.percentile, visitor);\r\n            if (fieldExprPattern.percentOfGrandTotal)\r\n                return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);\r\n            if (fieldExprPattern.selectRef)\r\n                return visitSelectRef(fieldExprPattern.selectRef, visitor);\r\n\r\n            debug.assertFail('failed to visit a fieldExprPattern.');\r\n            return;\r\n        }\r\n\r\n        function visitColumn<T>(column: FieldExprColumnPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(column, 'column');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumn(column);\r\n        }\r\n\r\n        function visitColumnAggr<T>(columnAggr: FieldExprColumnAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(columnAggr, 'columnAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnAggr(columnAggr);\r\n        }\r\n\r\n        function visitColumnHierarchyLevelVariation<T>(\r\n            columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern,\r\n            visitor: IFieldExprPatternVisitor<T>): T {\r\n\r\n            debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\r\n        }\r\n\r\n        function visitEntity<T>(entity: FieldExprEntityPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(entity, 'entity');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntity(entity);\r\n        }\r\n\r\n        function visitEntityAggr<T>(entityAggr: FieldExprEntityAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(entityAggr, 'entityAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntityAggr(entityAggr);\r\n        }\r\n\r\n        function visitHierarchy<T>(hierarchy: FieldExprHierarchyPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchy(hierarchy);\r\n        }\r\n\r\n        function visitHierarchyLevel<T>(hierarchyLevel: FieldExprHierarchyLevelPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevel(hierarchyLevel);\r\n        }\r\n\r\n        function visitHierarchyLevelAggr<T>(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\r\n        }\r\n\r\n        function visitMeasure<T>(measure: FieldExprMeasurePattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(measure, 'measure');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitMeasure(measure);\r\n        }\r\n\r\n        function visitSelectRef<T>(selectRef: FieldExprSelectRefPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(selectRef, 'selectRef');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitSelectRef(selectRef);\r\n        }\r\n\r\n        function visitPercentile<T>(percentile: FieldExprPercentilePattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(percentile, 'percentile');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitPercentile(percentile);\r\n        }\r\n\r\n        function visitPercentOfGrandTotal<T>(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);\r\n        }\r\n\r\n        export function toColumnRefSQExpr(columnPattern: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return SQExprBuilder.columnRef(\r\n                SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar),\r\n                columnPattern.name);\r\n        }\r\n\r\n        export function getAggregate(fieldExpr: FieldExprPattern): QueryAggregateFunction {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n\r\n            return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\r\n        }\r\n\r\n        export function isAggregation(fieldExpr: FieldExprPattern): boolean {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n\r\n            return visit(fieldExpr, FieldExprPatternIsAggregationVisitor.instance);\r\n        }\r\n\r\n        export function hasFieldExprName(fieldExpr: FieldExprPattern): boolean {\r\n            return (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure) !== undefined;\r\n        }\r\n\r\n        export function getPropertyName(fieldExpr: FieldExprPattern): string {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprPropertyNameVisitor.instance);\r\n        }\r\n\r\n        export function getHierarchyName(fieldExpr: FieldExprPattern): string {\r\n            let hierarchy = fieldExpr.hierarchy;\r\n            if (hierarchy)\r\n                return hierarchy.name;\r\n        }\r\n\r\n        export function getColumnRef(fieldExpr: FieldExprPattern): FieldExprPropertyPattern {\r\n            if (fieldExpr.columnHierarchyLevelVariation)\r\n                return fieldExpr.columnHierarchyLevelVariation.source;\r\n\r\n            return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\r\n        }\r\n\r\n        export function getFieldExprName(fieldExpr: FieldExprPattern): string {\r\n            let name = getPropertyName(fieldExpr);\r\n\r\n            if (name)\r\n                return name;\r\n\r\n            // In case it is an entity\r\n            return toFieldExprEntityPattern(fieldExpr).entity;\r\n        }\r\n        \r\n        export function getSchema(fieldExpr: FieldExprPattern): string {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n            \r\n            let item = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            debug.assertAnyValue(item, 'expected fieldExpr to be an entity item');\r\n            \r\n            return item.schema;\r\n        }\r\n\r\n        export function toFieldExprEntityPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        export function toFieldExprEntityItemPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        class FieldExprPatternAggregateVisitor implements IFieldExprPatternVisitor<QueryAggregateFunction> {\r\n            public static instance: FieldExprPatternAggregateVisitor = new FieldExprPatternAggregateVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): QueryAggregateFunction {\r\n                return columnAggr.aggregate;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): QueryAggregateFunction {\r\n                return entityAggr.aggregate;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): QueryAggregateFunction {\r\n                return hierarchyLevelAggr.aggregate;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): QueryAggregateFunction {\r\n                // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but\r\n                // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.\r\n                // This should be revisited when we have UI support for the Percentile aggregate.\r\n                return;\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): QueryAggregateFunction {\r\n                return SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));\r\n            }\r\n        }\r\n\r\n        class FieldExprPatternIsAggregationVisitor implements IFieldExprPatternVisitor<boolean> {\r\n            public static instance: FieldExprPatternIsAggregationVisitor = new FieldExprPatternIsAggregationVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): boolean {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        class FieldExprToEntityExprPatternBuilder implements IFieldExprPatternVisitor<FieldExprEntityItemPattern> {\r\n            public static instance: FieldExprToEntityExprPatternBuilder = new FieldExprToEntityExprPatternBuilder();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): FieldExprEntityItemPattern {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): FieldExprEntityItemPattern {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): FieldExprEntityItemPattern {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n\r\n            private static toEntityItemExprPattern(exprPattern: FieldExprEntityItemPattern): FieldExprEntityItemPattern {\r\n                debug.assertValue(exprPattern, 'exprPattern');\r\n\r\n                let pattern: FieldExprEntityItemPattern = { schema: exprPattern.schema, entity: exprPattern.entity };\r\n\r\n                if (exprPattern.entityVar) {\r\n                    pattern.entityVar = exprPattern.entityVar;\r\n                }\r\n\r\n                return pattern;\r\n            }\r\n        }\r\n        \r\n        class FieldExprPropertyNameVisitor implements IFieldExprPatternVisitor<string> {\r\n            public static instance: FieldExprPropertyNameVisitor = new FieldExprPropertyNameVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): string {\r\n                return column.name;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): string {\r\n                return columnAggr.name;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): string {\r\n                return measure.name;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): string {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): string {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export module DataViewAnalysis {\r\n        import ArrayExtensions = jsCommon.ArrayExtensions;\r\n        import QueryProjectionsByRole = powerbi.data.QueryProjectionsByRole;\r\n        import DataViewObjectDescriptors = powerbi.data.DataViewObjectDescriptors;\r\n        import DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\r\n\r\n        export interface ValidateAndReshapeResult {\r\n            dataView?: DataView;\r\n            isValid: boolean;\r\n        }\r\n\r\n        export interface RoleKindByQueryRef {\r\n            [queryRef: string]: VisualDataRoleKind;\r\n        }\r\n\r\n        export interface DataViewMappingResult {\r\n            supportedMappings: DataViewMapping[];\r\n\r\n            /** A set of mapping errors if there are no supported mappings */\r\n            mappingErrors: DataViewMappingMatchError[];\r\n        }\r\n\r\n        export enum DataViewMappingMatchErrorCode {\r\n            conditionRangeTooLarge,\r\n            conditionRangeTooSmall,\r\n            conditionKindExpectedMeasure,\r\n            conditionKindExpectedGrouping,\r\n            conditionKindExpectedGroupingOrMeasure,\r\n        }\r\n\r\n        export interface DataViewMappingMatchError {\r\n            code: DataViewMappingMatchErrorCode;\r\n            roleName: string;\r\n            mappingIndex?: number;\r\n            conditionIndex?: number;\r\n        }\r\n\r\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\r\n        export function validateAndReshape(dataView: DataView, dataViewMappings: DataViewMapping[]): ValidateAndReshapeResult {\r\n            if (!dataViewMappings || dataViewMappings.length === 0)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            if (dataView) {\r\n                for (let dataViewMapping of dataViewMappings) {\r\n                    // Keep the original when possible.\r\n                    if (supports(dataView, dataViewMapping))\r\n                        return { dataView: dataView, isValid: true };\r\n\r\n                    if (dataViewMapping.categorical && dataView.categorical)\r\n                        return reshapeCategorical(dataView, dataViewMapping);\r\n\r\n                    if (dataViewMapping.tree && dataView.tree)\r\n                        return reshapeTree(dataView, dataViewMapping.tree);\r\n\r\n                    if (dataViewMapping.single && dataView.single)\r\n                        return reshapeSingle(dataView, dataViewMapping.single);\r\n\r\n                    if (dataViewMapping.table && dataView.table)\r\n                        return reshapeTable(dataView, dataViewMapping.table);\r\n                }\r\n            }\r\n            else if (ScriptResultUtil.findScriptResult(dataViewMappings)) {\r\n                // Currently, PBI Service treats R Script Visuals as static images.\r\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\r\n                // to support the PBI Desktop scenario.\r\n                // This code will be removed once PBI Service fully supports R Script Visuals.\r\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\r\n                return { dataView: dataView, isValid: true };\r\n            }\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeCategorical(dataView: DataView, dataViewMapping: DataViewMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\r\n\r\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\r\n            let categoryRoleMapping = dataViewMapping.categorical;\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return { isValid: false };\r\n\r\n            let rowCount;\r\n            if (categoryRoleMapping.rowCount) {\r\n                rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (rowCount && rowCount.max) {\r\n                    let updated: DataViewCategorical;\r\n                    let categories = categorical.categories;\r\n                    let maxRowCount = rowCount.max;\r\n                    let originalLength = undefined;\r\n                    if (categories) {\r\n                        for (let i = 0, len = categories.length; i < len; i++) {\r\n                            let category = categories[i];\r\n                            originalLength = category.values.length;\r\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n\r\n                                // Row count too large: Trim it to fit.\r\n                                let updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\r\n\r\n                                updated = updated || { categories: [] };\r\n                                updated.categories.push({\r\n                                    source: category.source,\r\n                                    values: updatedCategories\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\r\n                        if (!originalLength)\r\n                            originalLength = categorical.values[0].values.length;\r\n\r\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n                            updated = updated || {};\r\n                            updated.values = data.DataViewTransform.createValueColumns();\r\n\r\n                            for (let i = 0, len = categorical.values.length; i < len; i++) {\r\n                                let column = categorical.values[i],\r\n                                    updatedColumn: DataViewValueColumn = {\r\n                                        source: column.source,\r\n                                        values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\r\n                                    };\r\n\r\n                                if (column.min !== undefined)\r\n                                    updatedColumn.min = column.min;\r\n                                if (column.max !== undefined)\r\n                                    updatedColumn.max = column.max;\r\n                                if (column.subtotal !== undefined)\r\n                                    updatedColumn.subtotal = column.subtotal;\r\n\r\n                                updated.values.push(updatedColumn);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (updated) {\r\n                        dataView = {\r\n                            metadata: dataView.metadata,\r\n                            categorical: updated,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (supportsCategorical(dataView, dataViewMapping))\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return null;\r\n        }\r\n\r\n        function reshapeSingle(dataView: DataView, singleRoleMapping: DataViewSingleMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (dataView.single)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            // TODO: Need to implement the reshaping of Tree\r\n            let metadata = dataView.metadata;\r\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTable(dataView: DataView, tableRoleMapping: DataViewTableMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (dataView.table)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        export function countGroups(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (!columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        export function countMeasures(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        /** Indicates whether the dataView conforms to the specified schema. */\r\n        export function supports(dataView: DataView, roleMapping: DataViewMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            if (!roleMapping || !dataView)\r\n                return false;\r\n\r\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\r\n                return false;\r\n\r\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\r\n                return false;\r\n\r\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\r\n                return false;\r\n\r\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsCategorical(dataView: DataView, categoryRoleMapping: DataViewCategoricalMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return false;\r\n\r\n            // TODO: Disabling this implementation isn't right.\r\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\r\n            //    return false;\r\n\r\n            if (categoryRoleMapping.rowCount) {\r\n                let rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\r\n                    rowCount = categoryRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\r\n                        len = dataViewCategorical.values[0].values.length;\r\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\r\n                        len = dataViewCategorical.categories[0].values.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsSingle(dataViewSingle: DataViewSingle, singleRoleMapping: DataViewSingleMapping): boolean {\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (!dataViewSingle)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): boolean {\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            let metadata = dataView.metadata;\r\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\r\n        }\r\n\r\n        function supportsTable(dataViewTable: DataViewTable, tableRoleMapping: DataViewTableMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (!dataViewTable)\r\n                return false;\r\n\r\n            if (tableRoleMapping.rowCount) {\r\n                let rowCount = tableRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\r\n                    rowCount = tableRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewTable.rows && dataViewTable.rows.length)\r\n                        len = dataViewTable.rows.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsScriptResult(dataView: DataViewScriptResultData, scriptResultRoleMapping: DataViewScriptResultMapping): boolean {\r\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\r\n\r\n            if (!dataView)\r\n                return false;\r\n\r\n            if (!dataView.imageBase64)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the range in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        export function validateRange(value: number, roleCondition: RoleCondition, ignoreMin?: boolean): DataViewMappingMatchErrorCode {\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (!roleCondition)\r\n                return;\r\n\r\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\r\n\r\n            if (roleCondition.max !== undefined && roleCondition.max < value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        function validateKind(roleCondition: RoleCondition, roleName: string, projections: QueryProjectionsByRole, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchErrorCode {\r\n            if (!roleCondition || roleCondition.kind === undefined) {\r\n                return;\r\n            }\r\n            let expectedKind = roleCondition.kind;\r\n            let roleCollection = projections[roleName];\r\n            if (roleCollection) {\r\n                let roleProjections = roleCollection.all();\r\n                for (let roleProjection of roleProjections) {\r\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\r\n                        switch (expectedKind) {\r\n                            case VisualDataRoleKind.Measure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\r\n                            case VisualDataRoleKind.Grouping:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\r\n                            case VisualDataRoleKind.GroupingOrMeasure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Determines the appropriate DataViewMappings for the projections. */\r\n        export function chooseDataViewMappings(\r\n            projections: QueryProjectionsByRole,\r\n            mappings: DataViewMapping[],\r\n            roleKindByQueryRef: RoleKindByQueryRef,\r\n            objectDescriptors?: DataViewObjectDescriptors,\r\n            objectDefinitions?: DataViewObjectDefinitions): DataViewMappingResult {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertAnyValue(mappings, 'mappings');\r\n\r\n            let supportedMappings: DataViewMapping[] = [];\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            if (!_.isEmpty(mappings)) {\r\n                for (let mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\r\n                    let mapping = mappings[mappingIndex],\r\n                        mappingConditions = mapping.conditions,\r\n                        requiredProperties = mapping.requiredProperties;\r\n                    let allPropertiesValid: boolean = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\r\n                    let conditionsMet: DataViewMappingCondition[] = [];\r\n\r\n                    if (!_.isEmpty(mappingConditions)) {\r\n                        for (let conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\r\n                            let condition = mappingConditions[conditionIndex];\r\n                            let currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\r\n                            if (!_.isEmpty(currentConditionErrors)) {\r\n                                for (let error of currentConditionErrors) {\r\n                                    error.mappingIndex = mappingIndex;\r\n                                    error.conditionIndex = conditionIndex;\r\n                                    errors.push(error);\r\n                                }\r\n                            }\r\n                            else\r\n                                conditionsMet.push(condition);\r\n                        }\r\n                    }\r\n                    else {\r\n                        conditionsMet.push({});\r\n                    }\r\n\r\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\r\n                        let supportedMapping = _.cloneDeep(mapping);\r\n\r\n                        let updatedConditions = _.filter(conditionsMet, (condition) => Object.keys(condition).length > 0);\r\n                        if (!_.isEmpty(updatedConditions))\r\n                            supportedMapping.conditions = updatedConditions;\r\n                        supportedMappings.push(supportedMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\r\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\r\n            };\r\n        }\r\n\r\n        function checkForConditionErrors(projections: QueryProjectionsByRole, condition: DataViewMappingCondition, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchError[] {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertValue(condition, 'condition');\r\n\r\n            let conditionRoles = Object.keys(condition);\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            for (let i = 0, len = conditionRoles.length; i < len; i++) {\r\n                let roleName: string = conditionRoles[i],\r\n                    isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs),\r\n                    roleCondition = condition[roleName];\r\n\r\n                let roleCount = getPropertyCount(roleName, projections, isDrillable);\r\n                let rangeError = validateRange(roleCount, roleCondition);\r\n                if (rangeError != null) {\r\n                    errors.push({\r\n                        code: rangeError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n                let kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\r\n                if (kindError != null) {\r\n                    errors.push({\r\n                        code: kindError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return errors;\r\n        }\r\n\r\n        function areAllPropertiesValid(requiredProperties: DataViewObjectPropertyIdentifier[], objectDescriptors: DataViewObjectDescriptors, objectDefinitions?: DataViewObjectDefinitions): boolean {\r\n            if (_.isEmpty(requiredProperties))\r\n                return true;\r\n\r\n            if (!objectDescriptors || !objectDefinitions)\r\n                return false;\r\n\r\n            let staticEvalContext: data.IEvalContext = data.createStaticEvalContext();\r\n\r\n            return _.every(requiredProperties, (requiredProperty) => {\r\n                let objectDescriptorValue = null;\r\n                let objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\r\n                if (objectDescriptorProperty)\r\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\r\n                let objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\r\n\r\n                if (!objectDescriptorValue || !objectDefinitionValue)\r\n                    return false;\r\n\r\n                return data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\r\n            });\r\n        }\r\n\r\n        export function getPropertyCount(roleName: string, projections: QueryProjectionsByRole, useActiveIfAvailable?: boolean): number {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(projections, 'projections');\r\n\r\n            let projectionsForRole = projections[roleName];\r\n            if (projectionsForRole) {\r\n                if (useActiveIfAvailable)\r\n                    return 1;\r\n                return projectionsForRole.all().length;\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function hasSameCategoryIdentity(dataView1: DataView, dataView2: DataView): boolean {\r\n            if (dataView1\r\n                && dataView2\r\n                && dataView1.categorical\r\n                && dataView2.categorical) {\r\n                let dv1Categories = dataView1.categorical.categories;\r\n                let dv2Categories = dataView2.categorical.categories;\r\n                if (dv1Categories\r\n                    && dv2Categories\r\n                    && dv1Categories.length === dv2Categories.length) {\r\n                    for (let i = 0, len = dv1Categories.length; i < len; i++) {\r\n                        let dv1Identity = dv1Categories[i].identity;\r\n                        let dv2Identity = dv2Categories[i].identity;\r\n\r\n                        let dv1Length = getLengthOptional(dv1Identity);\r\n                        if (dv1Length !== getLengthOptional(dv2Identity))\r\n                            return false;\r\n\r\n                        for (let j = 0; j < dv1Length; j++) {\r\n                            if (!DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function getLengthOptional(identity: DataViewScopeIdentity[]): number {\r\n            if (identity)\r\n                return identity.length;\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function areMetadataColumnsEquivalent(column1: DataViewMetadataColumn, column2: DataViewMetadataColumn): boolean {\r\n            if (!column1 && !column2)\r\n                return true;\r\n\r\n            if (!column1 || !column2)\r\n                return false;\r\n\r\n            if (column1.displayName !== column2.displayName)\r\n                return false;\r\n\r\n            if (column1.queryName !== column2.queryName)\r\n                return false;\r\n\r\n            if (column1.isMeasure !== column2.isMeasure)\r\n                return false;\r\n\r\n            if (column1.type !== column2.type)\r\n                return false;\r\n\r\n            if (column1.sort !== column2.sort)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\r\n        export function isMetadataEquivalent(metadata1: DataViewMetadata, metadata2: DataViewMetadata): boolean {\r\n            if (!metadata1 && !metadata2)\r\n                return true;\r\n\r\n            if (!metadata1 || !metadata2)\r\n                return false;\r\n\r\n            let previousColumnsLength = metadata1.columns.length;\r\n            let newColumnsLength = metadata2.columns.length;\r\n\r\n            if (previousColumnsLength !== newColumnsLength)\r\n                return false;\r\n\r\n            for (let i: number = 0; i < newColumnsLength; i++) {\r\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewRoleWildcard {\r\n        export function fromRoles(roles: string[]): DataViewRoleWildcard {\r\n            return new DataViewRoleWildcardImpl(roles);\r\n        }\r\n\r\n        export function equals(firstRoleWildcard: DataViewRoleWildcard, secondRoleWildcard: DataViewRoleWildcard): boolean {\r\n            return firstRoleWildcard.key &&\r\n                secondRoleWildcard.key &&\r\n                firstRoleWildcard.key === secondRoleWildcard.key &&\r\n                ArrayExtensions.sequenceEqual<string>(\r\n                    firstRoleWildcard.roles,\r\n                    secondRoleWildcard.roles,\r\n                    (role1: string, role2: string) => role1 === role2);\r\n        }\r\n\r\n        class DataViewRoleWildcardImpl implements DataViewRoleWildcard {\r\n            private _roles: string[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(roles: string[]) {\r\n                debug.assertNonEmpty(roles, 'roles');\r\n\r\n                this._roles = roles;\r\n                this._key = new Lazy<string>(() => JSON.stringify(this.roles));\r\n            }\r\n\r\n            public get roles(): string[] {\r\n                return this._roles;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewScopeIdentity {\r\n        /** Compares the two DataViewScopeIdentity values for equality. */\r\n        export function equals(x: DataViewScopeIdentity, y: DataViewScopeIdentity, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            return data.SQExpr.equals(<data.SQExpr>x.expr, <data.SQExpr>y.expr, ignoreCase);\r\n        }\r\n\r\n        export function filterFromIdentity(identities: DataViewScopeIdentity[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(identities))\r\n                return;\r\n            \r\n            let exprs: data.SQExpr[] = [];\r\n            for (let identity of identities) {\r\n                exprs.push(<data.SQExpr>identity.expr);\r\n            }\r\n\r\n            return filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function filterFromExprs(orExprs: data.SQExpr[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(orExprs))\r\n                return;\r\n\r\n            let resultExpr: data.SQExpr;\r\n            for (let orExpr of orExprs) {\r\n                let inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\r\n                if (resultExpr)\r\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\r\n                else\r\n                    resultExpr = inExpr || orExpr;\r\n            }\r\n            \r\n            if (resultExpr) {\r\n                if (isNot)\r\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\r\n            }\r\n\r\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\r\n        }\r\n    }\r\n\r\n    export module data {\r\n        import Lazy = jsCommon.Lazy;\r\n\r\n        export function createDataViewScopeIdentity(expr: SQExpr): DataViewScopeIdentity {\r\n            return new DataViewScopeIdentityImpl(expr);\r\n        }\r\n\r\n        class DataViewScopeIdentityImpl implements DataViewScopeIdentity {\r\n            private _expr: SQExpr;\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(expr: SQExpr) {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                this._expr = expr;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serialize(expr));\r\n            }\r\n\r\n            public get expr(): SQExpr {\r\n                return this._expr;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewScopeWildcard {\r\n        export function matches(wildcard: DataViewScopeWildcard, instance: DataViewScopeIdentity): boolean {\r\n            let instanceExprs = ScopeIdentityExtractor.getKeys(<SQExpr>instance.expr);\r\n            if (!instanceExprs)\r\n                return false;\r\n\r\n            return SQExprUtils.sequenceEqual(<SQExpr[]>wildcard.exprs, instanceExprs);\r\n        }\r\n\r\n        export function equals(firstScopeWildcard: DataViewScopeWildcard, secondScopeWildcard: DataViewScopeWildcard): boolean {\r\n            return firstScopeWildcard.key === secondScopeWildcard.key &&\r\n                SQExprUtils.sequenceEqual(<SQExpr[]>firstScopeWildcard.exprs, <SQExpr[]>secondScopeWildcard.exprs);\r\n        }\r\n\r\n        export function fromExprs(exprs: SQExpr[]): DataViewScopeWildcard {\r\n            return new DataViewScopeWildcardImpl(exprs);\r\n        }\r\n\r\n        class DataViewScopeWildcardImpl implements DataViewScopeWildcard {\r\n            private _exprs: SQExpr[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(exprs: SQExpr[]) {\r\n                debug.assertValue(exprs, 'exprs');\r\n\r\n                this._exprs = exprs;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serializeArray(exprs));\r\n            }\r\n\r\n            public get exprs(): SQExpr[] {\r\n                return this._exprs;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface IColorAllocatorCache {\r\n        get(key: SQFillRuleExpr): IColorAllocator;\r\n        register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this;\r\n    }\r\n\r\n    export function createColorAllocatorCache(): IColorAllocatorCache {\r\n        return new ColorAllocatorProvider();\r\n    }\r\n\r\n    interface ColorAllocatorCacheEntry {\r\n        key: SQFillRuleExpr;\r\n        allocator: IColorAllocator;\r\n    }\r\n\r\n    class ColorAllocatorProvider implements IColorAllocatorCache {\r\n        private cache: ColorAllocatorCacheEntry[];\r\n\r\n        constructor() {\r\n            this.cache = [];\r\n        }\r\n\r\n        public get(key: SQFillRuleExpr): IColorAllocator {\r\n            debug.assertValue(key, 'key');\r\n\r\n            for (let entry of this.cache) {\r\n                if (entry.key === key)\r\n                    return entry.allocator;\r\n            }\r\n        }\r\n\r\n        public register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this {\r\n            debug.assertValue(key, 'key');\r\n            debug.assertValue(colorAllocator, 'colorAllocator');\r\n            debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\r\n\r\n            this.cache.push({\r\n                key: key,\r\n                allocator: colorAllocator,\r\n            });\r\n\r\n            return this;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewRegressionRunOptions {\r\n        dataViewMappings: DataViewMapping[];\r\n        visualDataViews: DataView[];\r\n        dataRoles: VisualDataRole[];\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        objectDefinitions: DataViewObjectDefinitions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        transformSelects: DataViewSelectTransform[];\r\n        metadata: DataViewMetadata;\r\n        projectionActiveItems: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export module DataViewRegression {\r\n        // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\r\n        // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\r\n        const regressionXQueryName: string = 'RegressionX';\r\n        const regressionSeriesQueryName: string = 'RegressionSeries';\r\n        export const regressionYQueryName: string = 'RegressionY';\r\n\r\n        export function run(options: DataViewRegressionRunOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let dataViewMappings: DataViewMapping[] = options.dataViewMappings;\r\n            let visualDataViews: DataView[] = options.visualDataViews;\r\n            let dataRoles: VisualDataRole[] = options.dataRoles;\r\n            let objectDescriptors: DataViewObjectDescriptors = options.objectDescriptors;\r\n            let objectDefinitions: DataViewObjectDefinitions = options.objectDefinitions;\r\n            let colorAllocatorFactory: IColorAllocatorFactory = options.colorAllocatorFactory;\r\n            let transformSelects: DataViewSelectTransform[] = options.transformSelects;\r\n            let projectionActiveItems = options.projectionActiveItems;\r\n            let metadata: DataViewMetadata = options.metadata;\r\n\r\n            if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\r\n                // compute linear regression line if applicable\r\n                let roleKindByQueryRef: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\r\n                let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\r\n                if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\r\n                    return visualDataViews;\r\n\r\n                let applicableDataViewMappings: DataViewMapping[] = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\r\n\r\n                if (applicableDataViewMappings) {\r\n                    let regressionDataViewMapping: DataViewMapping = _.find(applicableDataViewMappings, (dataViewMapping) => {\r\n                        return dataViewMapping.usage && dataViewMapping.usage.regression;\r\n                    });\r\n\r\n                    if (regressionDataViewMapping) {\r\n                        let regressionDataViews: DataView[] = [];\r\n                        for (let visualDataView of visualDataViews) {\r\n                            let regressionDataView: DataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\r\n\r\n                            if (regressionDataView)\r\n                                regressionDataViews.push(regressionDataView);\r\n                        }\r\n\r\n                        if (!_.isEmpty(regressionDataViews))\r\n                            visualDataViews.push(...regressionDataViews);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        /**\r\n         * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\r\n         * It works on scalar axis only.\r\n         * The algorithm is as follows\r\n         *\r\n         * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\r\n         * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\r\n         * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\r\n         * If highlights values are present, repeat steps 2 & 3 using highlight values.\r\n         * 4. Create the new dataView using the points computed above\r\n         */\r\n        export function linearRegressionTransform(\r\n            sourceDataView: DataView,\r\n            dataRoles: VisualDataRole[],\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\r\n            debug.assertValue(dataRoles, 'dataRoles');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!sourceDataView.categorical)\r\n                return;\r\n\r\n            // Step 1\r\n            let xColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.X, sourceDataView.categorical, dataRoles);\r\n            let yColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.Y, sourceDataView.categorical, dataRoles);\r\n\r\n            if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\r\n                return;\r\n\r\n            let xColumnSource = xColumns[0].source;\r\n            let yColumnSource = yColumns[0].source;\r\n\r\n            let combineSeries = true;\r\n            if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\r\n                let regressionUsage = regressionDataViewMapping.usage.regression;\r\n\r\n                let combineSeriesPropertyId = regressionUsage['combineSeries'];\r\n                if (combineSeriesPropertyId) {\r\n                    combineSeries = DataViewObjects.getValue<boolean>(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\r\n                }\r\n            }\r\n\r\n            // Step 2\r\n            let dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\r\n            let lineDefSet = calculateLineDefinitions(dataPointsBySeries);\r\n            if (!lineDefSet)\r\n                return;\r\n\r\n            let xMin = lineDefSet.xMin;\r\n            let xMax = lineDefSet.xMax;\r\n\r\n            let shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\r\n            let highlightsLineDefSet: LineDefinitionSet;\r\n            if (shouldComputeHightlights) {\r\n                let highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\r\n                highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\r\n                if (highlightsLineDefSet) {\r\n                    xMin = _.min([xMin, highlightsLineDefSet.xMin]);\r\n                    xMax = _.max([xMax, highlightsLineDefSet.xMax]);\r\n                }\r\n                else {\r\n                    shouldComputeHightlights = false;\r\n                }\r\n            }\r\n\r\n            // Step 3\r\n            let valuesByTrend: number[][] = [];\r\n            for (let trend of lineDefSet.lineDefs) {\r\n                valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n            }\r\n\r\n            let highlightsByTrend: number[][];\r\n            if (shouldComputeHightlights) {\r\n                highlightsByTrend = [];\r\n                for (let trend of highlightsLineDefSet.lineDefs) {\r\n                    highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n                }\r\n            }\r\n\r\n            // Step 4\r\n            let groupValues: PrimitiveValue[];\r\n            if (combineSeries) {\r\n                groupValues = ['combinedRegressionSeries'];\r\n            }\r\n            else {\r\n                // If we are producing a trend line per series we need to maintain the group identities so that we can map between the\r\n                // trend line and the original series (to match the color for example).\r\n                if (sourceDataView.categorical.values.source) {\r\n                    // Source data view has dynamic series.\r\n                    let groups = sourceDataView.categorical.values.grouped();\r\n                    groupValues = _.map(groups, (group) => group.name);\r\n                }\r\n                else {\r\n                    // Source data view has static or no series.\r\n                    groupValues = _.map(yColumns, (column) => column.source.queryName);\r\n                }\r\n            }\r\n\r\n            // Step 5\r\n            let regressionDataView: DataView = createRegressionDataView(\r\n                xColumnSource,\r\n                yColumnSource,\r\n                groupValues,\r\n                [xMin, xMax],\r\n                valuesByTrend,\r\n                highlightsByTrend,\r\n                sourceDataView,\r\n                regressionDataViewMapping,\r\n                objectDescriptors,\r\n                objectDefinitions,\r\n                colorAllocatorFactory);\r\n\r\n            return regressionDataView;\r\n        }\r\n\r\n        function calculateLineDefinitions(dataPointsBySeries: DataPointSet[]): LineDefinitionSet {\r\n            let xMin: PrimitiveValue;\r\n            let xMax: PrimitiveValue;\r\n            let lineDefs: LineDefinition[] = [];\r\n            for (let dataPointSet of dataPointsBySeries) {\r\n                let unsortedXValues: PrimitiveValue[] = dataPointSet.xValues;\r\n                let unsortedYValues: PrimitiveValue[] = dataPointSet.yValues;\r\n\r\n                if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\r\n                    return;\r\n\r\n                // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\r\n                let xDataType: string = getDataType(unsortedXValues);\r\n                if (!xDataType)\r\n                    return;\r\n                let yDataType: string = getDataType(unsortedYValues);\r\n                if (!yDataType)\r\n                    return;\r\n\r\n                let sortedDataPointSet: DataPointSet = sortValues(unsortedXValues, unsortedYValues);\r\n                let minCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[0];\r\n                let maxCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\r\n\r\n                let lineDef: LineDefinition = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\r\n\r\n                xMin = _.min([xMin, minCategoryValue]);\r\n                xMax = _.max([xMax, maxCategoryValue]);\r\n\r\n                lineDefs.push(lineDef);\r\n            }\r\n\r\n            return {\r\n                lineDefs: lineDefs,\r\n                xMin: xMin,\r\n                xMax: xMax,\r\n            };\r\n        }\r\n\r\n        function getColumnsForCartesianRoleKind(roleKind: CartesianRoleKind, categorical: DataViewCategorical, roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            debug.assertValue(roleKind, 'roleKind');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n\r\n            let categories = categorical.categories;\r\n            if (_.isEmpty(categories))\r\n                return;\r\n\r\n            debug.assert(categories.length === 1, 'composite category columns not supported');\r\n            let categoryColumn = categories[0];\r\n            columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n        }\r\n\r\n        function getColumnsWithRoleKind(roleKind: CartesianRoleKind, columns: DataViewCategoricalColumn[], roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            if (_.isEmpty(columns))\r\n                return;\r\n\r\n            return _.filter(columns, (column) => {\r\n                for (let roleName in column.source.roles) {\r\n                    if (!column.source.roles[roleName])\r\n                        continue;\r\n\r\n                    let role = _.find(roles, (role) => role.name === roleName);\r\n                    if (role && role.cartesianKind === roleKind)\r\n                        return true;\r\n                }\r\n\r\n                return false;\r\n            });\r\n        }\r\n\r\n        function getDataType(values: PrimitiveValue[]): string {\r\n            let firstNonNull: PrimitiveValue = _.find(values, (value) => value != null);\r\n            if (firstNonNull == null)\r\n                return;\r\n\r\n            let dataType: string = typeof firstNonNull;\r\n\r\n            if (_.some(values, (value) => value != null && typeof value !== dataType))\r\n                return;\r\n\r\n            return dataType;\r\n        }\r\n\r\n        function sortValues(unsortedXValues: PrimitiveValue[], unsortedYValues: PrimitiveValue[]): DataPointSet {\r\n            debug.assertValue(unsortedXValues, 'unsortedXValues');\r\n            debug.assertValue(unsortedYValues, 'unsortedYValues');\r\n\r\n            let zippedValues = _.zip(unsortedXValues, unsortedYValues);\r\n            let [xValues, yValues] = _.chain(zippedValues)\r\n                .filter((valuePair) => valuePair[0] != null && valuePair[1] != null)\r\n                .sortBy((valuePair) => valuePair[0])\r\n                .unzip()\r\n                .value();\r\n\r\n            return {\r\n                xValues: xValues,\r\n                yValues: yValues\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Computes a line definition using linear regression.\r\n         *   xBar: average of X values, yBar: average of Y values\r\n         *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\r\n         *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\r\n         *   Slope: ssXY / ssXX\r\n         *   Intercept: yBar - xBar * slope\r\n         */\r\n        function computeRegressionLine(xValues: number[], yValues: number[]): LineDefinition {\r\n            debug.assertValue(xValues, 'xValues');\r\n            debug.assertValue(yValues, 'yValues');\r\n\r\n            let xBar = _.sum(xValues) / xValues.length;\r\n            let yBar = _.sum(yValues) / yValues.length;\r\n\r\n            let ssXX = _.chain(xValues)\r\n                .map((x) => {\r\n                    return (x - xBar) ** 2;\r\n                })\r\n                .sum();\r\n\r\n            let ssXY = _.chain(xValues)\r\n                .map((x, i) => {\r\n                    return (x - xBar) * (yValues[i] - yBar);\r\n                })\r\n                .sum();\r\n\r\n            let slope = ssXY / ssXX;\r\n            let intercept = yBar - (xBar * slope);\r\n\r\n            return {\r\n                slope: slope,\r\n                intercept: intercept\r\n            };\r\n        }\r\n\r\n        function computeLineYValues(lineDef: LineDefinition, x1: number, x2: number): number[] {\r\n            return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\r\n        }\r\n\r\n        function getValuesFromColumn(column: DataViewCategoricalColumn, preferHighlights: boolean): PrimitiveValue[] {\r\n            if (preferHighlights) {\r\n                // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                if (valueColumn.highlights) {\r\n                    return valueColumn.highlights;\r\n                }\r\n            }\r\n\r\n            return column.values;\r\n        }\r\n\r\n        function getDataPointsBySeries(xColumns: DataViewCategoricalColumn[], yColumns: DataViewCategoricalColumn[], combineSeries: boolean, preferHighlights: boolean): DataPointSet[] {\r\n            let dataPointsBySeries: DataPointSet[] = [];\r\n            let xValueArray: PrimitiveValue[][] = _.map(xColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n            let seriesYValues: PrimitiveValue[][] = _.map(yColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n\r\n            let multipleXValueColumns: boolean = xColumns.length > 1;\r\n            for (let i = 0; i < seriesYValues.length; i++) {\r\n                let xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\r\n                let yValues = seriesYValues[i];\r\n\r\n                if (combineSeries && dataPointsBySeries.length > 0) {\r\n                    dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\r\n                    dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\r\n                }\r\n                else {\r\n                    dataPointsBySeries.push({\r\n                        xValues: xValues,\r\n                        yValues: yValues,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return dataPointsBySeries;\r\n        }\r\n\r\n        function createRegressionDataView(\r\n            xColumnSource: DataViewMetadataColumn,\r\n            yColumnSource: DataViewMetadataColumn,\r\n            groupValues: PrimitiveValue[],\r\n            categories: PrimitiveValue[],\r\n            values: PrimitiveValue[][],\r\n            highlights: PrimitiveValue[][],\r\n            sourceDataView: DataView,\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(xColumnSource, 'xColumnSource');\r\n            debug.assertValue(yColumnSource, 'yColumnSource');\r\n            debug.assertValue(categories, 'categories');\r\n            debug.assertValue(values, 'values');\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertAnyValue(highlights, 'highlights');\r\n            debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\r\n\r\n            let xRole: string = (<DataViewRoleForMapping>regressionDataViewMapping.categorical.categories).for.in;\r\n            let grouped = (<DataViewGroupedRoleMapping>regressionDataViewMapping.categorical.values).group;\r\n            let yRole: string;\r\n            let seriesRole: string;\r\n            if (grouped && !_.isEmpty(grouped.select)) {\r\n                yRole = (<DataViewRoleForMapping>grouped.select[0]).for ?\r\n                    (<DataViewRoleForMapping>grouped.select[0]).for.in :\r\n                    (<DataViewRoleBindMapping>grouped.select[0]).bind.to;\r\n                seriesRole = grouped.by;\r\n            }\r\n            if (!yRole || !seriesRole)\r\n                return;\r\n\r\n            let categoricalRoles: { [name: string]: boolean } = {[xRole]: true};\r\n            let valueRoles: { [name: string]: boolean } = {[yRole]: true};\r\n            let seriesRoles: { [name: string]: boolean } = {[seriesRole]: true};\r\n\r\n            let valuesBySeries: DataViewBuilderSeriesData[][] = [];\r\n            for (let index in values) {\r\n                let seriesData: DataViewBuilderSeriesData = {\r\n                    values: values[index],\r\n                };\r\n\r\n                if (highlights)\r\n                    seriesData.highlights = highlights[index];\r\n\r\n                valuesBySeries.push([seriesData]);\r\n            }\r\n\r\n            let regressionDataView: DataView = createCategoricalDataViewBuilder()\r\n                .withCategory({\r\n                    source: {\r\n                        displayName: xColumnSource.displayName,\r\n                        queryName: regressionXQueryName,\r\n                        type: xColumnSource.type,\r\n                        isMeasure: false,\r\n                        roles: categoricalRoles\r\n                    },\r\n                    values: categories,\r\n                    identityFrom: {\r\n                        fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\r\n                    },\r\n                })\r\n                .withGroupedValues({\r\n                    groupColumn: {\r\n                        source: {\r\n                            displayName: yColumnSource.displayName + 'Regression',\r\n                            queryName: regressionSeriesQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: seriesRoles\r\n                        },\r\n                        values: groupValues,\r\n                        identityFrom: {\r\n                            fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\r\n                        }\r\n                    },\r\n                    valueColumns: [{\r\n                        source: {\r\n                            displayName: yColumnSource.displayName,\r\n                            queryName: regressionYQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: valueRoles\r\n                        },\r\n                    }],\r\n                    data: valuesBySeries\r\n                })\r\n                .build();\r\n            DataViewTransform.transformObjects(regressionDataView, data.StandardDataViewKinds.Categorical, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\r\n            return regressionDataView;\r\n        }\r\n\r\n        function hasHighlightValues(columns: DataViewCategoricalColumn[]): boolean {\r\n            return _.any(columns, (column) => {\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                return valueColumn.highlights != null;\r\n            });\r\n        }\r\n    }\r\n\r\n    interface DataPointSet {\r\n        xValues: any[];\r\n        yValues: any[];\r\n    }\r\n\r\n    interface LineDefinition {\r\n        slope: number;\r\n        intercept: number;\r\n    }\r\n\r\n    interface LineDefinitionSet {\r\n        lineDefs: LineDefinition[];\r\n        xMin: PrimitiveValue;\r\n        xMax: PrimitiveValue;\r\n    }\r\n}\r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewSelectTransform {\r\n        displayName?: string;\r\n        queryName?: string;\r\n        format?: string;\r\n        type?: ValueType;\r\n        roles?: { [roleName: string]: boolean };\r\n        kpi?: DataViewKpiColumnMetadata;\r\n        sort?: SortDirection;\r\n        expr?: SQExpr;\r\n        discourageAggregationAcrossGroups?: boolean;\r\n\r\n        /** Describes the default value applied to a column, if any. */\r\n        defaultValue?: DefaultValueDefinition;\r\n    }\r\n\r\n    export module DataViewSelectTransform {\r\n        /** Convert selection info to projections */\r\n        export function projectionsFromSelects(selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): QueryProjectionsByRole {\r\n            debug.assertAnyValue(selects, \"selects\");\r\n            debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\r\n\r\n            let projections: QueryProjectionsByRole = {};\r\n            for (let select of selects) {\r\n                if (!select)\r\n                    continue;\r\n\r\n                let roles = select.roles;\r\n                if (!roles)\r\n                    continue;\r\n\r\n                for (let roleName in roles) {\r\n                    if (roles[roleName]) {\r\n                        let qp = projections[roleName];\r\n                        if (!qp)\r\n                            qp = projections[roleName] = new QueryProjectionCollection([]);\r\n                        qp.all().push({ queryRef: select.queryName });\r\n\r\n                        if (projectionActiveItems && projectionActiveItems[roleName])\r\n                            qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], (activeItem: DataViewProjectionActiveItemInfo) => activeItem.queryRef);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return projections;\r\n        }\r\n\r\n        /** Use selections and metadata to fashion query role kinds */\r\n        export function createRoleKindFromMetadata(selects: DataViewSelectTransform[], metadata: DataViewMetadata): RoleKindByQueryRef {\r\n            let roleKindByQueryRef: DataViewAnalysis.RoleKindByQueryRef = {};\r\n            for (let column of metadata.columns) {\r\n                if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\r\n                    continue;\r\n\r\n                let select = selects[column.index];\r\n                if (select) {\r\n                    let queryRef = select.queryName;\r\n                    if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\r\n                        roleKindByQueryRef[queryRef] = column.isMeasure ? VisualDataRoleKind.Measure : VisualDataRoleKind.Grouping;\r\n                    }\r\n                }\r\n            }\r\n            return roleKindByQueryRef;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface ICategoricalEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createCategoricalEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewCategorical: DataViewCategorical): ICategoricalEvalContext {\r\n        return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\r\n    }\r\n\r\n    class CategoricalEvalContext implements ICategoricalEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewCategorical;\r\n        private columnsByRole: { [name: string]: DataViewCategoricalColumn };\r\n        private index: number;\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewCategorical) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.columnsByRole = {};\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            let columnsByRole = this.columnsByRole;\r\n            let column = columnsByRole[roleName];\r\n            if (!column)\r\n                column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\r\n            \r\n            if (!column)\r\n                return;\r\n\r\n            let index = this.index;\r\n            if (index != null)\r\n                return column.values[this.index];\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.index = index;\r\n        }\r\n    }\r\n\r\n    function findRuleInputColumn(dataViewCategorical: DataViewCategorical, inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n\r\n        return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\r\n            findRuleInputInColumns(dataViewCategorical.categories, inputRole);\r\n    }\r\n\r\n    function findRuleInputInColumns(columns: DataViewCategoricalColumn[], inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertAnyValue(columns, 'columns');\r\n\r\n        if (!columns)\r\n            return;\r\n\r\n        for (let column of columns) {\r\n            let roles = column.source.roles;\r\n            if (!roles || !roles[inputRole])\r\n                continue;\r\n\r\n            return column;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ITableEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createTableEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewTable: DataViewTable, selectTransforms: DataViewSelectTransform[]): ITableEvalContext {\r\n        return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\r\n    }\r\n\r\n    class TableEvalContext implements ITableEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewTable;\r\n        private rowIdx: number;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewTable, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let rowIdx = this.rowIdx;\r\n            if (rowIdx == null)\r\n                return;\r\n\r\n            return getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.rowIdx = index;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class RuleEvaluation {\r\n        // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class ColorRuleEvaluation extends RuleEvaluation {\r\n        private inputRole: string;\r\n        private allocator: IColorAllocator;\r\n\r\n        constructor(inputRole: string, allocator: IColorAllocator) {\r\n            debug.assertValue(inputRole, 'inputRole');\r\n            debug.assertValue(allocator, 'allocator');\r\n\r\n            super();\r\n            this.inputRole = inputRole;\r\n            this.allocator = allocator;\r\n        }\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n\r\n            let value: any = evalContext.getRoleValue(this.inputRole);\r\n            if (value !== undefined)\r\n                return this.allocator.color(value);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    export module DataViewMatrixUtils {\r\n\r\n        /**\r\n         * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the \r\n         * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the \r\n         * particular leaf node in the context of this forEachLeafNode(...) invocation.\r\n         *\r\n         * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\r\n         *\r\n         * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified \r\n         * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\r\n         * then treePath will be an array of length 1 containing that very node.\r\n         *\r\n         * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\r\n         * If your callback needs to retain a copy of the treePath, please clone the array before returning.\r\n         */\r\n        export function forEachLeafNode(\r\n            rootNodes: DataViewMatrixNode | DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): void {\r\n            debug.assertAnyValue(rootNodes, 'rootNodes');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\r\n            // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \r\n            // for the fact that all the properties on DataViewMatrixNode are optional...\r\n            if (rootNodes) {\r\n                if (isNodeArray(rootNodes)) {\r\n                    let index = 0;\r\n                    for (let rootNode of rootNodes) {\r\n                        if (rootNode) {\r\n                            index = forEachLeafNodeRecursive(rootNode, index, [], callback);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    forEachLeafNodeRecursive(rootNodes, 0, [], callback);\r\n                }\r\n            }\r\n        }\r\n\r\n        function isNodeArray(nodeOrNodeArray: DataViewMatrixNode | DataViewMatrixNode[]): nodeOrNodeArray is DataViewMatrixNode[] {\r\n            return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\r\n        }\r\n\r\n        /**\r\n         * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\r\n         * Returns the index for the next node after the last node that this function invokes callback with.\r\n         *\r\n         * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\r\n         */\r\n        function forEachLeafNodeRecursive(\r\n            matrixNode: DataViewMatrixNode,\r\n            nextIndex: number,\r\n            treePath: DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): number {\r\n            debug.assertValue(matrixNode, 'matrixNode');\r\n            debug.assertValue(treePath, 'treePath');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // If treePath already contains matrixNode, then either one of the following errors has happened:\r\n            // 1. the caller code mistakenly added matrixNode to treePath, or\r\n            // 2. the callback modified treePath by adding a node to it, or\r\n            // 3. the matrix hierarchy contains a cyclical node reference.');\r\n            debug.assert(!_.contains(treePath, matrixNode),\r\n                'pre-condition: treePath must not already contain matrixNode');\r\n\r\n            treePath.push(matrixNode);\r\n\r\n            if (_.isEmpty(matrixNode.children)) { // if it is a leaf node\r\n                callback(matrixNode, nextIndex, treePath);\r\n                nextIndex++;\r\n            }\r\n            else {\r\n                let children = matrixNode.children;\r\n                for (let nextChild of children) {\r\n                    if (nextChild) {\r\n                        nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\r\n                    }\r\n                }\r\n            }\r\n\r\n            debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\r\n            treePath.pop();\r\n\r\n            return nextIndex;\r\n        }\r\n\r\n        /**\r\n         * Returned an object tree where each node and its children property are inherited from the specified node \r\n         * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\r\n         *\r\n         * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array \r\n         * property, i.e. its children property is the same array object referenced in the input node's object tree.\r\n         *\r\n         * @param node The input node with the hierarchy object tree.\r\n         * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\r\n         * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is \r\n         * not already an inherited object. Same goes for the node's children property.  This is useful for creating \r\n         * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for \r\n         * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains \r\n         * inherited objects.\r\n         */\r\n        export function inheritMatrixNodeHierarchy(\r\n            node: DataViewMatrixNode,\r\n            deepestLevelToInherit: number,\r\n            useInheritSingle: boolean): DataViewMatrixNode {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\r\n            debug.assertValue(useInheritSingle, 'useInheritSingle');\r\n\r\n            let returnNode = node;\r\n\r\n            // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\r\n            // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\r\n            // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\r\n            //  {\r\n            //    \"level\": 0,\r\n            //    \"isSubtotal\": true,\r\n            //    \"children\": [\r\n            //      { \"level\": 2, \"isSubtotal\": true },\r\n            //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\r\n            //    ]\r\n            //  }\r\n            let isRootNode = _.isUndefined(node.level);\r\n            let shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\r\n            if (shouldInheritCurrentNode) {\r\n                let inheritFunc = useInheritSingle ? inheritSingle : inherit;\r\n                let inheritedNode: DataViewMatrixNode = inheritFunc(node);\r\n\r\n                let shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\r\n                if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\r\n                    inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\r\n                    for (let i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\r\n                        inheritedNode.children[i] =\r\n                            inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\r\n                    }\r\n                }\r\n\r\n                returnNode = inheritedNode;\r\n            }\r\n\r\n            return returnNode;\r\n        }\r\n\r\n        /**\r\n         * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\r\n         * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\r\n         * Year === 2016, Quarter === 'Qtr 1', Month === 1.\r\n         *\r\n         * Returns false if the specified matrixOrHierarchy does not contain any composite group, \r\n         * or if matrixOrHierarchy is null or undefined.\r\n         */\r\n        export function containsCompositeGroup(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): boolean {\r\n            debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\r\n\r\n            let hasCompositeGroup = false;\r\n\r\n            if (matrixOrHierarchy) {\r\n                if (isMatrix(matrixOrHierarchy)) {\r\n                    hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\r\n                        containsCompositeGroup(matrixOrHierarchy.columns);\r\n                }\r\n                else {\r\n                    let hierarchyLevels = matrixOrHierarchy.levels;\r\n                    if (!_.isEmpty(hierarchyLevels)) {\r\n                        for (var level of hierarchyLevels) {\r\n                            // it takes at least 2 columns at the same hierarchy level to form a composite group...\r\n                            if (level.sources && (level.sources.length >= 2)) {\r\n\r\n                                debug.assert(_.all(level.sources, sourceColumn => sourceColumn.isMeasure === level.sources[0].isMeasure),\r\n                                    'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\r\n\r\n                                // Measure headers are not group\r\n                                let isMeasureHeadersLevel = level.sources[0].isMeasure;\r\n                                if (!isMeasureHeadersLevel) {\r\n                                    hasCompositeGroup = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return hasCompositeGroup;\r\n        }\r\n\r\n        function isMatrix(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): matrixOrHierarchy is DataViewMatrix {\r\n            return 'rows' in matrixOrHierarchy &&\r\n                'columns' in matrixOrHierarchy &&\r\n                'valueSources' in matrixOrHierarchy;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    export module DataViewMetadataColumnUtils {\r\n\r\n        export interface MetadataColumnAndProjectionIndex {\r\n            /**\r\n            * A metadata column taken from a source collection, e.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n            */\r\n            metadataColumn: DataViewMetadataColumn;\r\n\r\n            /**\r\n             * The index of this.metadataColumn in its sources collection.\r\n             *\r\n             * E.g.1 This can be the value of the property DataViewMatrixGroupValue.levelSourceIndex which is the index of this.metadataColumn in DataViewHierarchyLevel.sources.\r\n             * E.g.2 This can be the value of the property DataViewMatrixNodeValue.valueSourceIndex which refer to columns in DataViewMatrix.valueSources.\r\n             */\r\n            sourceIndex: number;\r\n\r\n            /**\r\n            * The index of this.metadataColumn in the projection ordering of a given role.\r\n            */\r\n            projectionOrderIndex: number;\r\n        }\r\n\r\n        /**\r\n         * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\r\n         */\r\n        export function isForRole(metadataColumn: DataViewMetadataColumn, targetRole: string): boolean {\r\n            debug.assertValue(metadataColumn, 'metadataColumn');\r\n            debug.assertValue(targetRole, 'targetRole');\r\n\r\n            let roles = metadataColumn.roles;\r\n            return roles && roles[targetRole];\r\n        }\r\n\r\n        /**\r\n         * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\r\n         *\r\n         * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the \r\n         * specified columnSources must be a non-filtered array of column sources from the DataView, such as\r\n         * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\r\n         *\r\n         * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n         * @param projection The projection ordering.  It must contain an ordering for the specified role.\r\n         * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\r\n         */\r\n        export function joinMetadataColumnsAndProjectionOrder(\r\n            columnSources: DataViewMetadataColumn[],\r\n            projection: DataViewProjectionOrdering,\r\n            role: string): MetadataColumnAndProjectionIndex[] {\r\n            debug.assertAnyValue(columnSources, 'columnSources');\r\n            debug.assert(_.all(columnSources, column => _.isNumber(column.index)),\r\n                'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\r\n            debug.assertNonEmpty(projection[role], 'projection[role]');\r\n            debug.assert(_.all(columnSources, column => !isForRole(column, role) || _.contains(projection[role], column.index)),\r\n                'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\r\n\r\n            let jointResult: MetadataColumnAndProjectionIndex[] = [];\r\n\r\n            if (!_.isEmpty(columnSources)) {\r\n                let projectionOrderSelectIndices = projection[role];\r\n                let selectIndexToProjectionIndexMap: { [selectIndex: number]: number } = {};\r\n                for (let i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\r\n                    let selectIndex = projectionOrderSelectIndices[i];\r\n                    selectIndexToProjectionIndexMap[selectIndex] = i;\r\n                }\r\n\r\n                for (let j = 0, jlen = columnSources.length; j < jlen; j++) {\r\n                    var column = columnSources[j];\r\n                    if (isForRole(column, role)) {\r\n                        let jointColumnInfo: MetadataColumnAndProjectionIndex = {\r\n                            metadataColumn: column,\r\n                            sourceIndex: j,\r\n                            projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\r\n                        };\r\n\r\n                        jointResult.push(jointColumnInfo);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return jointResult;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export class ConceptualSchema {\r\n        public entities: ArrayNamedItems<ConceptualEntity>;\r\n        public capabilities: ConceptualCapabilities;\r\n\r\n        /** Indicates whether the user can edit this ConceptualSchema.  This is used to enable/disable model authoring UX. */\r\n        public canEdit: boolean;\r\n\r\n        public findProperty(entityName: string, propertyName: string): ConceptualProperty {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            return entity.properties.withName(propertyName);\r\n        }\r\n\r\n        public findHierarchy(entityName: string, name: string): ConceptualHierarchy {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.hierarchies))\r\n                return;\r\n\r\n            return entity.hierarchies.withName(name);\r\n        }\r\n\r\n        public findHierarchyByVariation(\r\n            variationEntityName: string,\r\n            variationColumnName: string,\r\n            variationName: string,\r\n            hierarchyName: string): ConceptualHierarchy {\r\n\r\n            let variationEntity = this.entities.withName(variationEntityName);\r\n            if (!variationEntity || _.isEmpty(variationEntity.properties))\r\n                return;\r\n\r\n            let variationProperty = variationEntity.properties.withName(variationColumnName);\r\n            if (!variationProperty)\r\n                return;\r\n\r\n            let variationColumn = variationProperty.column;\r\n            if (!variationColumn || _.isEmpty(variationColumn.variations))\r\n                return;\r\n\r\n            let variation = variationColumn.variations.withName(variationName);\r\n            if (variation) {\r\n                let targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\r\n                if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\r\n                    return;\r\n\r\n                return targetEntity.hierarchies.withName(hierarchyName);\r\n            }\r\n        }\r\n\r\n        /**\r\n        * Returns the first property of the entity whose kpi is tied to kpiProperty\r\n        */\r\n        public findPropertyWithKpi(entityName: string, kpiProperty: ConceptualProperty): ConceptualProperty {\r\n            debug.assertValue(kpiProperty, 'kpiProperty');\r\n\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            for (let prop of entity.properties) {\r\n                if (prop &&\r\n                    prop.measure &&\r\n                    prop.measure.kpi &&\r\n                    (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\r\n                    return prop;\r\n            }\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    export interface ConceptualCapabilities {\r\n        discourageQueryAggregateUsage: boolean;\r\n        normalizedFiveStateKpiRange: boolean;\r\n        supportsMedian: boolean;\r\n        supportsPercentile: boolean;\r\n        supportsScopedEval: boolean;\r\n    }\r\n\r\n    export interface ConceptualPropertyItemContainer {\r\n        properties: ArrayNamedItems<ConceptualProperty>;\r\n        hierarchies?: ArrayNamedItems<ConceptualHierarchy>;\r\n        displayFolders?: ArrayNamedItems<ConceptualDisplayFolder>;\r\n    }\r\n\r\n    export interface ConceptualPropertyItem {\r\n        name: string;\r\n        displayName: string;\r\n        hidden?: boolean;\r\n    }\r\n\r\n    export interface ConceptualEntity extends ConceptualPropertyItemContainer {\r\n        name: string;\r\n        displayName: string;\r\n        visibility?: ConceptualVisibility;\r\n        calculated?: boolean;\r\n        queryable?: ConceptualQueryableState;\r\n        navigationProperties?: ArrayNamedItems<ConceptualNavigationProperty>;\r\n    }\r\n\r\n    export interface ConceptualDisplayFolder extends ConceptualPropertyItem, ConceptualPropertyItemContainer {\r\n    }\r\n\r\n    export interface ConceptualProperty extends ConceptualPropertyItem {\r\n        type: ValueType;\r\n        kind: ConceptualPropertyKind;\r\n        format?: string;\r\n        column?: ConceptualColumn;\r\n        queryable?: ConceptualQueryableState;\r\n        measure?: ConceptualMeasure;\r\n        kpiValue?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualHierarchy extends ConceptualPropertyItem {\r\n        levels: ArrayNamedItems<ConceptualHierarchyLevel>;\r\n    }\r\n\r\n    export interface ConceptualHierarchyLevel extends ConceptualPropertyItem {\r\n        column: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualNavigationProperty {\r\n        name: string;\r\n        isActive: boolean;\r\n        sourceColumn?: ConceptualColumn;\r\n        targetEntity: ConceptualEntity;\r\n        sourceMultiplicity: ConceptualMultiplicity;\r\n        targetMultiplicity: ConceptualMultiplicity;\r\n    }\r\n\r\n    export interface ConceptualVariationSource {\r\n        name: string;\r\n        isDefault: boolean;\r\n        navigationProperty?: ConceptualNavigationProperty;\r\n        defaultHierarchy?: ConceptualHierarchy;\r\n        defaultProperty?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualColumn {\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n        keys?: ArrayNamedItems<ConceptualProperty>;\r\n        idOnEntityKey?: boolean;\r\n        calculated?: boolean;\r\n        defaultValue?: SQConstantExpr;\r\n        variations?: ArrayNamedItems<ConceptualVariationSource>;\r\n        aggregateBehavior?: ConceptualAggregateBehavior;\r\n    }\r\n\r\n    export interface ConceptualMeasure {\r\n        kpi?: ConceptualPropertyKpi;\r\n    }\r\n\r\n    export interface ConceptualPropertyKpi {\r\n        statusMetadata: DataViewKpiColumnMetadata;\r\n        trendMetadata?: DataViewKpiColumnMetadata;\r\n        status?: ConceptualProperty;\r\n        goal?: ConceptualProperty;\r\n        trend?: ConceptualProperty;\r\n    }\r\n\r\n    export const enum ConceptualVisibility {\r\n        Visible = 0,\r\n        Hidden = 1,\r\n        ShowAsVariationsOnly = 2,\r\n        IsPrivate = 4,\r\n    }\r\n\r\n    export const enum ConceptualQueryableState {\r\n        Queryable = 0,\r\n        Error = 1,\r\n    }\r\n\r\n    export const enum ConceptualMultiplicity {\r\n        ZeroOrOne = 0,\r\n        One = 1,\r\n        Many = 2,\r\n    }\r\n\r\n    export const enum ConceptualPropertyKind {\r\n        Column,\r\n        Measure,\r\n        Kpi,\r\n    }\r\n\r\n    export const enum ConceptualDefaultAggregate {\r\n        Default,\r\n        None,\r\n        Sum,\r\n        Count,\r\n        Min,\r\n        Max,\r\n        Average,\r\n        DistinctCount,\r\n    }\r\n\r\n    // TODO: Remove this (replaced by ValueType)\r\n    export enum ConceptualDataCategory {\r\n        None,\r\n        Address,\r\n        City,\r\n        Company,\r\n        Continent,\r\n        Country,\r\n        County,\r\n        Date,\r\n        Image,\r\n        ImageUrl,\r\n        Latitude,\r\n        Longitude,\r\n        Organization,\r\n        Place,\r\n        PostalCode,\r\n        Product,\r\n        StateOrProvince,\r\n        WebUrl,\r\n    }\r\n\r\n    export const enum ConceptualAggregateBehavior {\r\n        Default,\r\n        DiscourageAcrossGroups,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import FederatedConceptualSchema = powerbi.data.FederatedConceptualSchema;\r\n    import FieldExprColumnPattern = powerbi.data.FieldExprColumnPattern;\r\n    import FieldExprColumnAggrPattern = powerbi.data.FieldExprColumnAggrPattern;\r\n    import FieldExprColumnHierarchyLevelVariationPattern = powerbi.data.FieldExprColumnHierarchyLevelVariationPattern;\r\n    import FieldExprEntityPattern = powerbi.data.FieldExprEntityPattern;\r\n    import FieldExprEntityAggrPattern = powerbi.data.FieldExprEntityAggrPattern;\r\n    import FieldExprHierarchyPattern = powerbi.data.FieldExprHierarchyPattern;\r\n    import FieldExprHierarchyLevelPattern = powerbi.data.FieldExprHierarchyLevelPattern;\r\n    import FieldExprHierarchyLevelAggrPattern = powerbi.data.FieldExprHierarchyLevelAggrPattern;\r\n    import FieldExprMeasurePattern = powerbi.data.FieldExprMeasurePattern;\r\n    import FieldExprPattern = powerbi.data.FieldExprPattern;\r\n    import FieldExprPercentilePattern = powerbi.data.FieldExprPercentilePattern;\r\n    import FieldExprSelectRefPattern = powerbi.data.FieldExprSelectRefPattern;\r\n    import FieldExprPercentOfGrandTotalPattern = powerbi.data.FieldExprPercentOfGrandTotalPattern;\r\n    import IFieldExprPatternVisitor = powerbi.data.IFieldExprPatternVisitor;\r\n    import QueryProjectionsByRole = data.QueryProjectionsByRole;\r\n\r\n    export interface ScriptResult {\r\n        source: string;\r\n        provider: string;\r\n    }\r\n\r\n    export module ScriptResultUtil {\r\n\r\n        export function findScriptResult(dataViewMappings: DataViewMapping[] | data.CompiledDataViewMapping[]): DataViewScriptResultMapping | data.CompiledDataViewScriptResultMapping {\r\n            if (dataViewMappings && dataViewMappings.length === 1) {\r\n                return dataViewMappings[0].scriptResult;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResult(dataViewMappings: data.CompiledDataViewMapping[]): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult) {\r\n                let objects = dataViewMappings[0].metadata.objects;\r\n                let source: string = DataViewObjects.getValue<string>(objects, scriptResult.script.source);\r\n                let provider: string = DataViewObjects.getValue<string>(objects, scriptResult.script.provider);\r\n                return {\r\n                    source: source,\r\n                    provider: provider\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResultFromVisualConfig(dataViewMappings: DataViewMapping[], objects: powerbi.data.DataViewObjectDefinitions): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult && objects) {\r\n                let scriptSource = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\r\n                let provider = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\r\n                return {\r\n                    source: scriptSource ? scriptSource.value : null,\r\n                    provider: provider ? provider.value : null\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function getScriptInput(projections: QueryProjectionsByRole, selects: ArrayNamedItems<data.NamedSQExpr>, schema: FederatedConceptualSchema): data.ScriptInput {\r\n            let scriptInput: data.ScriptInput = {\r\n                VariableName: \"dataset\",\r\n                Columns: []\r\n            };\r\n\r\n            // Go over all the projections, and create an input column according to the order\r\n            // of the projections (including duplicate expressions)\r\n            if (projections && selects && !_.isEmpty(selects)) {\r\n                let scriptInputColumnNames: string[] = [];\r\n                let scriptInputColumns: data.ScriptInputColumn[] = [];\r\n                for (let role in projections) {\r\n                    for (let projection of projections[role].all()) {\r\n                        let select = selects.withName(projection.queryRef);\r\n                        if (select) {\r\n                            let scriptInputColumn = <data.ScriptInputColumn>{\r\n                                QueryName: select.name,\r\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\r\n                            };\r\n\r\n                            scriptInputColumns.push(scriptInputColumn);\r\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Make sure the names of the columns are unique\r\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\r\n\r\n                // Update the names of the columns\r\n                for (let i = 0; i < scriptInputColumnNames.length; i++) {\r\n                    let scriptInputColumn = scriptInputColumns[i];\r\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\r\n                }\r\n\r\n                scriptInput.Columns = scriptInputColumns;\r\n            }\r\n\r\n            return scriptInput;\r\n        }\r\n\r\n        class ScriptInputColumnNameVisitor implements IFieldExprPatternVisitor<string>\r\n        {\r\n            private federatedSchema: FederatedConceptualSchema;\r\n\r\n            constructor(federatedSchema: FederatedConceptualSchema) {\r\n                this.federatedSchema = federatedSchema;\r\n            }\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): string {\r\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): string {\r\n                return entity.entity;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): string {\r\n                return entityAggr.entity;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): string {\r\n                /*Hierarchy levels are not supported yet*/\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): string {\r\n                return FieldExprPattern.visit(selectRef, this);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): string {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): string {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n\r\n            private static getNameForHierarchy(pattern: FieldExprHierarchyPattern, federatedScheam: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedScheam.schema(pattern.schema),\r\n                    hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\r\n\r\n                if (hierarchy)\r\n                    return hierarchy.name;\r\n            }\r\n\r\n            private static getNameForProperty(pattern: data.FieldExprPropertyPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedSchema.schema(pattern.schema),\r\n                    property = schema.findProperty(pattern.entity, pattern.name);\r\n\r\n                if (property)\r\n                    return property.name;\r\n            }\r\n\r\n            private static getVariationLevelName(pattern: FieldExprColumnHierarchyLevelVariationPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let source = pattern.source;\r\n                let prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\r\n                if (!prop)\r\n                    return;\r\n\r\n                let variations = prop.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === pattern.variationName)\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            if (level.name === pattern.level.level)\r\n                                return level.column.name;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.segmentation {\r\n\r\n    export interface DataViewTableSegment extends DataViewTable {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewTreeSegmentNode extends DataViewTreeNode {\r\n        /** Indicates whether the node is a duplicate of a node from a previous segment. */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export interface DataViewCategoricalSegment extends DataViewCategorical {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewMatrixSegmentNode extends DataViewMatrixNode {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export module DataViewMerger {\r\n\r\n        export function mergeDataViews(source: DataView, segment: DataView): void {\r\n\r\n            if (!DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\r\n                debug.assertFail(\"Cannot merge data views with different metadata columns\");\r\n            }\r\n\r\n            // The last segment is complete. We mark the source as complete.\r\n            if (!segment.metadata.segment)\r\n                delete source.metadata.segment;\r\n\r\n            if (source.table && segment.table)\r\n                mergeTables(source.table, <DataViewTableSegment>segment.table);\r\n\r\n            if (source.categorical && segment.categorical)\r\n                mergeCategorical(source.categorical, <DataViewCategoricalSegment>segment.categorical);\r\n\r\n            // Tree cannot support subtotals hence we can get into situations\r\n            // where a node has no children in one segment and more than 1 child\r\n            // in another segment.\r\n            if (source.tree && segment.tree)\r\n                mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\r\n\r\n            if (source.matrix && segment.matrix)\r\n                mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTables(source: DataViewTable, segment: DataViewTableSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            if (_.isEmpty(segment.rows))\r\n                return;\r\n\r\n            let mergeIndex = segment.lastMergeIndex + 1;\r\n            merge(source.rows, segment.rows, mergeIndex);\r\n\r\n            debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');\r\n            if (segment.identity)\r\n                merge(source.identity, segment.identity, mergeIndex);\r\n        }\r\n\r\n        /**\r\n         * Merge categories values and identities\r\n         *\r\n         * Note: Public for testability\r\n         */\r\n        export function mergeCategorical(source: DataViewCategorical, segment: DataViewCategoricalSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            // Merge categories values and identities\r\n            if (source.categories && segment.categories) {\r\n                let segmentCategoriesLength = segment.categories.length;\r\n                debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\r\n\r\n                for (let categoryIndex: number = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\r\n                    let segmentCategory = segment.categories[categoryIndex];\r\n                    let sourceCategory = source.categories[categoryIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\r\n                    debug.assert(_.isUndefined(sourceCategory.values) ? _.isUndefined(sourceCategory.identity) : true, 'Source category is missing values but has identities.');\r\n\r\n                    let mergeIndex = segment.lastMergeIndex + 1;\r\n                    if (segmentCategory.values) {\r\n                        merge(sourceCategory.values, segmentCategory.values, mergeIndex);\r\n                    }\r\n\r\n                    if (segmentCategory.identity) {\r\n                        merge(sourceCategory.identity, segmentCategory.identity, mergeIndex);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Merge values for each value column\r\n            if (source.values && segment.values) {\r\n                let segmentValuesLength = segment.values.length;\r\n                debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\r\n\r\n                for (let valueIndex: number = 0; valueIndex < segmentValuesLength; valueIndex++) {\r\n                    let segmentValue = segment.values[valueIndex];\r\n                    let sourceValue = source.values[valueIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\r\n\r\n                    if (!sourceValue.values && segmentValue.values) {\r\n                        sourceValue.values = [];\r\n                    }\r\n\r\n                    let mergeIndex = segment.lastMergeIndex + 1;\r\n                    if (segmentValue.values) {\r\n                        merge(sourceValue.values, segmentValue.values, mergeIndex);\r\n                    }\r\n\r\n                    if (segmentValue.highlights) {\r\n                        merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Merges the segment array starting at the specified index into the source array\r\n         * and returns the segment slice that wasn't merged.\r\n         * The segment array is spliced up to specified index in the process.\r\n         */\r\n        function merge(source: any[], segment: any[], index?: number): any[] {\r\n            if (index >= segment.length)\r\n                return segment;\r\n\r\n            let result: any[] = [];\r\n            if (index !== undefined)\r\n                result = segment.splice(0, index);\r\n\r\n            Array.prototype.push.apply(source, segment);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTreeNodes(sourceRoot: DataViewTreeNode, segmentRoot: DataViewTreeNode, allowDifferentStructure: boolean): void {\r\n            debug.assertValue(sourceRoot, 'sourceRoot');\r\n            debug.assertValue(segmentRoot, 'segmentRoot');\r\n\r\n            if (!segmentRoot.children || segmentRoot.children.length === 0)\r\n                return;\r\n\r\n            if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\r\n                sourceRoot.children = segmentRoot.children;\r\n                return;\r\n            }\r\n\r\n            debug.assert(sourceRoot.children && sourceRoot.children.length >= 0,\r\n                \"Source tree has different structure than segment.\");\r\n\r\n            let firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\r\n            let lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\r\n            let mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\r\n\r\n            if (mergedChildren.length > 0)\r\n                mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\r\n        }\r\n\r\n        function findFirstAppendIndex(children: DataViewTreeNode[]): number {\r\n            if (children.length === 0)\r\n                return 0;\r\n\r\n            let i: number = 0;\r\n            for (; i < children.length; i++) {\r\n                let childSegment: DataViewTreeSegmentNode = <DataViewTreeSegmentNode>children[i];\r\n                if (!childSegment.isMerge)\r\n                    break;\r\n            }\r\n\r\n            return i;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Rewrites an expression tree, including all descendant nodes. */\r\n    export class SQExprRewriter implements ISQExprVisitor<SQExpr>, IFillRuleDefinitionVisitor<LinearGradient2Definition, LinearGradient3Definition> {\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQColumnRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQMeasureRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(rewrittenArg, expr.func);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyExpr(rewrittenArg, expr.hierarchy);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyLevelExpr(rewrittenArg, expr.level);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitAnd(orig: SQAndExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQAndExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitBetween(orig: SQBetweenExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this),\r\n                origLower = orig.lower,\r\n                rewrittenLower = origLower.accept(this),\r\n                origUpper = orig.upper,\r\n                rewrittenUpper = origUpper.accept(this);\r\n\r\n            if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\r\n                return orig;\r\n\r\n            return new SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\r\n        }\r\n\r\n        public visitIn(orig: SQInExpr): SQExpr {\r\n            let origArgs = orig.args,\r\n                rewrittenArgs = this.rewriteAll(origArgs),\r\n                origValues: SQExpr[][] = orig.values,\r\n                rewrittenValues: SQExpr[][];\r\n\r\n            for (let i = 0, len = origValues.length; i < len; i++) {\r\n                let origValueTuple = origValues[i],\r\n                    rewrittenValueTuple = this.rewriteAll(origValueTuple);\r\n\r\n                if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\r\n                    rewrittenValues = ArrayExtensions.take(origValues, i);\r\n\r\n                if (rewrittenValues)\r\n                    rewrittenValues.push(rewrittenValueTuple);\r\n            }\r\n\r\n            if (origArgs === rewrittenArgs && !rewrittenValues)\r\n                return orig;\r\n\r\n            return new SQInExpr(rewrittenArgs, rewrittenValues || origValues);\r\n        }\r\n\r\n        private rewriteAll(origExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(origExprs, 'origExprs');\r\n\r\n            let rewrittenResult: SQExpr[];\r\n            for (let i = 0, len = origExprs.length; i < len; i++) {\r\n                let origExpr = origExprs[i],\r\n                    rewrittenExpr = origExpr.accept(this);\r\n\r\n                if (origExpr !== rewrittenExpr && !rewrittenResult)\r\n                    rewrittenResult = ArrayExtensions.take(origExprs, i);\r\n\r\n                if (rewrittenResult)\r\n                    rewrittenResult.push(rewrittenExpr);\r\n            }\r\n\r\n            return rewrittenResult || origExprs;\r\n        }\r\n\r\n        public visitOr(orig: SQOrExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQOrExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitCompare(orig: SQCompareExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitContains(orig: SQContainsExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQContainsExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitExists(orig: SQExistsExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQExistsExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitNot(orig: SQNotExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQNotExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitStartsWith(orig: SQStartsWithExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQStartsWithExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitDateSpan(orig: SQDateSpanExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateSpanExpr(orig.unit, rewrittenArg);\r\n        }\r\n\r\n        public visitDateAdd(orig: SQDateAddExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\r\n        }\r\n\r\n        public visitNow(orig: SQNowExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitDefaultValue(orig: SQDefaultValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitAnyValue(orig: SQAnyValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitArithmetic(orig: SQArithmeticExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\r\n        }\r\n\r\n        public visitScopedEval(orig: SQScopedEvalExpr): SQExpr {\r\n            let origExpression = orig.expression,\r\n                rewrittenExpression = origExpression.accept(this),\r\n                origScope = orig.scope,\r\n                rewrittenScope = this.rewriteAll(origScope);\r\n\r\n            if (origExpression === rewrittenExpression && origScope === rewrittenScope)\r\n                return orig;\r\n\r\n            return new SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\r\n        }\r\n        \r\n        public visitWithRef(orig: SQWithRefExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitFillRule(orig: SQFillRuleExpr): SQExpr {\r\n            let origInput = orig.input,\r\n                rewrittenInput = origInput.accept(this);\r\n\r\n            let origRule = orig.rule;\r\n\r\n            let origGradient2 = origRule.linearGradient2,\r\n                rewrittenGradient2 = origGradient2;\r\n            if (origGradient2) {\r\n                rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\r\n            }\r\n\r\n            let origGradient3 = origRule.linearGradient3,\r\n                rewrittenGradient3 = origGradient3;\r\n            if (origGradient3) {\r\n                rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\r\n            }\r\n\r\n            if (origInput !== rewrittenInput ||\r\n                origGradient2 !== rewrittenGradient2 ||\r\n                origGradient3 !== rewrittenGradient3) {\r\n                let rewrittenRule: FillRuleDefinition = {};\r\n                if (rewrittenGradient2)\r\n                    rewrittenRule.linearGradient2 = rewrittenGradient2;\r\n                if (rewrittenGradient3)\r\n                    rewrittenRule.linearGradient3 = rewrittenGradient3;\r\n\r\n                return new SQFillRuleExpr(rewrittenInput, rewrittenRule);\r\n            }\r\n\r\n            return orig;\r\n        }\r\n\r\n        public visitLinearGradient2(origGradient2: LinearGradient2Definition): LinearGradient2Definition {\r\n            debug.assertValue(origGradient2, 'origGradient2');\r\n\r\n            let origMin = origGradient2.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMax = origGradient2.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient2;\r\n        }\r\n\r\n        public visitLinearGradient3(origGradient3: LinearGradient3Definition): LinearGradient3Definition {\r\n            debug.assertValue(origGradient3, 'origGradient3');\r\n\r\n            let origMin = origGradient3.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMid = origGradient3.mid,\r\n                rewrittenMid = this.visitFillRuleStop(origMid),\r\n                origMax = origGradient3.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    mid: rewrittenMid,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient3;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): RuleColorStopDefinition {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            let origColor = stop.color,\r\n                rewrittenColor = stop.color.accept(this);\r\n\r\n            let origValue = stop.value,\r\n                rewrittenValue = origValue;\r\n            if (origValue)\r\n                rewrittenValue = origValue.accept(this);\r\n\r\n            if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\r\n                let rewrittenStop: RuleColorStopDefinition = {\r\n                    color: rewrittenColor\r\n                };\r\n\r\n                if (rewrittenValue)\r\n                    rewrittenStop.value = rewrittenValue;\r\n\r\n                return rewrittenStop;\r\n            }\r\n\r\n            return stop;\r\n        }\r\n\r\n        public visitResourcePackageItem(orig: SQResourcePackageItemExpr): SQExpr {\r\n            return orig;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Responsible for writing equality comparisons against a field to an SQInExpr. */\r\n    export module EqualsToInRewriter {\r\n        export function run(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(new Rewriter());\r\n        }\r\n\r\n        class Rewriter extends SQExprRewriter {\r\n            private current: InBuilder;\r\n\r\n            constructor() {\r\n                super();\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): SQExpr {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return this.visitUnsupported(expr);\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let leftIsComparand = this.isComparand(expr.left);\r\n                let rightIsComparand = this.isComparand(expr.right);\r\n                if (leftIsComparand === rightIsComparand)\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let operand: SQExpr = leftIsComparand\r\n                    ? expr.left\r\n                    : expr.right;\r\n                let value: SQExpr = leftIsComparand\r\n                    ? expr.right\r\n                    : expr.left;\r\n\r\n                let current = this.current;\r\n                if (!current) {\r\n                    return SQExprBuilder.inExpr([operand], [[value]]);\r\n                }\r\n\r\n                current.add(operand, value);\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitOr(expr: SQOrExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current: InBuilder;\r\n                if (!this.current) {\r\n                    current = this.current = new InBuilder();\r\n                }\r\n\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n\r\n                if (current) {\r\n                    this.current = null;\r\n                    return current.complete() || expr;\r\n                }\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current = this.current;\r\n                if (current) {\r\n                    // NOTE: Composite keys are not supported by this algorithm.\r\n                    current.cancel();\r\n                    return expr;\r\n                }\r\n\r\n                return super.visitAnd(expr);\r\n            }\r\n\r\n            private visitUnsupported(expr: SQExpr): SQExpr {\r\n                let current = this.current;\r\n                if (current)\r\n                    current.cancel();\r\n\r\n                return expr;\r\n            }\r\n\r\n            private isSupported(expr: SQExpr): boolean {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return expr instanceof SQCompareExpr\r\n                    || expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQConstantExpr\r\n                    || expr instanceof SQHierarchyLevelExpr\r\n                    || expr instanceof SQOrExpr\r\n                    || expr instanceof SQAndExpr;\r\n            }\r\n\r\n            private isComparand(expr: SQExpr): boolean {\r\n                return expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQHierarchyLevelExpr;\r\n            }\r\n        }\r\n\r\n        class InBuilder {\r\n            private operand: SQExpr;\r\n            private values: SQExpr[];\r\n            private cancelled: boolean;\r\n\r\n            public add(operand: SQExpr, value: SQExpr): void {\r\n                debug.assertValue(operand, 'operand');\r\n                debug.assertValue(value, 'value');\r\n\r\n                if (this.cancelled)\r\n                    return;\r\n\r\n                if (this.operand && !SQExpr.equals(operand, this.operand)) {\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n\r\n                this.operand = operand;\r\n\r\n                let values = this.values;\r\n                if (!values)\r\n                    values = this.values = [];\r\n\r\n                values.push(value);\r\n            }\r\n\r\n            public cancel(): void {\r\n                this.cancelled = true;\r\n            }\r\n\r\n            public complete(): SQInExpr {\r\n                if (this.cancelled || !this.operand)\r\n                    return;\r\n\r\n                return SQExprBuilder.inExpr([this.operand], _.map(this.values, v => [v]));\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface FilterValueScopeIdsContainer {\r\n            isNot: boolean;\r\n            scopeIds: DataViewScopeIdentity[];\r\n        }\r\n\r\n    export module SQExprConverter {\r\n        export function asScopeIdsContainer(filter: SemanticFilter, fieldSQExprs: SQExpr[]): FilterValueScopeIdsContainer {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\r\n\r\n            let filterItems = filter.conditions();\r\n            debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\r\n            let filterItem = filterItems[0];\r\n            if (filterItem) {\r\n                let visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\r\n                if (filterItem.accept(visitor))\r\n                    return visitor.getResult();\r\n            }\r\n        }\r\n\r\n        /** Gets a comparand value from the given DataViewScopeIdentity. */\r\n        export function getFirstComparandValue(identity: DataViewScopeIdentity): any {\r\n            debug.assertValue(identity, 'identity');\r\n\r\n            let comparandExpr = (<SQExpr>identity.expr).accept(new FindComparandVisitor());\r\n            if (comparandExpr)\r\n                return comparandExpr.value;\r\n        }\r\n    }\r\n\r\n    /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\r\n    class FilterScopeIdsCollectorVisitor extends DefaultSQExprVisitor<boolean>{\r\n        private isRoot: boolean;\r\n        private isNot: boolean;\r\n        private keyExprsCount: number;\r\n        private valueExprs: SQExpr[];\r\n        private fieldExprs: SQExpr[];\r\n\r\n        constructor(fieldSQExprs:SQExpr[]) {\r\n            super();\r\n            this.isRoot = true;\r\n            this.isNot = false;\r\n            this.keyExprsCount = null;\r\n            this.valueExprs = [];\r\n\r\n            // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\r\n            // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\r\n            // need to drop it in order to use JsonComparer.\r\n            this.fieldExprs = [];\r\n            for (let field of fieldSQExprs) {\r\n                this.fieldExprs.push(SQExprBuilder.removeEntityVariables(field));\r\n            }\r\n        }\r\n\r\n        public getResult(): FilterValueScopeIdsContainer {\r\n            debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');            \r\n\r\n            let valueExprs = this.valueExprs,\r\n                scopeIds: DataViewScopeIdentity[] = [];\r\n            let valueCount: number = this.keyExprsCount || 1;\r\n\r\n            for (let startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\r\n                let values = valueExprs.slice(startIndex, endIndex);\r\n                let scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\r\n\r\n                if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, DataViewScopeIdentity.equals))\r\n                    scopeIds.push(scopeId);\r\n\r\n                startIndex += valueCount;\r\n                endIndex += valueCount;\r\n            }\r\n\r\n            return {\r\n                isNot: this.isNot,\r\n                scopeIds: scopeIds,\r\n            };\r\n        }\r\n\r\n        private static getScopeIdentity(fieldExprs: SQExpr[], valueExprs: SQExpr[]): DataViewScopeIdentity {\r\n            debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\r\n            debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\r\n\r\n            let compoundSQExpr: SQExpr;\r\n            for (let i = 0, len = fieldExprs.length; i < len; i++) {\r\n                let equalsExpr = SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\r\n                if (!compoundSQExpr)\r\n                    compoundSQExpr = equalsExpr;\r\n                else\r\n                    compoundSQExpr = SQExprBuilder.and(compoundSQExpr, equalsExpr);\r\n            }\r\n\r\n            return createDataViewScopeIdentity(compoundSQExpr);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): boolean {\r\n            if (!this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isNot = true;\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): boolean {\r\n            if (this.isRoot && expr.type.primitiveType === PrimitiveType.Null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);            \r\n            return true;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n\r\n            if (expr.comparison !== QueryComparisonKind.Equal)\r\n                return this.unsupportedSQExpr();\r\n\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): boolean {\r\n            this.keyExprsCount = 0;\r\n            let result: boolean;\r\n            this.isRoot = false;\r\n            for (let arg of expr.args) {\r\n                result = arg.accept(this);\r\n                if (!result)\r\n                    return this.unsupportedSQExpr();\r\n\r\n                this.keyExprsCount++;\r\n            }\r\n\r\n            if (this.keyExprsCount !== this.fieldExprs.length)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let values = expr.values;\r\n            for (let valueTuple of values) {\r\n                let jlen = valueTuple.length;\r\n                debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\r\n\r\n                for (let value of valueTuple) {\r\n                    result = value.accept(this);\r\n                    if (!result)\r\n                        return this.unsupportedSQExpr();\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): boolean {\r\n            if (this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let fixedExpr = SQExprBuilder.removeEntityVariables(expr);\r\n            if (this.keyExprsCount !== null)\r\n                return SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\r\n\r\n            return SQExpr.equals(this.fieldExprs[0], fixedExpr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): boolean {\r\n            return this.unsupportedSQExpr();\r\n        }\r\n\r\n        private unsupportedSQExpr(): boolean {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    class FindComparandVisitor extends DefaultSQExprVisitor<SQConstantExpr> {\r\n        public visitAnd(expr: SQAndExpr): SQConstantExpr {\r\n            return expr.left.accept(this) || expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQConstantExpr {\r\n            if (expr.comparison === QueryComparisonKind.Equal) {\r\n                if (expr.right instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.right;\r\n                if (expr.left instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.left;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\r\n    export module ScopeIdentityExtractor {\r\n        export function getKeys(expr: SQExpr): SQExpr[] {\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return null;\r\n\r\n            return ArrayExtensions.emptyToNull(extractor.keys);\r\n        }\r\n\r\n        export function getInExpr(expr: SQExpr): SQInExpr{\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return;\r\n            \r\n            let keys = ArrayExtensions.emptyToNull(extractor.keys);\r\n            let keyValues = ArrayExtensions.emptyToNull(extractor.values);\r\n\r\n            if (keys && keyValues)\r\n                return data.SQExprBuilder.inExpr(keys, [keyValues]);\r\n        }\r\n\r\n        /**\r\n         * Recognizes expressions of the form:\r\n         * 1) Equals(ColRef, Constant)\r\n         * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\r\n         * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\r\n         */\r\n        class ScopeIdExtractorImpl extends DefaultSQExprVisitor<void> {\r\n            public keys: SQExpr[] = [];\r\n            public values: SQConstantExpr[] = [];\r\n            public malformed: boolean;\r\n\r\n            public visitAnd(expr: SQAndExpr): void {\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): void {\r\n                if (expr.comparison !== QueryComparisonKind.Equal) {\r\n                    this.visitDefault(expr);\r\n                    return;\r\n                }\r\n                debug.assert(expr.left instanceof SQExpr && expr.right instanceof SQConstantExpr, 'invalid compare expr operands');\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): void {\r\n                this.values.push(expr);\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): void {\r\n                this.malformed = true;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module PrimitiveValueEncoding {\r\n        const SingleQuoteRegex = /'/g;\r\n\r\n        export function decimal(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'M';\r\n        }\r\n\r\n        export function double(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'D';\r\n        }\r\n\r\n        export function integer(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'L';\r\n        }\r\n\r\n        export function dateTime(value: Date): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\r\n            // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\r\n            // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\r\n            let date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\r\n            let dateTimeString = date.toISOString();\r\n\r\n            // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\r\n            // we will drop it.\r\n            // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\r\n            if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\r\n                dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\r\n            return \"datetime'\" + dateTimeString + \"'\";\r\n        }\r\n\r\n        export function text(value: string): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\r\n        }\r\n\r\n        export function nullEncoding(): string {\r\n            return 'null';\r\n        }\r\n\r\n        export function boolean(value: boolean): string {\r\n            return value ? 'true' : 'false';\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Agg = powerbi.data.QueryAggregateFunction;\r\n\r\n    export interface ISQAggregationOperations {\r\n        /** Returns an array of supported aggregates for a given expr and role type. */\r\n        getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[];\r\n\r\n        isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean;\r\n\r\n        createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr;\r\n    }\r\n\r\n    export function createSQAggregationOperations(datetimeMinMaxSupported: boolean): ISQAggregationOperations {\r\n        return new SQAggregationOperations(datetimeMinMaxSupported);\r\n    }\r\n\r\n    class SQAggregationOperations implements ISQAggregationOperations {\r\n        constructor(private datetimeMinMaxSupported: boolean) {\r\n        }\r\n\r\n        public getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[] {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertAnyValue(targetTypes, 'targetTypes');\r\n\r\n            let metadata = getMetadataForUnderlyingType(expr, schema);\r\n\r\n            // don't use expr.validate as validate will be using this function and we end up in a recursive loop\r\n            if (!metadata)\r\n                return [];\r\n\r\n            let valueType = metadata.type,\r\n                fieldKind = metadata.kind,\r\n                isPropertyIdentity = metadata.idOnEntityKey;\r\n\r\n            if (!valueType)\r\n                return [];\r\n\r\n            // Cannot aggregate on model measures\r\n            if (fieldKind === FieldKind.Measure)\r\n                return [];\r\n\r\n            if (valueType.numeric || valueType.integer) {\r\n                let aggregates = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                let currentSchema = schema.schema(fieldExprItem.schema);\r\n                if (currentSchema.capabilities.supportsMedian)\r\n                    aggregates.push(Agg.Median);\r\n\r\n                return aggregates;\r\n            }\r\n\r\n            let aggregates: QueryAggregateFunction[] = [];\r\n\r\n            // Min/Max of DateTime\r\n            if (this.datetimeMinMaxSupported &&\r\n                valueType.dateTime &&\r\n                (_.isEmpty(targetTypes) || ValueType.isCompatibleTo(valueType, targetTypes))) {\r\n                aggregates.push(Agg.Min);\r\n                aggregates.push(Agg.Max);\r\n            }\r\n\r\n            // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\r\n            // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\r\n            let distinctCountAggExists = SQExprInfo.getAggregate(expr) === Agg.Count;\r\n            if (!(isPropertyIdentity && !distinctCountAggExists))\r\n                aggregates.push(Agg.Count);\r\n\r\n            aggregates.push(Agg.CountNonNull);\r\n\r\n            return aggregates;\r\n        }\r\n\r\n        public isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\r\n            return _.contains(supportedAggregates, aggregate);\r\n        }\r\n\r\n        public createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n            if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\r\n                aggregate = preferredAggregate;\r\n            }\r\n            else {\r\n                aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\r\n            }\r\n            if (aggregate !== undefined)\r\n                expr = SQExprBuilder.aggregate(expr, aggregate);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    function getMetadataForUnderlyingType(expr: SQExpr, schema: FederatedConceptualSchema): SQExprMetadata {\r\n        // Unwrap the aggregate (if the expr has one), and look at the underlying type.\r\n        let metadata = SQExprBuilder.removeAggregate(expr).getMetadata(schema);\r\n\r\n        if (!metadata)\r\n            metadata = expr.getMetadata(schema);\r\n\r\n        return metadata;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module SQHierarchyExprUtils {\r\n        export function getConceptualHierarchyLevelFromExpr(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            fieldExpr: FieldExprPattern): ConceptualHierarchyLevel {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            let hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\r\n            if (hierarchyLevel)\r\n                return SQHierarchyExprUtils.getConceptualHierarchyLevel(\r\n                    conceptualSchema,\r\n                    fieldExprItem.schema,\r\n                    fieldExprItem.entity,\r\n                    hierarchyLevel.name,\r\n                    hierarchyLevel.level);\r\n        }\r\n\r\n        export function getConceptualHierarchyLevel(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            schemaName: string,\r\n            entity: string,\r\n            hierarchy: string,\r\n            hierarchyLevel: string): ConceptualHierarchyLevel {\r\n\r\n            let schema = conceptualSchema.schema(schemaName);\r\n            let conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\r\n            if (conceptualHierarchy) {\r\n                return conceptualHierarchy.levels.withName(hierarchyLevel);\r\n            }\r\n        }\r\n\r\n        export function getConceptualHierarchy(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): ConceptualHierarchy {\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchy = <SQHierarchyExpr>sqExpr;\r\n\r\n                if (sqExpr.arg instanceof SQEntityExpr) {\r\n                    let entityExpr = <SQEntityExpr>sqExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(entityExpr.schema)\r\n                        .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\r\n                } else if (sqExpr.arg instanceof SQPropertyVariationSourceExpr) {\r\n                    let variationExpr = <SQPropertyVariationSourceExpr>sqExpr.arg;\r\n                    let sourceEntityExpr = <SQEntityExpr>variationExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(sourceEntityExpr.schema)\r\n                        .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function expandExpr(schema: FederatedConceptualSchema, expr: SQExpr, suppressHierarchyLevelExpansion?: boolean): SQExpr | SQExpr[] {\r\n            return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\r\n                SQExprVariationConverter.expand(expr, schema) ||\r\n                // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\r\n                (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\r\n                expr;\r\n        }\r\n\r\n        export function isHierarchyOrVariation(schema: FederatedConceptualSchema, expr: SQExpr): boolean {\r\n            if (expr instanceof SQHierarchyExpr || expr instanceof SQHierarchyLevelExpr)\r\n                return true;\r\n\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Return column reference expression for hierarchy level expression.\r\n        export function getSourceVariationExpr(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\r\n\r\n                return SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\r\n            }\r\n        }\r\n\r\n        // Return hierarchy expression for hierarchy level expression.\r\n        export function getSourceHierarchy(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQHierarchyExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            let hierarchyLevel = fieldExprPattern.hierarchyLevel;\r\n            if (hierarchyLevel) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\r\n                return SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\r\n            }\r\n        }\r\n\r\n        export function getHierarchySourceAsVariationSource(hierarchyLevelExpr: SQHierarchyLevelExpr): SQPropertyVariationSourceExpr {\r\n\r\n            // Make sure the hierarchy level source is a hierarchy\r\n            if (!(hierarchyLevelExpr.arg instanceof SQHierarchyExpr))\r\n                return;\r\n                        \r\n            // Check if the hierarchy source if a variation\r\n            let hierarchyRef = <SQHierarchyExpr>hierarchyLevelExpr.arg;\r\n            if (hierarchyRef.arg instanceof SQPropertyVariationSourceExpr)\r\n                return <SQPropertyVariationSourceExpr>hierarchyRef.arg;\r\n        }\r\n\r\n        /**\r\n        * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\r\n        */\r\n        export function areHierarchyLevelsOrdered(allLevels: SQHierarchyLevelExpr[], firstExpr: SQExpr, secondExpr: SQExpr): boolean {\r\n\r\n            // Validate that both items hierarchy levels\r\n            if (!(firstExpr instanceof SQHierarchyLevelExpr) || !(secondExpr instanceof SQHierarchyLevelExpr))\r\n                return false;\r\n\r\n            let firstLevel = <SQHierarchyLevelExpr>firstExpr;\r\n            let secondLevel = <SQHierarchyLevelExpr>secondExpr;\r\n\r\n            // Validate that both items belong to the same hierarchy\r\n            if (!SQExpr.equals(firstLevel.arg, secondLevel.arg))\r\n                return false;\r\n\r\n            // Determine the order\r\n            let firstIndex = SQExprUtils.indexOfExpr(allLevels, firstLevel);\r\n            let secondIndex = SQExprUtils.indexOfExpr(allLevels, secondLevel);\r\n\r\n            return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\r\n        }\r\n\r\n        /**\r\n         * Given an ordered set of levels and an ordered subset of those levels, returns the index where\r\n         * expr should be inserted into the subset to maintain the correct order.\r\n         */\r\n        export function getInsertionIndex(allLevels: SQHierarchyLevelExpr[], orderedSubsetOfLevels: SQHierarchyLevelExpr[], expr: SQHierarchyLevelExpr): number {\r\n\r\n            let insertIndex = 0;\r\n\r\n            // Loop through the supplied levels until the insertion would no longer be in the correct order\r\n            while (insertIndex < orderedSubsetOfLevels.length &&\r\n                areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\r\n                insertIndex++;\r\n            }\r\n\r\n            return insertIndex;\r\n        }\r\n    }\r\n\r\n    export module SQExprHierarchyToHierarchyLevelConverter {\r\n        export function convert(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(sqExpr, 'sqExpr');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchyExpr = <SQHierarchyExpr>sqExpr;\r\n\r\n                let conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\r\n                if (conceptualHierarchy)\r\n                    return _.map(conceptualHierarchy.levels, hierarchyLevel => SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name));\r\n            }\r\n        }\r\n    }\r\n\r\n    module SQExprHierarchyLevelConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n            let exprs: SQExpr[] = [];\r\n\r\n            if (expr instanceof SQHierarchyLevelExpr) {\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                if (fieldExpr.hierarchyLevel) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                    let hierarchy = schema\r\n                        .schema(fieldExprItem.schema)\r\n                        .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\r\n\r\n                    if (hierarchy) {\r\n                        let hierarchyLevels = hierarchy.levels;\r\n                        for (let hierarchyLevel of hierarchyLevels) {\r\n                            if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\r\n                                exprs.push(expr);\r\n                                break;\r\n                            }\r\n                            else\r\n                                exprs.push(\r\n                                    SQExprBuilder.hierarchyLevel(\r\n                                        SQExprBuilder.hierarchy(\r\n                                            SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                            hierarchy.name),\r\n                                        hierarchyLevel.name)\r\n                                );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return exprs;\r\n        }\r\n    }\r\n\r\n    module SQExprVariationConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n\r\n            let exprs: SQExpr[];\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0) {\r\n                    let variations = column.variations;\r\n\r\n                    // for SU11, we support only one variation\r\n                    debug.assert(variations.length === 1, \"variations.length\");\r\n                    let variation = variations[0];\r\n\r\n                    let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                    exprs = [];\r\n                    if (variation.defaultHierarchy) {\r\n                        let hierarchyExpr = SQExprBuilder.hierarchy(\r\n                            SQExprBuilder.propertyVariationSource(\r\n                                SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                variation.name, conceptualProperty.name),\r\n                            variation.defaultHierarchy.name);\r\n\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            exprs.push(SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\r\n                    }\r\n                }\r\n            }\r\n\r\n            return exprs;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    // A group can consist of either a single expression, or a collection of hierarchy expressions\r\n    export interface SQExprGroup {\r\n        expr: SQExpr;\r\n        children: SQHierarchyLevelExpr[];\r\n\r\n        /** Index of expression in the query. */\r\n        selectQueryIndex: number;\r\n    };\r\n\r\n    export module SQExprGroupUtils {\r\n        /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\r\n        export function groupExprs(schema: FederatedConceptualSchema, exprs: SQExpr[]): SQExprGroup[] {\r\n            let groups: SQExprGroup[] = [];\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i];\r\n                debug.assertValue(expr, \"Expression not found\");\r\n\r\n                if (!(expr instanceof SQHierarchyLevelExpr)) {\r\n                    groups.push({ expr: expr, children: null, selectQueryIndex: i });\r\n                }\r\n                else {\r\n                    addChildToGroup(schema, groups, expr, i);\r\n                }\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function addChildToGroup(\r\n            schema: FederatedConceptualSchema,\r\n            groups: SQExprGroup[],\r\n            expr: SQHierarchyLevelExpr,\r\n            selectQueryIndex: number): void {\r\n\r\n            // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \r\n            // a new Group or to the last Group\r\n            let shouldAddExpressionToNewGroup = true;\r\n            let exprSource = SQHierarchyExprUtils.getSourceVariationExpr(expr) || SQHierarchyExprUtils.getSourceHierarchy(expr);\r\n            let lastGroup = _.last(groups);\r\n\r\n            // The relevant group is always the last added. If it has the same source hierarchy,\r\n            // and is properly ordered within that hierarchy, we will need to add to this group.\r\n            if (lastGroup && lastGroup.children && SQExpr.equals(lastGroup.expr, exprSource)) {\r\n                let expandedExpr = SQHierarchyExprUtils.expandExpr(schema, expr.arg);\r\n                if (expandedExpr instanceof Array) {\r\n                    let allHierarchyLevels = <SQHierarchyLevelExpr[]>expandedExpr;\r\n                    shouldAddExpressionToNewGroup = !SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\r\n                }\r\n            }\r\n\r\n            if (shouldAddExpressionToNewGroup)\r\n                // Use the Sourcevariation as the expression for the group.\r\n                groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\r\n            else {\r\n                debug.assertValue(lastGroup, 'There should be a group to add the variation to');\r\n                debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\r\n                lastGroup.children.push(expr);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    /** Represents an immutable expression within a SemanticQuery. */\r\n    export abstract class SQExpr implements ISQExpr {\r\n        private _kind: SQExprKind;\r\n\r\n        constructor(kind: SQExprKind) {\r\n            debug.assertValue(kind, 'kind');\r\n\r\n            this._kind = kind;\r\n        }\r\n\r\n        public static equals(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            return SQExprEqualityVisitor.run(x, y, ignoreCase);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.accept(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            debug.assertFail('abstract method');\r\n            return;\r\n        }\r\n\r\n        public get kind(): SQExprKind {\r\n            return this._kind;\r\n        }\r\n        \r\n        public static isArithmetic(expr: SQExpr): expr is SQArithmeticExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            \r\n            return expr.kind === SQExprKind.Arithmetic;\r\n        }\r\n\r\n        public static isColumn(expr: SQExpr): expr is SQColumnRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ColumnRef;\r\n        }\r\n\r\n        public static isConstant(expr: SQExpr): expr is SQConstantExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Constant;\r\n        }\r\n\r\n        public static isEntity(expr: SQExpr): expr is SQEntityExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Entity;\r\n        }\r\n\r\n        public static isHierarchy(expr: SQExpr): expr is SQHierarchyExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Hierarchy;\r\n        }\r\n\r\n        public static isHierarchyLevel(expr: SQExpr): expr is SQHierarchyLevelExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.HierarchyLevel;\r\n        }\r\n\r\n        public static isAggregation(expr: SQExpr): expr is SQAggregationExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Aggregation;\r\n        }\r\n\r\n        public static isMeasure(expr: SQExpr): expr is SQMeasureRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.MeasureRef;\r\n        }\r\n\r\n        public static isSelectRef(expr: SQExpr): expr is SQSelectRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.SelectRef;\r\n        }\r\n        \r\n        public static isScopedEval(expr: SQExpr): expr is SQScopedEvalExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            \r\n            return expr.kind === SQExprKind.ScopedEval;\r\n        }\r\n        \r\n        public static isWithRef(expr: SQExpr): expr is SQWithRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            \r\n            return expr.kind === SQExprKind.WithRef;\r\n        }\r\n\r\n        public static isResourcePackageItem(expr: SQExpr): expr is SQResourcePackageItemExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ResourcePackageItem;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            if (field.column || field.columnAggr || field.measure)\r\n                return this.getMetadataForProperty(field, federatedSchema);\r\n\r\n            if (field.hierarchyLevel || field.hierarchyLevelAggr)\r\n                return this.getMetadataForHierarchyLevel(field, federatedSchema);\r\n\r\n            if (field.columnHierarchyLevelVariation)\r\n                return this.getMetadataForVariation(field, federatedSchema);\r\n\r\n            if (field.percentOfGrandTotal)\r\n                return this.getMetadataForPercentOfGrandTotal();\r\n\r\n            return SQExpr.getMetadataForEntity(field, federatedSchema);\r\n        }\r\n\r\n        public getDefaultAggregate(federatedSchema: FederatedConceptualSchema, forceAggregation: boolean = false): QueryAggregateFunction {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n\r\n            if (property && property.kind === ConceptualPropertyKind.Column) {\r\n                let propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\r\n\r\n                if ((property.type.integer || property.type.numeric) &&\r\n                    propertyDefaultAggregate !== ConceptualDefaultAggregate.None) {\r\n                    aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\r\n                    if (aggregate === undefined)\r\n                        aggregate = defaultAggregateForDataType(property.type);\r\n                }\r\n\r\n                // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \r\n                // aggregate on CountNonNull.\r\n                if (aggregate === undefined && forceAggregation) {\r\n                    aggregate = QueryAggregateFunction.CountNonNull;\r\n                }\r\n            }\r\n\r\n            return aggregate;\r\n        }\r\n\r\n        /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\r\n        public getKeyColumns(schema: FederatedConceptualSchema): SQExpr[] {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n\r\n            let keySQExprs: SQExpr[] = [];\r\n            let keys = this.getPropertyKeys(schema);\r\n            if (keys && keys.length > 0) {\r\n                for (let i = 0, len = keys.length; i < len; i++) {\r\n                    keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\r\n                }\r\n            }\r\n            else\r\n                keySQExprs.push(columnRefExpr);\r\n\r\n            return keySQExprs;\r\n        }\r\n\r\n        /** Returns a value indicating whether the expression would group on keys other than itself.*/\r\n        public hasGroupOnKeys(schema: FederatedConceptualSchema): boolean {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n            let keys = this.getPropertyKeys(schema);\r\n\r\n            if (!keys || keys.length < 1)\r\n                return false;\r\n\r\n            if (keys.length > 1)\r\n                return true;\r\n\r\n            let keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\r\n            return !SQExpr.equals(keySqExpr, this);\r\n        }\r\n\r\n        private getPropertyKeys(schema: FederatedConceptualSchema): jsCommon.ArrayNamedItems<ConceptualProperty> {\r\n            let property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            return property.column ? property.column.keys : undefined;\r\n        }\r\n\r\n        public getConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let propertyName = FieldExprPattern.getPropertyName(field);\r\n\r\n            if (propertyName)\r\n                return federatedSchema\r\n                    .schema(fieldExprItem.schema)\r\n                    .findProperty(fieldExprItem.entity, propertyName);\r\n        }\r\n\r\n        public getTargetEntityForVariation(federatedSchema: FederatedConceptualSchema, variationName: string): string {\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (property && property.column && !_.isEmpty(property.column.variations)) {\r\n                let variations = property.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === variationName)\r\n                        return variation.navigationProperty.targetEntity.name;\r\n            }\r\n        }\r\n\r\n        public getTargetEntity(federatedSchema: FederatedConceptualSchema): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\r\n        }\r\n\r\n        private getHierarchyLevelConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\r\n            if (fieldExprHierachyLevel) {\r\n                let fieldExprEntity = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n\r\n                let hierarchy = federatedSchema\r\n                    .schema(fieldExprEntity.schema)\r\n                    .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\r\n\r\n                if (hierarchy) {\r\n                    let hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\r\n                    if (hierarchyLevel)\r\n                        return hierarchyLevel.column;\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForVariation(field: data.FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let sourceProperty = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\r\n\r\n            if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\r\n                for (let variation of sourceProperty.column.variations) {\r\n                    if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\r\n                        for (let level of variation.defaultHierarchy.levels) {\r\n                            if (level.name === columnHierarchyLevelVariation.level.level) {\r\n                                let property = level.column;\r\n                                return {\r\n                                    kind: (property.kind === ConceptualPropertyKind.Measure) ? FieldKind.Measure : FieldKind.Column,\r\n                                    type: property.type,\r\n                                    format: property.format,\r\n                                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                                    defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n                                };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForHierarchyLevel(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private getMetadataForPercentOfGrandTotal(): SQExprMetadata {\r\n            return {\r\n                kind: FieldKind.Measure,\r\n                format: '#,##0.##%',\r\n                type: ValueType.fromExtendedType(ExtendedType.Double)\r\n            };\r\n        }\r\n\r\n        private getPropertyMetadata(field: FieldExprPattern, property: ConceptualProperty): SQExprMetadata {\r\n            let format = property.format;\r\n            let type = property.type;\r\n            let columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\r\n\r\n            if (columnAggregate) {\r\n                switch (columnAggregate.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        type = ValueType.fromExtendedType(ExtendedType.Integer);\r\n                        format = undefined;\r\n                        break;\r\n                    case QueryAggregateFunction.Avg:\r\n                        if (type.integer)\r\n                            type = ValueType.fromExtendedType(ExtendedType.Double);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return {\r\n                kind: (property.kind === ConceptualPropertyKind.Measure || (columnAggregate && columnAggregate.aggregate !== undefined)) ? FieldKind.Measure : FieldKind.Column,\r\n                type: type,\r\n                format: format,\r\n                idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\r\n                defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n            };\r\n        }\r\n\r\n        private getMetadataForProperty(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private static getMetadataForEntity(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let entity = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .entities\r\n                .withName(fieldExprItem.entity);\r\n\r\n            if (!entity)\r\n                return;\r\n\r\n            // We only support count and countnonnull for entity.\r\n            if (field.entityAggr) {\r\n                switch (field.entityAggr.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        return {\r\n                            kind: FieldKind.Measure,\r\n                            type: ValueType.fromExtendedType(ExtendedType.Integer),\r\n                            format: undefined,\r\n                            idOnEntityKey: false,\r\n                            aggregate: field.entityAggr.aggregate\r\n                        };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export const enum SQExprKind {\r\n        Entity,\r\n        ColumnRef,\r\n        MeasureRef,\r\n        Aggregation,\r\n        PropertyVariationSource,\r\n        Hierarchy,\r\n        HierarchyLevel,\r\n        And,\r\n        Between,\r\n        In,\r\n        Or,\r\n        Contains,\r\n        Compare,\r\n        StartsWith,\r\n        Exists,\r\n        Not,\r\n        Constant,\r\n        DateSpan,\r\n        DateAdd,\r\n        Now,\r\n        AnyValue,\r\n        DefaultValue,\r\n        Arithmetic,\r\n        FillRule,\r\n        ResourcePackageItem,\r\n        ScopedEval,\r\n        WithRef,\r\n        Percentile,\r\n        SelectRef,\r\n    }\r\n\r\n    export interface SQExprMetadata {\r\n        kind: FieldKind;\r\n        type: ValueType;\r\n        format?: string;\r\n        idOnEntityKey?: boolean;\r\n        aggregate?: QueryAggregateFunction;\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n    }\r\n\r\n    export const enum FieldKind {\r\n        /** Indicates the field references a column, which evaluates to a distinct set of values (e.g., Year, Name, SalesQuantity, etc.). */\r\n        Column,\r\n\r\n        /** Indicates the field references a measure, which evaluates to a single value (e.g., SalesYTD, Sum(Sales), etc.). */\r\n        Measure,\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateForDataType(type: ValueType): QueryAggregateFunction {\r\n        if (type.integer || type.numeric)\r\n            return QueryAggregateFunction.Sum;\r\n\r\n        return QueryAggregateFunction.Count;\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateToQueryAggregateFunction(aggregate: ConceptualDefaultAggregate): QueryAggregateFunction {\r\n        switch (aggregate) {\r\n            case ConceptualDefaultAggregate.Average:\r\n                return QueryAggregateFunction.Avg;\r\n            case ConceptualDefaultAggregate.Count:\r\n                return QueryAggregateFunction.CountNonNull;\r\n            case ConceptualDefaultAggregate.DistinctCount:\r\n                return QueryAggregateFunction.Count;\r\n            case ConceptualDefaultAggregate.Max:\r\n                return QueryAggregateFunction.Max;\r\n            case ConceptualDefaultAggregate.Min:\r\n                return QueryAggregateFunction.Min;\r\n            case ConceptualDefaultAggregate.Sum:\r\n                return QueryAggregateFunction.Sum;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    export class SQEntityExpr extends SQExpr {\r\n        public schema: string;\r\n        public entity: string;\r\n        public variable: string;\r\n\r\n        constructor(schema: string, entity: string, variable?: string) {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            super(SQExprKind.Entity);\r\n            this.schema = schema;\r\n            this.entity = entity;\r\n            if (variable)\r\n                this.variable = variable;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitEntity(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQArithmeticExpr extends SQExpr {\r\n        public left: SQExpr;\r\n        public right: SQExpr;\r\n        public operator: ArithmeticOperatorKind;\r\n\r\n        constructor(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n            debug.assertValue(operator, 'operator');\r\n\r\n            super(SQExprKind.Arithmetic);\r\n            this.left = left;\r\n            this.right = right;\r\n            this.operator = operator;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitArithmetic(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQScopedEvalExpr extends SQExpr {\r\n        public expression: SQExpr;\r\n        public scope: SQExpr[];\r\n\r\n        constructor(expression: SQExpr, scope: SQExpr[]) {\r\n            debug.assertValue(expression, 'expression');\r\n            debug.assertValue(scope, 'scope');\r\n\r\n            super(SQExprKind.ScopedEval);\r\n            this.expression = expression;\r\n            this.scope = scope;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitScopedEval(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            return this.expression.getMetadata(federatedSchema);\r\n        }\r\n    }\r\n    \r\n    export class SQWithRefExpr extends SQExpr {\r\n        public expressionName: string;\r\n\r\n        constructor(expressionName: string) {\r\n            debug.assertValue(expressionName, 'expressionName');\r\n\r\n            super(SQExprKind.WithRef);\r\n            this.expressionName = expressionName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitWithRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export abstract class SQPropRefExpr extends SQExpr {\r\n        public ref: string;\r\n        public source: SQExpr;\r\n\r\n        constructor(kind: SQExprKind, source: SQExpr, ref: string) {\r\n            debug.assertValue(kind, 'kind');\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            super(kind);\r\n            this.source = source;\r\n            this.ref = ref;\r\n        }\r\n    }\r\n\r\n    export class SQColumnRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.ColumnRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitColumnRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQMeasureRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.MeasureRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitMeasureRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAggregationExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public func: QueryAggregateFunction;\r\n\r\n        constructor(arg: SQExpr, func: QueryAggregateFunction) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(func, 'func');\r\n\r\n            super(SQExprKind.Aggregation);\r\n            this.arg = arg;\r\n            this.func = func;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAggr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPercentileExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public k: number;\r\n        public exclusive: boolean;\r\n\r\n        constructor(arg: SQExpr, k: number, exclusive: boolean) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(k, 'k');\r\n            debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');\r\n            debug.assertValue(exclusive, 'exclusive');\r\n\r\n            super(SQExprKind.Percentile);\r\n            this.arg = arg;\r\n            this.k = k;\r\n            this.exclusive = exclusive;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let argMetadata = this.arg.getMetadata(federatedSchema);\r\n            if (argMetadata) {\r\n                return {\r\n                    kind: FieldKind.Measure,\r\n                    type: argMetadata.type,\r\n                };\r\n            }\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPercentile(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPropertyVariationSourceExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public name: string;\r\n        public property: string;\r\n\r\n        constructor(arg: SQExpr, name: string, property: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(name, 'name');\r\n            debug.assertValue(property, 'property');\r\n\r\n            super(SQExprKind.PropertyVariationSource);\r\n            this.arg = arg;\r\n            this.name = name;\r\n            this.property = property;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPropertyVariationSource(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public hierarchy: string;\r\n\r\n        constructor(arg: SQExpr, hierarchy: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n\r\n            super(SQExprKind.Hierarchy);\r\n            this.arg = arg;\r\n            this.hierarchy = hierarchy;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchy(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyLevelExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public level: string;\r\n\r\n        constructor(arg: SQExpr, level: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(level, 'level');\r\n\r\n            super(SQExprKind.HierarchyLevel);\r\n            this.arg = arg;\r\n            this.level = level;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchyLevel(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQSelectRefExpr extends SQExpr {\r\n        public expressionName: string;\r\n\r\n        constructor(expressionName: string) {\r\n            debug.assertValue(expressionName, 'arg');\r\n\r\n            super(SQExprKind.SelectRef);\r\n            this.expressionName = expressionName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitSelectRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAndExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.And);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQBetweenExpr extends SQExpr {\r\n        arg: SQExpr;\r\n        lower: SQExpr;\r\n        upper: SQExpr;\r\n\r\n        constructor(arg: SQExpr, lower: SQExpr, upper: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(lower, 'lower');\r\n            debug.assertValue(upper, 'upper');\r\n\r\n            super(SQExprKind.Between);\r\n            this.arg = arg;\r\n            this.lower = lower;\r\n            this.upper = upper;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitBetween(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQInExpr extends SQExpr {\r\n        args: SQExpr[];\r\n        values: SQExpr[][];\r\n\r\n        constructor(args: SQExpr[], values: SQExpr[][]) {\r\n            debug.assertValue(args, 'args');\r\n            debug.assertValue(values, 'values');\r\n\r\n            super(SQExprKind.In);\r\n            this.args = args;\r\n            this.values = values;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitIn(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQOrExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Or);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitOr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQCompareExpr extends SQExpr {\r\n        comparison: QueryComparisonKind;\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(comparison: QueryComparisonKind, left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(comparison, 'kind');\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Compare);\r\n            this.comparison = comparison;\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitCompare(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQContainsExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Contains);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitContains(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQStartsWithExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.StartsWith);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitStartsWith(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQExistsExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Exists);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitExists(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNotExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Not);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNot(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQConstantExpr extends SQExpr implements ISQConstantExpr {\r\n        public type: ValueType;\r\n\r\n        /** The native JavaScript representation of the value. */\r\n        public value: any;\r\n\r\n        /** The string encoded, lossless representation of the value. */\r\n        public valueEncoded: string;\r\n\r\n        constructor(type: ValueType, value: any, valueEncoded: string) {\r\n            debug.assertValue(type, 'type');\r\n\r\n            super(SQExprKind.Constant);\r\n            this.type = type;\r\n            this.value = value;\r\n            this.valueEncoded = valueEncoded;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitConstant(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            return {\r\n                // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\r\n                // A getType or similiar function in the future would be more appropriate. \r\n                kind: FieldKind.Measure,\r\n                type: this.type,\r\n            };\r\n        }\r\n    }\r\n\r\n    export class SQDateSpanExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateSpan);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateSpan(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDateAddExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public amount: number;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, amount: number, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(amount, 'amount');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateAdd);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n            this.amount = amount;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateAdd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNowExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.Now);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNow(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDefaultValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.DefaultValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDefaultValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAnyValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.AnyValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnyValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQFillRuleExpr extends SQExpr {\r\n        public input: SQExpr;\r\n        public rule: FillRuleDefinition;\r\n\r\n        constructor(\r\n            input: SQExpr,\r\n            fillRule: FillRuleDefinition) {\r\n            debug.assertValue(input, 'input');\r\n            debug.assertValue(fillRule, 'fillRule');\r\n\r\n            super(SQExprKind.FillRule);\r\n            this.input = input;\r\n            this.rule = fillRule;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitFillRule(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQResourcePackageItemExpr extends SQExpr {\r\n        public packageName: string;\r\n        public packageType: number;\r\n        public itemName: string;\r\n\r\n        constructor(packageName: string, packageType: number, itemName: string) {\r\n            debug.assertValue(packageName, 'packageName');\r\n            debug.assertValue(itemName, 'itemName');\r\n\r\n            super(SQExprKind.ResourcePackageItem);\r\n            this.packageName = packageName;\r\n            this.packageType = packageType;\r\n            this.itemName = itemName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitResourcePackageItem(this, arg);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for creating & manipulating expressions. */\r\n    export module SQExprBuilder {\r\n        export function entity(schema: string, entity: string, variable?: string): SQEntityExpr {\r\n            return new SQEntityExpr(schema, entity, variable);\r\n        }\r\n\r\n        export function columnRef(source: SQExpr, prop: string): SQColumnRefExpr {\r\n            return new SQColumnRefExpr(source, prop);\r\n        }\r\n\r\n        export function measureRef(source: SQExpr, prop: string): SQMeasureRefExpr {\r\n            return new SQMeasureRefExpr(source, prop);\r\n        }\r\n\r\n        export function aggregate(source: SQExpr, aggregate: QueryAggregateFunction): SQAggregationExpr {\r\n            return new SQAggregationExpr(source, aggregate);\r\n        }\r\n\r\n        export function selectRef(expressionName: string): SQSelectRefExpr {\r\n            return new SQSelectRefExpr(expressionName);\r\n        }\r\n\r\n        export function percentile(source: SQExpr, k: number, exclusive: boolean): SQPercentileExpr {\r\n            return new SQPercentileExpr(source, k, exclusive);\r\n        }\r\n\r\n        export function arithmetic(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind): SQArithmeticExpr {\r\n            return new SQArithmeticExpr(left, right, operator);\r\n        }\r\n\r\n        export function scopedEval(expression: SQExpr, scope: SQExpr[]): SQScopedEvalExpr {\r\n            return new SQScopedEvalExpr(expression, scope);\r\n        }\r\n        \r\n        export function withRef(expressionName: string): SQWithRefExpr {\r\n            return new SQWithRefExpr(expressionName);\r\n        }\r\n\r\n        export function hierarchy(source: SQExpr, hierarchy: string): SQHierarchyExpr {\r\n            return new SQHierarchyExpr(source, hierarchy);\r\n        }\r\n\r\n        export function propertyVariationSource(source: SQExpr, name: string, property: string): SQPropertyVariationSourceExpr {\r\n            return new SQPropertyVariationSourceExpr(source, name, property);\r\n        }\r\n\r\n        export function hierarchyLevel(source: SQExpr, level: string): SQHierarchyLevelExpr {\r\n            return new SQHierarchyLevelExpr(source, level);\r\n        }\r\n\r\n        export function and(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n\r\n            return new SQAndExpr(left, right);\r\n        }\r\n\r\n        export function between(arg: SQExpr, lower: SQExpr, upper: SQExpr): SQBetweenExpr {\r\n            return new SQBetweenExpr(arg, lower, upper);\r\n        }\r\n\r\n        export function inExpr(args: SQExpr[], values: SQExpr[][]): SQInExpr {\r\n            return new SQInExpr(args, values);\r\n        }\r\n\r\n        export function or(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n            if (left instanceof SQInExpr && right instanceof SQInExpr) {\r\n                let inExpr = tryUseInExprs(<SQInExpr>left, <SQInExpr>right);\r\n                if (inExpr)\r\n                    return inExpr;\r\n            }\r\n\r\n            return new SQOrExpr(left, right);\r\n        }\r\n\r\n        function tryUseInExprs(left: SQInExpr, right: SQInExpr): SQInExpr {\r\n            if (!left.args || !right.args)\r\n                return;\r\n\r\n            let leftArgLen = left.args.length;\r\n            let rightArgLen = right.args.length;\r\n            if (leftArgLen !== rightArgLen)\r\n                return;\r\n\r\n            for (let i = 0; i < leftArgLen; ++i) {\r\n                if (!SQExpr.equals(left.args[i], right.args[i]))\r\n                    return;\r\n            }\r\n\r\n            let combinedValues = left.values.concat(right.values);\r\n            return SQExprBuilder.inExpr(left.args, combinedValues);\r\n        }\r\n\r\n        export function compare(kind: QueryComparisonKind, left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return new SQCompareExpr(kind, left, right);\r\n        }\r\n\r\n        export function contains(left: SQExpr, right: SQExpr): SQContainsExpr {\r\n            return new SQContainsExpr(left, right);\r\n        }\r\n\r\n        export function exists(arg: SQExpr): SQExistsExpr {\r\n            return new SQExistsExpr(arg);\r\n        }\r\n\r\n        export function equal(left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return compare(QueryComparisonKind.Equal, left, right);\r\n        }\r\n\r\n        export function not(arg: SQExpr): SQNotExpr {\r\n            return new SQNotExpr(arg);\r\n        }\r\n\r\n        export function startsWith(left: SQExpr, right: SQExpr): SQStartsWithExpr {\r\n            return new SQStartsWithExpr(left, right);\r\n        }\r\n\r\n        export function nullConstant(): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Null),\r\n                null,\r\n                PrimitiveValueEncoding.nullEncoding());\r\n        }\r\n\r\n        export function now(): SQNowExpr {\r\n            return new SQNowExpr();\r\n        }\r\n\r\n        export function defaultValue(): SQDefaultValueExpr {\r\n            return new SQDefaultValueExpr();\r\n        }\r\n\r\n        export function anyValue(): SQAnyValueExpr {\r\n            return new SQAnyValueExpr();\r\n        }\r\n\r\n        export function boolean(value: boolean): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Boolean),\r\n                value,\r\n                PrimitiveValueEncoding.boolean(value));\r\n        }\r\n\r\n        export function dateAdd(unit: TimeUnit, amount: number, arg: SQExpr): SQDateAddExpr {\r\n            return new SQDateAddExpr(unit, amount, arg);\r\n        }\r\n\r\n        export function dateTime(value: Date, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.dateTime(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.DateTime), value, valueEncoded);\r\n        }\r\n\r\n        export function dateSpan(unit: TimeUnit, arg: SQExpr): SQDateSpanExpr {\r\n            return new SQDateSpanExpr(unit, arg);\r\n        }\r\n\r\n        export function decimal(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.decimal(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Decimal), value, valueEncoded);\r\n        }\r\n\r\n        export function double(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.double(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Double), value, valueEncoded);\r\n        }\r\n\r\n        export function integer(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.integer(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Integer), value, valueEncoded);\r\n        }\r\n\r\n        export function text(value: string, valueEncoded?: string): SQConstantExpr {\r\n            debug.assert(!valueEncoded || valueEncoded === PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\r\n\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Text),\r\n                value,\r\n                valueEncoded || PrimitiveValueEncoding.text(value));\r\n        }\r\n\r\n        /** Returns an SQExpr that evaluates to the constant value. */\r\n        export function typedConstant(value: PrimitiveValue, type: ValueTypeDescriptor): SQConstantExpr {\r\n            if (value == null)\r\n                return nullConstant();\r\n\r\n            if (_.isBoolean(value)) {\r\n                return boolean(<boolean>value);\r\n            }\r\n\r\n            if (_.isString(value)) {\r\n                return text(<string>value);\r\n            }\r\n\r\n            if (_.isNumber(value)) {\r\n                if (type.integer && Double.isInteger(<number>value))\r\n                    return integer(<number>value);\r\n\r\n                return double(<number>value);\r\n            }\r\n\r\n            if (value instanceof Date) {\r\n                return dateTime(value);\r\n            }\r\n        }\r\n\r\n        export function setAggregate(expr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);\r\n        }\r\n\r\n        export function removeAggregate(expr: SQExpr): SQExpr {\r\n            return FieldExprRemoveAggregateRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function setPercentOfGrandTotal(expr: SQExpr): SQExpr {\r\n            return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removePercentOfGrandTotal(expr: SQExpr): SQExpr {\r\n            return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removeEntityVariables(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function fillRule(expr: SQExpr, rule: FillRuleDefinition): SQFillRuleExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(rule, 'rule');\r\n\r\n            return new SQFillRuleExpr(expr, rule);\r\n        }\r\n\r\n        export function resourcePackageItem(packageName: string, packageType: number, itemName: string): SQResourcePackageItemExpr {\r\n            return new SQResourcePackageItemExpr(packageName, packageType, itemName);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for obtaining information about expressions. */\r\n    export module SQExprInfo {\r\n        export function getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            return SQExprAggregateInfoVisitor.getAggregate(expr);\r\n        }\r\n    }\r\n\r\n    class SQExprEqualityVisitor implements ISQExprVisitorWithArg<boolean, SQExpr>, IFillRuleDefinitionVisitor<boolean, boolean> {\r\n        private static instance: SQExprEqualityVisitor = new SQExprEqualityVisitor(/* ignoreCase */ false);\r\n        private static ignoreCaseInstance: SQExprEqualityVisitor = new SQExprEqualityVisitor(true);\r\n        private ignoreCase: boolean;\r\n\r\n        public static run(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n            if (ignoreCase)\r\n                return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\r\n\r\n            return x.accept(SQExprEqualityVisitor.instance, y);\r\n        }\r\n\r\n        constructor(ignoreCase: boolean) {\r\n            this.ignoreCase = ignoreCase;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, comparand: SQColumnRefExpr): boolean {\r\n            return comparand instanceof SQColumnRefExpr &&\r\n                expr.ref === (<SQColumnRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQColumnRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, comparand: SQMeasureRefExpr): boolean {\r\n            return comparand instanceof SQMeasureRefExpr &&\r\n                expr.ref === (<SQMeasureRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQMeasureRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAggregationExpr &&\r\n                expr.func === (<SQAggregationExpr>comparand).func &&\r\n                this.equals(expr.arg, (<SQAggregationExpr>comparand).arg);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQPercentileExpr &&\r\n                expr.exclusive === comparand.exclusive &&\r\n                expr.k === comparand.k &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, comparand: SQHierarchyExpr): boolean {\r\n            return comparand instanceof SQHierarchyExpr &&\r\n                expr.hierarchy === comparand.hierarchy &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, comparand: SQHierarchyLevelExpr): boolean {\r\n            return comparand instanceof SQHierarchyLevelExpr &&\r\n                expr.level === comparand.level &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, comparand: SQPropertyVariationSourceExpr): boolean {\r\n            return comparand instanceof SQPropertyVariationSourceExpr &&\r\n                expr.name === comparand.name &&\r\n                expr.property === comparand.property &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr, comparand: SQSelectRefExpr): boolean {\r\n            return comparand instanceof SQSelectRefExpr &&\r\n                expr.expressionName === comparand.expressionName;\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQBetweenExpr &&\r\n                this.equals(expr.arg, (<SQBetweenExpr>comparand).arg) &&\r\n                this.equals(expr.lower, (<SQBetweenExpr>comparand).lower) &&\r\n                this.equals(expr.upper, (<SQBetweenExpr>comparand).upper);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, comparand: SQExpr): boolean {\r\n            if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, (<SQInExpr>comparand).args))\r\n                return false;\r\n\r\n            let values = expr.values,\r\n                compareValues = (<SQInExpr>comparand).values;\r\n            if (values.length !== compareValues.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                if (!this.equalsAll(values[i], compareValues[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQEntityExpr &&\r\n                expr.schema === (<SQEntityExpr>comparand).schema &&\r\n                expr.entity === (<SQEntityExpr>comparand).entity &&\r\n                this.optionalEqual(expr.variable, (<SQEntityExpr>comparand).variable);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAndExpr &&\r\n                this.equals(expr.left, (<SQAndExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQAndExpr>comparand).right);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQOrExpr &&\r\n                this.equals(expr.left, (<SQOrExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQOrExpr>comparand).right);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQCompareExpr &&\r\n                expr.comparison === (<SQCompareExpr>comparand).comparison &&\r\n                this.equals(expr.left, (<SQCompareExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQCompareExpr>comparand).right);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQContainsExpr &&\r\n                this.equals(expr.left, (<SQContainsExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQContainsExpr>comparand).right);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateSpanExpr &&\r\n                expr.unit === (<SQDateSpanExpr>comparand).unit &&\r\n                this.equals(expr.arg, (<SQDateSpanExpr>comparand).arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateAddExpr &&\r\n                expr.unit === (<SQDateAddExpr>comparand).unit &&\r\n                expr.amount === (<SQDateAddExpr>comparand).amount &&\r\n                this.equals(expr.arg, (<SQDateAddExpr>comparand).arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQExistsExpr &&\r\n                this.equals(expr.arg, (<SQExistsExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNotExpr &&\r\n                this.equals(expr.arg, (<SQNotExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNowExpr;\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDefaultValueExpr;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAnyValueExpr;\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQResourcePackageItemExpr &&\r\n                expr.packageName === comparand.packageName &&\r\n                expr.packageType === comparand.packageType &&\r\n                expr.itemName === comparand.itemName;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQStartsWithExpr &&\r\n                this.equals(expr.left, (<SQStartsWithExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQStartsWithExpr>comparand).right);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQConstantExpr && expr.type === (<SQConstantExpr>comparand).type)\r\n                return expr.type.text && this.ignoreCase ?\r\n                    StringExtensions.equalIgnoreCase(expr.valueEncoded, (<SQConstantExpr>comparand).valueEncoded) :\r\n                    expr.valueEncoded === (<SQConstantExpr>comparand).valueEncoded;\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\r\n                let leftRule = expr.rule,\r\n                    rightRule = comparand.rule;\r\n\r\n                if (leftRule === rightRule)\r\n                    return true;\r\n\r\n                let leftLinearGradient2 = leftRule.linearGradient2,\r\n                    rightLinearGradient2 = rightRule.linearGradient2;\r\n                if (leftLinearGradient2 && rightLinearGradient2) {\r\n                    return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\r\n                }\r\n\r\n                let leftLinearGradient3 = leftRule.linearGradient3,\r\n                    rightLinearGradient3 = rightRule.linearGradient3;\r\n                if (leftLinearGradient3 && rightLinearGradient3) {\r\n                    return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitLinearGradient2(left2: LinearGradient2Definition, right2: LinearGradient2Definition): boolean {\r\n            debug.assertValue(left2, 'left2');\r\n            debug.assertValue(right2, 'right2');\r\n\r\n            return this.equalsFillRuleStop(left2.min, right2.min) &&\r\n                this.equalsFillRuleStop(left2.max, right2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(left3: LinearGradient3Definition, right3: LinearGradient3Definition): boolean {\r\n            debug.assertValue(left3, 'left3');\r\n            debug.assertValue(right3, 'right3');\r\n\r\n            return this.equalsFillRuleStop(left3.min, right3.min) &&\r\n                this.equalsFillRuleStop(left3.mid, right3.mid) &&\r\n                this.equalsFillRuleStop(left3.max, right3.max);\r\n        }\r\n\r\n        private equalsFillRuleStop(stop1: RuleColorStopDefinition, stop2: RuleColorStopDefinition): boolean {\r\n            debug.assertValue(stop1, 'stop1');\r\n            debug.assertValue(stop2, 'stop2');\r\n\r\n            if (!this.equals(stop1.color, stop2.color))\r\n                return false;\r\n\r\n            if (!stop1.value)\r\n                return stop1.value === stop2.value;\r\n\r\n            return this.equals(stop1.value, stop2.value);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQArithmeticExpr &&\r\n                expr.operator === (<SQArithmeticExpr>comparand).operator &&\r\n                this.equals(expr.left, (<SQArithmeticExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQArithmeticExpr>comparand).right);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQScopedEvalExpr &&\r\n                this.equals(expr.expression, comparand.expression) &&\r\n                this.equalsAll(expr.scope, comparand.scope);\r\n        }\r\n        \r\n        public visitWithRef(expr: SQWithRefExpr, comparand: SQExpr): boolean {\r\n            return  comparand instanceof SQWithRefExpr &&\r\n                expr.expressionName === comparand.expressionName;\r\n        }\r\n\r\n        private optionalEqual(x: string, y: string) {\r\n            // Only check equality if both values are specified.\r\n            if (x && y)\r\n                return x === y;\r\n\r\n            return true;\r\n        }\r\n\r\n        private equals(x: SQExpr, y: SQExpr): boolean {\r\n            return x.accept(this, y);\r\n        }\r\n\r\n        private equalsAll(x: SQExpr[], y: SQExpr[]): boolean {\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!this.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /** Rewrites a root-level expression. */\r\n    class SQExprRootRewriter extends DefaultSQExprVisitor<SQExpr> {\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    export const enum SQExprValidationError {\r\n        invalidAggregateFunction,\r\n        invalidSchemaReference,\r\n        invalidEntityReference,\r\n        invalidColumnReference,\r\n        invalidMeasureReference,\r\n        invalidHierarchyReference,\r\n        invalidHierarchyLevelReference,\r\n        invalidLeftOperandType,\r\n        invalidRightOperandType,\r\n        invalidValueType,\r\n        invalidPercentileArgument,\r\n        invalidScopeArgument,\r\n    }\r\n\r\n    export class SQExprValidationVisitor extends SQExprRewriter {\r\n        public errors: SQExprValidationError[];\r\n        private schema: FederatedConceptualSchema;\r\n        private aggrUtils: ISQAggregationOperations;\r\n\r\n        constructor(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]) {\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertValue(aggrUtils, 'aggrUtils');\r\n\r\n            super();\r\n            this.schema = schema;\r\n            this.aggrUtils = aggrUtils;\r\n            if (errors)\r\n                this.errors = errors;\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): SQExpr {\r\n            let inExpr = <SQInExpr>super.visitIn(expr);\r\n            let args = inExpr.args;\r\n            let values = inExpr.values;\r\n            for (let valueTuple of values) {\r\n                debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\r\n                for (let i = 0, len = valueTuple.length; i < len; ++i)\r\n                    this.validateCompatibleType(args[i], valueTuple[i]);\r\n            }\r\n\r\n            return inExpr;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQExpr {\r\n            let compareExpr = <SQCompareExpr>super.visitCompare(expr);\r\n            this.validateCompatibleType(compareExpr.left, compareExpr.right);\r\n\r\n            return compareExpr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.column.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Column ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidColumnReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.measure.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Measure ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidMeasureReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let aggregateExpr = <SQAggregationExpr>super.visitAggr(expr);\r\n\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\r\n            if (columnRefExpr) {\r\n                if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/null))\r\n                    this.register(SQExprValidationError.invalidAggregateFunction);\r\n            }\r\n\r\n            return aggregateExpr;\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem: FieldExprHierarchyPattern = <FieldExprHierarchyPattern>fieldExpr.hierarchy;\r\n                if (fieldExprItem) {\r\n                    this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\r\n                } else {\r\n                    this.register(SQExprValidationError.invalidHierarchyReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let hierarchyLevelFieldExprItem: FieldExprHierarchyLevelPattern = <FieldExprHierarchyLevelPattern>fieldExpr.hierarchyLevel;\r\n                if (hierarchyLevelFieldExprItem) {\r\n                    this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\r\n                } else if (!fieldExpr.columnHierarchyLevelVariation) {\r\n                    this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): SQExpr {\r\n            expr.arg.accept(this);\r\n\r\n            if (_.isEmpty(this.errors)) {\r\n                let argMetadata = expr.arg.getMetadata(this.schema);\r\n                if (!argMetadata ||\r\n                    argMetadata.kind !== FieldKind.Column ||\r\n                    !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {\r\n                    this.register(SQExprValidationError.invalidPercentileArgument);\r\n                }\r\n            }\r\n\r\n            return expr;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            this.validateEntity(expr.schema, expr.entity);\r\n            return expr;\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): SQExpr {\r\n            this.validateArithmeticTypes(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): SQExpr {\r\n            for (let scopeRef of expr.scope) {\r\n                if (!(SQExpr.isWithRef(scopeRef) || SQExpr.isColumn(scopeRef))) {\r\n                    this.register(SQExprValidationError.invalidScopeArgument);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n        \r\n        public visitWithRef(expr: SQWithRefExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        private validateOperandsAndTypeForStartOrContains(left: SQExpr, right: SQExpr): void {\r\n            if (left instanceof SQColumnRefExpr) {\r\n                this.visitColumnRef(<SQColumnRefExpr>left);\r\n            } else if (left instanceof SQHierarchyLevelExpr) {\r\n                this.visitHierarchyLevel(<SQHierarchyLevelExpr>left);\r\n            } else {\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            }\r\n\r\n            if (!(right instanceof SQConstantExpr) || !(<SQConstantExpr>right).type.text)\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n            else\r\n                this.validateCompatibleType(left, right);\r\n        }\r\n\r\n        private validateArithmeticTypes(left: SQExpr, right: SQExpr): void {\r\n            if (!SQExprUtils.supportsArithmetic(left, this.schema))\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            if (!SQExprUtils.supportsArithmetic(right, this.schema))\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n        }\r\n\r\n        private validateCompatibleType(left: SQExpr, right: SQExpr): void {\r\n            let leftMetadata = left.getMetadata(this.schema),\r\n                leftType = leftMetadata && leftMetadata.type,\r\n                rightMetadata = right.getMetadata(this.schema),\r\n                rightType = rightMetadata && rightMetadata.type;\r\n\r\n            if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\r\n                this.register(SQExprValidationError.invalidValueType);\r\n        }\r\n\r\n        private validateEntity(schemaName: string, entityName: string): ConceptualEntity {\r\n            let schema = this.schema.schema(schemaName);\r\n            if (schema) {\r\n                let entity = schema.entities.withName(entityName);\r\n                if (entity)\r\n                    return entity;\r\n\r\n                this.register(SQExprValidationError.invalidEntityReference);\r\n            }\r\n            else {\r\n                this.register(SQExprValidationError.invalidSchemaReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchy(schemaName: string, entityName: string, hierarchyName: string): ConceptualHierarchy {\r\n            let entity = this.validateEntity(schemaName, entityName);\r\n            if (entity) {\r\n                let hierarchy = entity.hierarchies.withName(hierarchyName);\r\n                if (hierarchy)\r\n                    return hierarchy;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchyLevel(schemaName: string, entityName: string, hierarchyName: string, levelName: string): ConceptualHierarchyLevel {\r\n            let hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\r\n            if (hierarchy) {\r\n                let hierarchyLevel = hierarchy.levels.withName(levelName);\r\n                if (hierarchyLevel)\r\n                    return hierarchyLevel;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n            }\r\n        }\r\n\r\n        private register(error: SQExprValidationError) {\r\n            if (!this.errors)\r\n                this.errors = [];\r\n            this.errors.push(error);\r\n        }\r\n\r\n        private isQueryable(fieldExpr: FieldExprPattern): boolean {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\r\n                let hierarchyLevelConceptualProperty = SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\r\n                return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== ConceptualQueryableState.Error;\r\n            }\r\n\r\n            return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, FieldExprPattern.getPropertyName(fieldExpr)).queryable !== ConceptualQueryableState.Error;\r\n        }\r\n    }\r\n\r\n    /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\r\n    class SQExprAggregateInfoVisitor extends DefaultSQExprVisitor<QueryAggregateFunction> {\r\n        public visitAggr(expr: SQAggregationExpr): QueryAggregateFunction {\r\n            return expr.func;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): QueryAggregateFunction {\r\n            return;\r\n        }\r\n\r\n        public static getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            let visitor = new SQExprAggregateInfoVisitor();\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQExprColumnRef expression or undefined.*/\r\n    class SQExprColumnRefInfoVisitor extends DefaultSQExprVisitor<SQColumnRefExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQColumnRefExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let ref: string = expr.level;\r\n            let hierarchy = <SQHierarchyExpr>(expr.arg);\r\n            let sourceExpr: SQColumnRefExpr = hierarchy.accept(this);\r\n\r\n            if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\r\n                let propertyVariationSource = <SQPropertyVariationSourceExpr>hierarchy.arg;\r\n                let targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\r\n\r\n                if (sourceExpr && targetEntity) {\r\n                    let schemaName = (<SQEntityExpr>(sourceExpr.source)).schema;\r\n                    let targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\r\n                    let schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\r\n\r\n                    if (schemaHierarchy) {\r\n                        for (let level of schemaHierarchy.levels)\r\n                            if (level.name === ref)\r\n                                return new SQColumnRefExpr(targetEntityExpr, level.column.name);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let entityExpr = <SQEntityExpr>(hierarchy.arg);\r\n                let hierarchyLevelRef = SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema,\r\n                    entityExpr.schema,\r\n                    entityExpr.entity,\r\n                    hierarchy.hierarchy,\r\n                    expr.level);\r\n\r\n                if (hierarchyLevelRef)\r\n                    return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\r\n            }\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQColumnRefExpr {\r\n            let propertyName = expr.property;\r\n            return new SQColumnRefExpr(expr.arg, propertyName);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQColumnRefExpr {\r\n            return;\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQEntityExpr expression or undefined.*/\r\n    class SQEntityExprInfoVisitor extends DefaultSQExprVisitor<SQEntityExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQEntityExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntity(expr);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQEntityExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQEntityExpr {\r\n            return expr.source.accept(this);\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n\r\n        public static getEntity(columnRef: SQColumnRefExpr): SQEntityExpr {\r\n            let field = SQExprConverter.asFieldPattern(columnRef);\r\n            let column = field.column;\r\n            return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\r\n        }\r\n\r\n        public static getEntityExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQEntityExpr {\r\n            let visitor = new SQEntityExprInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    class SQExprChangeAggregateRewriter extends SQExprRootRewriter {\r\n        private func: QueryAggregateFunction;\r\n\r\n        constructor(func: QueryAggregateFunction) {\r\n            debug.assertValue(func, 'func');\r\n\r\n            super();\r\n            this.func = func;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            if (expr.func === this.func)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(expr.arg, this.func);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            return new SQAggregationExpr(expr, this.func);\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, func: QueryAggregateFunction): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(func, 'func');\r\n\r\n            let rewriter = new SQExprChangeAggregateRewriter(func);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    class FieldExprChangeAggregateRewriter implements IFieldExprPatternVisitor<SQExpr> {\r\n        private sqExpr: SQExpr;\r\n        private aggregate: QueryAggregateFunction;\r\n\r\n        constructor(sqExpr: SQExpr, aggregate: QueryAggregateFunction) {\r\n            this.sqExpr = sqExpr;\r\n            this.aggregate = aggregate;\r\n        }\r\n\r\n        public static rewrite(sqExpr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));\r\n        }\r\n\r\n        public visitPercentOfGrandTotal(pattern: FieldExprPercentOfGrandTotalPattern): SQExpr {\r\n            pattern.baseExpr = SQExprConverter.asFieldPattern(\r\n                SQExprChangeAggregateRewriter.rewrite(\r\n                    SQExprBuilder.fieldExpr(pattern.baseExpr),\r\n                    this.aggregate));\r\n            return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });\r\n        }\r\n\r\n        public visitColumn(column: FieldExprColumnPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntity(entity: FieldExprEntityPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchy(hierarchy: FieldExprHierarchyPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitMeasure(measure: FieldExprMeasurePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitPercentile(percentile: FieldExprPercentilePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        private defaultRewrite(): SQExpr {\r\n            return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);\r\n        }\r\n    }\r\n\r\n    class FieldExprRemoveAggregateRewriter implements IFieldExprPatternVisitor<SQExpr> {\r\n\r\n        constructor(private sqExpr: SQExpr) {\r\n        }\r\n\r\n        public static rewrite(sqExpr: SQExpr): SQExpr {\r\n            return FieldExprPattern.visit(sqExpr, new FieldExprRemoveAggregateRewriter(sqExpr));\r\n        }\r\n\r\n        public visitPercentOfGrandTotal(pattern: FieldExprPercentOfGrandTotalPattern): SQExpr {\r\n            return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr));\r\n        }\r\n\r\n        public visitColumn(column: FieldExprColumnPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntity(entity: FieldExprEntityPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchy(hierarchy: FieldExprHierarchyPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitMeasure(measure: FieldExprMeasurePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitPercentile(percentile: FieldExprPercentilePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        private defaultRewrite(): SQExpr {\r\n            return SQExprRemoveAggregateRewriter.rewrite(this.sqExpr);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveAggregateRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemoveAggregateRewriter = new SQExprRemoveAggregateRewriter();\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            return expr.arg;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveAggregateRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveEntityVariablesRewriter extends SQExprRewriter {\r\n        private static instance: SQExprRemoveEntityVariablesRewriter = new SQExprRemoveEntityVariablesRewriter();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            if (expr.variable)\r\n                return SQExprBuilder.entity(expr.schema, expr.entity);\r\n\r\n            return expr;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemovePercentOfGrandTotalRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemovePercentOfGrandTotalRewriter = new SQExprRemovePercentOfGrandTotalRewriter();\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr && fieldExpr.percentOfGrandTotal)\r\n                expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    class SQExprSetPercentOfGrandTotalRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprSetPercentOfGrandTotalRewriter = new SQExprSetPercentOfGrandTotalRewriter();\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr && !fieldExpr.percentOfGrandTotal)\r\n                expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: SQExprConverter.asFieldPattern(expr) } });\r\n\r\n            return expr;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import ConceptualEntity = powerbi.data.ConceptualEntity;\r\n    import ConceptualMultiplicity = powerbi.data.ConceptualMultiplicity;\r\n    import SQEntityExpr = powerbi.data.SQEntityExpr;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    export module SQExprUtils {\r\n        export function supportsArithmetic(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let metadata = expr.getMetadata(schema),\r\n                type = metadata && metadata.type;\r\n\r\n            if (!metadata || !type) {\r\n                return false;\r\n            }\r\n            \r\n            return type.numeric || type.dateTime || type.duration;\r\n        }\r\n\r\n        export function indexOfExpr(items: SQExpr[], searchElement: SQExpr): number {\r\n            debug.assertValue(items, 'items');\r\n            debug.assertValue(searchElement, 'searchElement');\r\n\r\n            for (let i = 0, len = items.length; i < len; i++) {\r\n                if (SQExpr.equals(items[i], searchElement))\r\n                    return i;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function sequenceEqual(x: SQExpr[], y: SQExpr[]): boolean {\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!SQExpr.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n        \r\n        export function uniqueName(namedItems: NamedSQExpr[], expr: SQExpr, exprDefaultName?: string): string {\r\n            debug.assertValue(namedItems, 'namedItems');\r\n\r\n            // Determine all names\r\n            let names: { [name: string]: boolean } = {};\r\n            for (let i = 0, len = namedItems.length; i < len; i++)\r\n                names[namedItems[i].name] = true;\r\n\r\n            return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\r\n        }\r\n\r\n        /** Generates a default expression name  */\r\n        export function defaultName(expr: SQExpr, fallback: string = 'select'): string {\r\n            if (!expr)\r\n                return fallback;\r\n\r\n            return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a model measure or an aggregate. */\r\n        export function isMeasure(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsMeasureVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\r\n        export function isAnyValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsAnyValueVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\r\n        export function isDefaultValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsDefaultValueVisitor.instance);\r\n        }\r\n\r\n        export function discourageAggregation(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let capabilities = getSchemaCapabilities(expr, schema);\r\n            return capabilities && capabilities.discourageQueryAggregateUsage;\r\n        }\r\n\r\n        export function getAggregateBehavior(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualAggregateBehavior {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let column = getConceptualColumn(expr, schema);\r\n            if (column)\r\n                return column.aggregateBehavior;\r\n        }\r\n\r\n        export function getSchemaCapabilities(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualCapabilities {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(expr);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let conceptualSchema = schema.schema(fieldExprItem.schema);\r\n            if (conceptualSchema)\r\n                return conceptualSchema.capabilities;\r\n        }\r\n\r\n        export function getKpiMetadata(expr: SQExpr, schema: FederatedConceptualSchema): DataViewKpiColumnMetadata {\r\n            let kpiStatusProperty = getKpiStatusProperty(expr, schema);\r\n            if (kpiStatusProperty)\r\n                return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\r\n\r\n            let kpiTrendProperty = getKpiTrendProperty(expr, schema);\r\n            if (kpiTrendProperty)\r\n                return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\r\n        }\r\n\r\n        export function getConceptualEntity(entityExpr: SQEntityExpr, schema: FederatedConceptualSchema): ConceptualEntity {\r\n            debug.assertValue(entityExpr, 'entityExpr');\r\n\r\n            let conceptualEntity = schema\r\n                .schema(entityExpr.schema)\r\n                .entities\r\n                .withName(entityExpr.entity);\r\n            return conceptualEntity;\r\n        }\r\n\r\n        function getKpiStatusProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.status === property)\r\n                return property;\r\n        }\r\n\r\n        function getKpiTrendProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.trend === property)\r\n                return property;\r\n        }\r\n\r\n        export function getDefaultValue(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): SQConstantExpr {\r\n            let column = getConceptualColumn(fieldSQExpr, schema);\r\n            if (column)\r\n                return column.defaultValue;\r\n        }\r\n\r\n        function getConceptualColumn(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): ConceptualColumn {\r\n            if (!fieldSQExpr || !schema)\r\n                return;\r\n\r\n            let sqField = SQExprConverter.asFieldPattern(fieldSQExpr);\r\n            if (!sqField)\r\n                return;\r\n\r\n            let column: FieldExprPropertyPattern = sqField.column;\r\n\r\n            if (column) {\r\n                if (schema.schema(column.schema) && sqField.column.name) {\r\n                    let property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\r\n\r\n                    if (property)\r\n                        return property.column;\r\n                }\r\n            }\r\n            else {\r\n                let hierarchyLevelField: FieldExprHierarchyLevelPattern = sqField.hierarchyLevel;\r\n                if (hierarchyLevelField) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(sqField);\r\n                    let schemaName = fieldExprItem.schema;\r\n                    if (schema.schema(schemaName)) {\r\n                        let hierarchy = schema.schema(schemaName)\r\n                            .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\r\n\r\n                        if (hierarchy) {\r\n                            let hierarchyLevel: ConceptualHierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\r\n                            if (hierarchyLevel && hierarchyLevel.column)\r\n                                return hierarchyLevel.column.column;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function getDefaultValues(fieldSQExprs: SQExpr[], schema: FederatedConceptualSchema): SQConstantExpr[] {\r\n            if (_.isEmpty(fieldSQExprs) || !schema)\r\n                return;\r\n            let result: SQConstantExpr[] = [];\r\n            for (let sqExpr of fieldSQExprs) {\r\n                let defaultValue = getDefaultValue(sqExpr, schema);\r\n                if (defaultValue)\r\n                    result.push(defaultValue);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Return compare or and expression for key value pairs. */\r\n        export function getDataViewScopeIdentityComparisonExpr(fieldsExpr: SQExpr[], values: SQConstantExpr[]): SQExpr {\r\n            debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\r\n\r\n            let compareExprs: SQCompareExpr[] = [];\r\n            for (let i = 0; i < fieldsExpr.length; i++) {\r\n                compareExprs.push(SQExprBuilder.compare(QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\r\n            }\r\n\r\n            if (_.isEmpty(compareExprs))\r\n                return;\r\n\r\n            let resultExpr: SQExpr;\r\n            for (let compareExpr of compareExprs) {\r\n                resultExpr = SQExprBuilder.and(resultExpr, compareExpr);\r\n            }\r\n\r\n            return resultExpr;\r\n        }\r\n\r\n        export function getActiveTablesNames(queryDefn: data.SemanticQuery): string[] {\r\n            let tables: string[] = [];\r\n            if (queryDefn) {\r\n                let selectedItems = queryDefn.from();\r\n                if (selectedItems !== undefined) {\r\n                    for (let key of selectedItems.keys()) {\r\n                        let entityObj = selectedItems.entity(key);\r\n                        if (tables.indexOf(entityObj.entity) < 0)\r\n                            tables.push(entityObj.entity);\r\n                    }\r\n                }\r\n            }\r\n            return tables;\r\n        }\r\n\r\n        export function isRelatedToMany(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne);\r\n        }\r\n\r\n        export function isRelatedToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many);\r\n        }\r\n\r\n        function isRelated(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr,\r\n            sourceMultiplicity: ConceptualMultiplicity,\r\n            targetMultiplicity: ConceptualMultiplicity): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n\r\n            if (_.isEmpty(source.navigationProperties))\r\n                return false;\r\n\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let queue: ConceptualEntity[] = [];\r\n            queue.push(source);\r\n\r\n            // walk the relationship path from source.\r\n            while (!_.isEmpty(queue)) {\r\n                let current = queue.shift();\r\n\r\n                let navProperties = current.navigationProperties;\r\n                if (_.isEmpty(navProperties))\r\n                    continue;\r\n\r\n                for (let navProperty of navProperties) {\r\n                    if (!navProperty.isActive)\r\n                        continue;\r\n\r\n                    if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\r\n                        if (navProperty.targetEntity === target)\r\n                            return true;\r\n                        queue.push(navProperty.targetEntity);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRelatedOneToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let sourceNavigations = source.navigationProperties;\r\n            let targetNavigations = target.navigationProperties;\r\n\r\n            if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\r\n                return false;\r\n\r\n            return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\r\n        }\r\n\r\n        function hasOneToOneNavigation(navigationProperties: ArrayNamedItems<ConceptualNavigationProperty>, targetEntity: ConceptualEntity): boolean {\r\n            if (_.isEmpty(navigationProperties))\r\n                return false;\r\n\r\n            for (let navigationProperty of navigationProperties) {\r\n                if (!navigationProperty.isActive)\r\n                    continue;\r\n\r\n                if (navigationProperty.targetEntity !== targetEntity)\r\n                    continue;\r\n\r\n                if (navigationProperty.sourceMultiplicity === ConceptualMultiplicity.ZeroOrOne &&\r\n                    navigationProperty.targetMultiplicity === ConceptualMultiplicity.ZeroOrOne) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\r\n            and returns a new array. When available, we should use _.unionWith from lodash. */\r\n        export function concatUnique(leftExprs: SQExpr[], rightExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(leftExprs, 'leftExprs');\r\n            debug.assertValue(rightExprs, 'rightExprs');\r\n\r\n            let concatExprs = ArrayExtensions.copy(leftExprs);\r\n            for (let expr of rightExprs) {\r\n                if (indexOfExpr(concatExprs, expr) === -1) {\r\n                    concatExprs.push(expr);\r\n                }\r\n            }\r\n\r\n            return concatExprs;\r\n        }\r\n\r\n        class SQExprDefaultNameGenerator extends DefaultSQExprVisitorWithArg<string, string> {\r\n            public static instance: SQExprDefaultNameGenerator = new SQExprDefaultNameGenerator();\r\n\r\n            public visitEntity(expr: SQEntityExpr): string {\r\n                return expr.entity;\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, fallback: string): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, fallback: string): string {\r\n                return QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\r\n            }\r\n\r\n            public visitPercentile(expr: SQPercentileExpr, fallback: string): string {\r\n                let func = expr.exclusive\r\n                    ? 'Percentile.Exc('\r\n                    : 'Percentile.Inc(';\r\n\r\n                return func + expr.arg.accept(this) + ', ' + expr.k + ')';\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr, fallback: string): string {\r\n                return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): string {\r\n                return 'const';\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr, fallback: string): string {\r\n                return fallback || 'expr';\r\n            }\r\n        }\r\n\r\n        class IsMeasureVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsMeasureVisitor = new IsMeasureVisitor();\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsDefaultValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsDefaultValueVisitor = new IsDefaultValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsAnyValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsAnyValueVisitor = new IsAnyValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export class SemanticQueryRewriter {\r\n        private exprRewriter: ISQExprVisitor<SQExpr>;\r\n\r\n        constructor(exprRewriter: ISQExprVisitor<SQExpr>) {\r\n            this.exprRewriter = exprRewriter;\r\n        }\r\n\r\n        public rewriteFrom(fromValue: SQFrom): SQFrom {\r\n            let fromContents: { [name: string]: SQFromEntitySource } = {};\r\n            let originalFrom = fromValue,\r\n                originalFromKeys = originalFrom.keys();\r\n            for (let i = 0, len = originalFromKeys.length; i < len; i++) {\r\n                let keyName = originalFromKeys[i],\r\n                    originalEntityRef = originalFrom.entity(keyName),\r\n                    originalEntityExpr = SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName),\r\n                    updatedEntityExpr = <SQEntityExpr>originalEntityExpr.accept(this.exprRewriter);\r\n                \r\n                fromContents[keyName] = {\r\n                    schema: updatedEntityExpr.schema,\r\n                    entity: updatedEntityExpr.entity,\r\n                };\r\n            }\r\n            return new SQFrom(fromContents);\r\n        }\r\n\r\n        public rewriteSelect(selectItems: NamedSQExpr[], from: SQFrom): NamedSQExpr[]{\r\n            debug.assertValue(selectItems, 'selectItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            return this.rewriteNamedSQExpressions(selectItems, from);\r\n        }\r\n\r\n        public rewriteGroupBy(groupByitems: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertAnyValue(groupByitems, 'groupByitems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(groupByitems))\r\n                return;\r\n\r\n            return this.rewriteNamedSQExpressions(groupByitems, from);\r\n        }\r\n\r\n        private rewriteNamedSQExpressions(expressions: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertValue(expressions, 'expressions');\r\n\r\n            return _.map(expressions, item => {\r\n                return {\r\n                    name: item.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from)\r\n                };\r\n            });\r\n        }\r\n\r\n        public rewriteOrderBy(orderByItems: SQSortDefinition[], from: SQFrom): SQSortDefinition[]{\r\n            debug.assertAnyValue(orderByItems, 'orderByItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(orderByItems))\r\n                return;\r\n\r\n            let orderBy: SQSortDefinition[] = [];\r\n            for (let i = 0, len = orderByItems.length; i < len; i++) {\r\n                let item = orderByItems[i],\r\n                    updatedExpr = SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\r\n                orderBy.push({\r\n                        direction: item.direction,\r\n                        expr: updatedExpr,\r\n                    });\r\n            }\r\n\r\n            return orderBy;\r\n        }\r\n\r\n        public rewriteWhere(whereItems: SQFilter[], from: SQFrom): SQFilter[]{\r\n            debug.assertAnyValue(whereItems, 'whereItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(whereItems))\r\n                return;\r\n\r\n            let where: SQFilter[] = [];\r\n            for (let i = 0, len = whereItems.length; i < len; i++) {\r\n                let originalWhere = whereItems[i];\r\n\r\n                let updatedWhere: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\r\n                };\r\n\r\n                if (originalWhere.target)\r\n                    updatedWhere.target = _.map(originalWhere.target, e => SQExprRewriterWithSourceRenames.rewrite(e.accept(this.exprRewriter), from));\r\n\r\n                where.push(updatedWhere);\r\n            }\r\n\r\n            return where;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export interface NamedSQExpr {\r\n        name: string;\r\n        expr: SQExpr;\r\n    }\r\n\r\n    export interface SQFilter {\r\n        target?: SQExpr[];\r\n        condition: SQExpr;\r\n    }\r\n\r\n    /** Represents an entity reference in SemanticQuery from. */\r\n    export interface SQFromEntitySource {\r\n        entity: string;\r\n        schema: string;\r\n    }\r\n\r\n    /** Represents a sort over an expression. */\r\n    export interface SQSortDefinition {\r\n        expr: SQExpr;\r\n        direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryFromEnsureEntityResult {\r\n        name: string;\r\n        new?: boolean;\r\n    }\r\n\r\n    export interface SQSourceRenames {\r\n        [from: string]: string;\r\n    }\r\n\r\n    /**\r\n     * Represents a semantic query that is:\r\n     * 1) Round-trippable with a JSON QueryDefinition.\r\n     * 2) Immutable\r\n     * 3) Long-lived and does not have strong references to a conceptual model (only names).\r\n     */\r\n    export class SemanticQuery {\r\n        private static empty: SemanticQuery;\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n        private orderByItems: SQSortDefinition[];\r\n        private selectItems: NamedSQExpr[];\r\n        private groupByItems: NamedSQExpr[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[], orderBy: SQSortDefinition[], select: NamedSQExpr[], groupBy: NamedSQExpr[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(select, 'select');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n            this.orderByItems = orderBy;\r\n            this.selectItems = select;\r\n            this.groupByItems = groupBy;\r\n        }\r\n\r\n        public static create(): SemanticQuery {\r\n            if (!SemanticQuery.empty)\r\n                SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\r\n\r\n            return SemanticQuery.empty;\r\n        }\r\n\r\n        private static createWithTrimmedFrom(\r\n            from: SQFrom,\r\n            where: SQFilter[],\r\n            orderBy: SQSortDefinition[],\r\n            select: NamedSQExpr[],\r\n            groupBy: NamedSQExpr[]): SemanticQuery {\r\n\r\n            let unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\r\n\r\n            // Where\r\n            if (where) {\r\n                for (let i = 0, len = where.length; i < len; i++) {\r\n                    let filter = where[i];\r\n\r\n                    filter.condition.accept(unreferencedKeyFinder);\r\n\r\n                    let filterTarget = filter.target;\r\n                    if (filterTarget) {\r\n                        for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                            if (filterTarget[j])\r\n                                filterTarget[j].accept(unreferencedKeyFinder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // OrderBy\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++)\r\n                    orderBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            // Select\r\n            for (let i = 0, len = select.length; i < len; i++)\r\n                select[i].expr.accept(unreferencedKeyFinder);\r\n\r\n            // GroupBy\r\n            if (groupBy) {\r\n                for (let i = 0, len = groupBy.length; i < len; i++)\r\n                    groupBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            let unreferencedKeys = unreferencedKeyFinder.result();\r\n            for (let i = 0, len = unreferencedKeys.length; i < len; i++)\r\n                from.remove(unreferencedKeys[i]);\r\n\r\n            return new SemanticQuery(from, where, orderBy, select, groupBy);\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        /** Returns a query equivalent to this, with the specified selected items. */\r\n        select(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the items being selected in this query. */\r\n        select(): ArrayNamedItems<NamedSQExpr>;\r\n        public select(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getSelect();\r\n\r\n            return this.setSelect(values);\r\n        }\r\n\r\n        private getSelect(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.selectItems);\r\n        }\r\n\r\n        private static createNamedExpressionArray(items: NamedSQExpr[]): ArrayNamedItems<NamedSQExpr> {\r\n            return ArrayExtensions.extendWithName<NamedSQExpr>(_.map(items, s => {\r\n                return {\r\n                    name: s.name,\r\n                    expr: s.expr,\r\n                };\r\n            }));\r\n        }\r\n\r\n        private setSelect(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private static rewriteExpressionsWithSourceRenames(values: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            let items: NamedSQExpr[] = [];\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n                items.push({\r\n                    name: value.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\r\n                });\r\n            }\r\n\r\n            return items;\r\n        } \r\n\r\n        /** Removes the given expression from the select. */\r\n        public removeSelect(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let originalItems = this.selectItems,\r\n                selectItems: NamedSQExpr[] = [];\r\n            for (let i = 0, len = originalItems.length; i < len; i++) {\r\n                let originalExpr = originalItems[i];\r\n                if (SQExpr.equals(originalExpr.expr, expr))\r\n                    continue;\r\n\r\n                selectItems.push(originalExpr);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Removes the given expression from order by. */\r\n        public removeOrderBy(expr: SQExpr): SemanticQuery {\r\n            let sorts = this.orderBy();\r\n            for (let i = sorts.length - 1; i >= 0; i--) {\r\n                if (SQExpr.equals(sorts[i].expr, expr))\r\n                    sorts.splice(i, 1);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public selectNameOf(expr: SQExpr): string {\r\n            let index = SQExprUtils.indexOfExpr(_.map(this.selectItems, s => s.expr), expr);\r\n            if (index >= 0)\r\n                return this.selectItems[index].name;\r\n        }\r\n\r\n        public setSelectAt(index: number, expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (index >= this.selectItems.length)\r\n                return;\r\n\r\n            let select = this.select(),\r\n                from = this.fromValue.clone(),\r\n                originalName = select[index].name;\r\n            select[index] = {\r\n                name: originalName,\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\r\n        }\r\n\r\n        /** Adds a the expression to the select clause. */\r\n        public addSelect(expr: SQExpr, exprName?: string): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let selectItems = this.select(),\r\n                from = this.fromValue.clone();\r\n            selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private createNamedExpr(currentNames: ArrayNamedItems<NamedSQExpr>, from: SQFrom, expr: SQExpr, exprName?: string): NamedSQExpr{\r\n            return {\r\n                name: SQExprUtils.uniqueName(currentNames, expr, exprName),\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n        } \r\n\r\n        /** Returns a query equivalent to this, with the specified groupBy items. */\r\n        groupBy(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the groupby items in this query. */\r\n        groupBy(): ArrayNamedItems<NamedSQExpr>;\r\n        public groupBy(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getGroupBy();\r\n\r\n            return this.setGroupBy(values);\r\n        }\r\n\r\n        private getGroupBy(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.groupByItems);\r\n        }\r\n\r\n        private setGroupBy(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        public addGroupBy(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let groupByItems = this.groupBy(),\r\n                from = this.fromValue.clone();\r\n            groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the sorting for this query. */\r\n        orderBy(values: SQSortDefinition[]): SemanticQuery;\r\n        orderBy(): SQSortDefinition[];\r\n\r\n        public orderBy(values?: SQSortDefinition[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getOrderBy();\r\n\r\n            return this.setOrderBy(values);\r\n        }\r\n\r\n        private getOrderBy(): SQSortDefinition[] {\r\n            let result: SQSortDefinition[] = [];\r\n\r\n            let orderBy = this.orderByItems;\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++) {\r\n                    let clause = orderBy[i];\r\n\r\n                    result.push({\r\n                        expr: clause.expr,\r\n                        direction: clause.direction,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setOrderBy(values: SQSortDefinition[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedOrderBy: SQSortDefinition[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let clause = values[i];\r\n                updatedOrderBy.push({\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\r\n                    direction: clause.direction,\r\n                });\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the filters for this query. */\r\n        where(values: SQFilter[]): SemanticQuery;\r\n        where(): SQFilter[];\r\n\r\n        public where(values?: SQFilter[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getWhere();\r\n\r\n            return this.setWhere(values);\r\n        }\r\n\r\n        private getWhere(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            if (whereItems) {\r\n                for (let i = 0, len = whereItems.length; i < len; i++)\r\n                    result.push(whereItems[i]);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setWhere(values: SQFilter[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedWhere: SQFilter[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let filter = values[i];\r\n                let updatedFilter: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\r\n                };\r\n\r\n                let filterTarget = filter.target;\r\n                if (filterTarget) {\r\n                    updatedFilter.target = [];\r\n                    for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                        if (filterTarget[j]) {\r\n                            let updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\r\n                            updatedFilter.target.push(updatedTarget);\r\n                        }\r\n                }\r\n\r\n                updatedWhere.push(updatedFilter);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public addWhere(filter: SemanticFilter): SemanticQuery {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedWhere: SQFilter[] = this.where(),\r\n                incomingWhere: SQFilter[] = filter.where(),\r\n                from = this.fromValue.clone();\r\n\r\n            for (let i = 0, len = incomingWhere.length; i < len; i++) {\r\n                let clause = incomingWhere[i];\r\n\r\n                let updatedClause: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\r\n                };\r\n\r\n                if (clause.target)\r\n                    updatedClause.target = _.map(clause.target, t => SQExprRewriterWithSourceRenames.rewrite(t, from));\r\n\r\n                updatedWhere.push(updatedClause);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticQuery {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n            let orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\r\n            let select = rewriter.rewriteSelect(this.selectItems, from);\r\n            let groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\r\n        }\r\n    }\r\n\r\n    /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\r\n    export class SemanticFilter implements ISemanticFilter {\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n        }\r\n\r\n        public static fromSQExpr(contract: SQExpr): SemanticFilter {\r\n            debug.assertValue(contract, 'contract');\r\n\r\n            let from = new SQFrom();\r\n\r\n            let rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\r\n            // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\r\n            //         Thus not setting a target here.\r\n            let where: SQFilter[] = [{\r\n                condition: rewrittenContract\r\n            }];\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static getDefaultValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.defaultValue());\r\n        }\r\n\r\n        public static getAnyValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.anyValue());\r\n        }\r\n\r\n        private static getDataViewScopeIdentityComparisonFilters(fieldSQExprs: SQExpr | SQExpr[], value: SQExpr): SemanticFilter {\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (fieldSQExprs instanceof Array) {\r\n                let values: SQConstantExpr[] = Array.apply(null, Array(fieldSQExprs.length)).map(() => { return value; });\r\n                return SemanticFilter.fromSQExpr(SQExprUtils.getDataViewScopeIdentityComparisonExpr(<SQExpr[]>fieldSQExprs, values));\r\n            }\r\n\r\n            return SemanticFilter.fromSQExpr(SQExprBuilder.equal(<SQExpr>fieldSQExprs, value));\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        public conditions(): SQExpr[] {\r\n            let expressions: SQExpr[] = [];\r\n\r\n            let where = this.whereItems;\r\n            for (let i = 0, len = where.length; i < len; i++) {\r\n                let filter = where[i];\r\n                expressions.push(filter.condition);\r\n            }\r\n            return expressions;\r\n        }\r\n\r\n        public where(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            for (let i = 0, len = whereItems.length; i < len; i++)\r\n                result.push(whereItems[i]);\r\n\r\n            return result;\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticFilter {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.rewrite(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        /** Merges a list of SemanticFilters into one. */\r\n        public static merge(filters: SemanticFilter[]): SemanticFilter {\r\n            if (_.isEmpty(filters))\r\n                return null;\r\n\r\n            if (filters.length === 1)\r\n                return filters[0];\r\n\r\n            let firstFilter = filters[0];\r\n            let from = firstFilter.from(),\r\n                where: SQFilter[] = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\r\n\r\n            for (let i = 1, len = filters.length; i < len; i++)\r\n                SemanticFilter.applyFilter(filters[i], from, where);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static isDefaultFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isDefaultValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isAnyFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isAnyValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isSameFilter(leftFilter: SemanticFilter, rightFilter: SemanticFilter): boolean {\r\n            if (jsCommon.JsonComparer.equals<SemanticFilter>(leftFilter, rightFilter)) {\r\n                return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\r\n                    || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private static applyFilter(filter: SemanticFilter, from: SQFrom, where: SQFilter[]): void {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            // Where\r\n            let filterWhereItems = filter.whereItems;\r\n            for (let i = 0; i < filterWhereItems.length; i++) {\r\n                let filterWhereItem = filterWhereItems[i];\r\n\r\n                let updatedWhereItem: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\r\n                };\r\n\r\n                if (filterWhereItem.target)\r\n                    updatedWhereItem.target = _.map(filterWhereItem.target, e => SQExprRewriterWithSourceRenames.rewrite(e, from));\r\n\r\n                where.push(updatedWhereItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Represents a SemanticQuery/SemanticFilter from clause. */\r\n    export class SQFrom {\r\n        private items: { [name: string]: SQFromEntitySource };\r\n\r\n        constructor(items?: { [name: string]: SQFromEntitySource }) {\r\n            this.items = items || {};\r\n        }\r\n\r\n        public keys(): string[] {\r\n            return Object.keys(this.items);\r\n        }\r\n\r\n        public entity(key: string): SQFromEntitySource {\r\n            return this.items[key];\r\n        }\r\n\r\n        public ensureEntity(entity: SQFromEntitySource, desiredVariableName?: string): QueryFromEnsureEntityResult {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            // 1) Reuse a reference to the entity among the already referenced\r\n            let keys = this.keys();\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let key = keys[i],\r\n                    item = this.items[key];\r\n                if (item && entity.entity === item.entity && entity.schema === item.schema)\r\n                    return { name: key };\r\n            }\r\n\r\n            // 2) Add a reference to the entity\r\n            let candidateName = desiredVariableName || this.candidateName(entity.entity),\r\n                uniqueName: string = candidateName,\r\n                i = 2;\r\n            while (this.items[uniqueName]) {\r\n                uniqueName = candidateName + i++;\r\n            }\r\n\r\n            this.items[uniqueName] = entity;\r\n            return { name: uniqueName, new: true };\r\n        }\r\n\r\n        public remove(key: string): void {\r\n            delete this.items[key];\r\n        }\r\n\r\n        /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\r\n        private candidateName(ref: string): string {\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            let idx = ref.lastIndexOf('.');\r\n            if (idx >= 0 && (idx !== ref.length - 1))\r\n                ref = ref.substr(idx + 1);\r\n\r\n            return ref.substring(0, 1).toLowerCase();\r\n        }\r\n\r\n        public clone(): SQFrom {\r\n            // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\r\n            let cloned = new SQFrom();\r\n\r\n            // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\r\n            $.extend(cloned.items, this.items);\r\n\r\n            return cloned;\r\n        }\r\n    }\r\n\r\n    export class SQExprRewriterWithSourceRenames extends SQExprRewriter {\r\n        private renames: SQSourceRenames;\r\n\r\n        constructor(renames: SQSourceRenames) {\r\n            debug.assertValue(renames, 'renames');\r\n\r\n            super();\r\n            this.renames = renames;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            let updatedName = this.renames[expr.entity];\r\n\r\n            if (updatedName)\r\n                return new SQEntityExpr(expr.schema, expr.entity, updatedName);\r\n\r\n            return super.visitEntity(expr);\r\n        }\r\n\r\n        public rewriteFilter(filter: SQFilter): SQFilter {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedTargets = undefined;\r\n            if (filter.target)\r\n                updatedTargets = this.rewriteArray(filter.target);\r\n\r\n            let updatedCondition = filter.condition.accept(this);\r\n\r\n            if (filter.condition === updatedCondition && filter.target === updatedTargets)\r\n                return filter;\r\n\r\n            let updatedFilter: SQFilter = {\r\n                condition: updatedCondition,\r\n            };\r\n\r\n            if (updatedTargets)\r\n                updatedFilter.target = updatedTargets;\r\n\r\n            return updatedFilter;\r\n        }\r\n\r\n        public rewriteArray(exprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(exprs, 'exprs');\r\n\r\n            let updatedExprs: SQExpr[];\r\n\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i],\r\n                    rewrittenExpr = expr.accept(this);\r\n\r\n                if (expr !== rewrittenExpr && !updatedExprs)\r\n                    updatedExprs = ArrayExtensions.take(exprs, i);\r\n\r\n                if (updatedExprs)\r\n                    updatedExprs.push(rewrittenExpr);\r\n            }\r\n\r\n            return updatedExprs || exprs;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, from: SQFrom): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(from, 'from');\r\n\r\n            let renames = QuerySourceRenameDetector.run(expr, from);\r\n            let rewriter = new SQExprRewriterWithSourceRenames(renames);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    /** Responsible for updating a QueryFrom based on SQExpr references. */\r\n    class QuerySourceRenameDetector extends DefaultSQExprVisitorWithTraversal {\r\n        private from: SQFrom;\r\n        private renames: SQSourceRenames;\r\n\r\n        public static run(expr: SQExpr, from: SQFrom): SQSourceRenames {\r\n            let detector = new QuerySourceRenameDetector(from);\r\n            expr.accept(detector);\r\n\r\n            return detector.renames;\r\n        }\r\n\r\n        constructor(from: SQFrom) {\r\n            debug.assertValue(from, 'from');\r\n            super();\r\n\r\n            this.from = from;\r\n            this.renames = {};\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            // TODO: Renames must take the schema into account, not just entity set name.\r\n            let existingEntity = this.from.entity(expr.variable);\r\n            if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\r\n                return;\r\n\r\n            let actualEntity = this.from.ensureEntity(\r\n                {\r\n                    schema: expr.schema,\r\n                    entity: expr.entity,\r\n                },\r\n                expr.variable);\r\n\r\n            this.renames[expr.entity] = actualEntity.name;\r\n        }\r\n    }\r\n\r\n    /** Visitor for finding unreferenced sources. */\r\n    class UnreferencedKeyFinder extends DefaultSQExprVisitorWithTraversal {\r\n        private keys: string[];\r\n\r\n        constructor(keys: string[]) {\r\n            debug.assertValue(keys, 'keys');\r\n\r\n            super();\r\n            this.keys = keys;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            let index = this.keys.indexOf(expr.variable);\r\n            if (index >= 0)\r\n                this.keys.splice(index, 1);\r\n        }\r\n\r\n        public result(): string[] {\r\n            return this.keys;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataViewTransform = powerbi.data.DataViewTransform;\r\n    import SQExprBuilder = powerbi.data.SQExprBuilder;\r\n\r\n    /** Utility for creating a DataView from columns of data. */\r\n    export interface IDataViewBuilderCategorical {\r\n        withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical;\r\n        withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical;\r\n        withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical;\r\n        withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical;\r\n\r\n        build(): DataView;\r\n    }\r\n\r\n    export interface DataViewBuilderColumnOptions {\r\n        source: DataViewMetadataColumn;\r\n    }\r\n\r\n    export interface DataViewBuilderCategoryColumnOptions extends DataViewBuilderColumnOptions {\r\n        values: PrimitiveValue[];\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n    }\r\n\r\n    export interface DataViewBuilderValuesOptions {\r\n        columns: DataViewBuilderValuesColumnOptions[];\r\n    }\r\n\r\n    export interface DataViewBuilderGroupedValuesOptions {\r\n        groupColumn: DataViewBuilderCategoryColumnOptions;\r\n        valueColumns: DataViewBuilderColumnOptions[];\r\n        data: DataViewBuilderSeriesData[][];\r\n    }\r\n\r\n    /** Indicates the source set of identities. */\r\n    export interface DataViewBuilderColumnIdentitySource {\r\n        fields: SQExpr[];\r\n        identities?: DataViewScopeIdentity[];\r\n    }\r\n\r\n    export interface DataViewBuilderValuesColumnOptions extends DataViewBuilderColumnOptions, DataViewBuilderSeriesData {\r\n    }\r\n\r\n    export interface DataViewBuilderSeriesData {\r\n        values: PrimitiveValue[];\r\n        highlights?: PrimitiveValue[];\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        maxLocal?: any;\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        minLocal?: any;\r\n    }\r\n\r\n    export function createCategoricalDataViewBuilder(): IDataViewBuilderCategorical {\r\n        return new CategoricalDataViewBuilder();\r\n    }\r\n\r\n    interface ColumnMetadata {\r\n        column: DataViewMetadataColumn;\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n        values: PrimitiveValue[];\r\n    }\r\n\r\n    class CategoricalDataViewBuilder implements IDataViewBuilderCategorical {\r\n        private categories: DataViewCategoryColumn[];\r\n        private staticMeasureColumns: DataViewMetadataColumn[];\r\n        private dynamicMeasureColumns: DataViewMetadataColumn[];\r\n        private dynamicSeriesMetadata: ColumnMetadata;\r\n        private columnIndex: number;\r\n        private staticSeriesValues: DataViewBuilderValuesColumnOptions[];\r\n        private dynamicSeriesValues: DataViewBuilderSeriesData[][];\r\n\r\n        constructor() {\r\n            this.categories = [];\r\n            this.staticMeasureColumns = [];\r\n            this.dynamicMeasureColumns = [];\r\n            this.columnIndex = 0;\r\n        }\r\n\r\n        public withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical {\r\n            let categoryValues = options.values,\r\n                identityFrom = options.identityFrom,\r\n                type = options.source.type;\r\n\r\n            let categoryColumn: DataViewCategoryColumn = {\r\n                source: options.source,\r\n                identityFields: options.identityFrom.fields,\r\n                identity: options.identityFrom.identities || [],\r\n                values: categoryValues,\r\n            };\r\n\r\n            if (!options.identityFrom.identities) {\r\n                for (let categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\r\n                    categoryColumn.identity.push(\r\n                        getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\r\n                }\r\n            }\r\n\r\n            if (!this.categories)\r\n                this.categories = [];\r\n\r\n            this.categories.push(categoryColumn);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical {\r\n            if (_.isEmpty(this.categories))\r\n                this.categories = categories;\r\n            else\r\n                Array.prototype.push.apply(this.categories, categories);\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Adds static series columns.\r\n         *\r\n         * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in \r\n         * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\r\n         */\r\n        public withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let columns = options.columns;\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            for (let column of columns) {\r\n                this.staticMeasureColumns.push(column.source);\r\n            }\r\n\r\n            this.staticSeriesValues = columns;\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Adds dynamic series columns.\r\n         *\r\n         * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in \r\n         * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\r\n         */\r\n        public withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let groupColumn = options.groupColumn;\r\n            debug.assertValue(groupColumn, 'groupColumn');\r\n\r\n            this.dynamicSeriesMetadata = {\r\n                column: groupColumn.source,\r\n                identityFrom: groupColumn.identityFrom,\r\n                values: groupColumn.values,\r\n            };\r\n\r\n            let valueColumns = options.valueColumns;\r\n            for (let valueColumn of valueColumns) {\r\n                this.dynamicMeasureColumns.push(valueColumn.source);\r\n            }\r\n\r\n            this.dynamicSeriesValues = options.data;\r\n\r\n            return this;\r\n        }\r\n\r\n        private fillData(dataViewValues: DataViewValueColumns) {\r\n            let categoryColumn = _.first(this.categories);\r\n            let categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 0;\r\n\r\n            if (this.hasDynamicSeries()) {\r\n                for (let seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\r\n                    let seriesMeasures = this.dynamicSeriesValues[seriesIndex];\r\n                    debug.assert(seriesMeasures.length === this.dynamicMeasureColumns.length, 'seriesMeasures.length === this.dynamicMeasureColumns.length');\r\n\r\n                    for (let measureIndex = 0, measuresLen = this.dynamicMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                        let groupIndex = seriesIndex * measuresLen + measureIndex;\r\n\r\n                        applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.hasStaticSeries()) {\r\n                // Note: when the target categorical has both dynamic and static series, append static measures at the end of the values array.\r\n                let staticColumnsStartingIndex = this.hasDynamicSeries() ? (this.dynamicSeriesValues.length * this.dynamicMeasureColumns.length) : 0;\r\n\r\n                for (let measureIndex = 0, measuresLen = this.staticMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                    applySeriesData(dataViewValues[staticColumnsStartingIndex + measureIndex], this.staticSeriesValues[measureIndex], categoryLength);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the DataView with metadata and DataViewCategorical.\r\n         * Returns undefined if the combination of parameters is illegal, such as having both dynamic series and static series when building a visual DataView.\r\n         */\r\n        public build(): DataView {\r\n            let metadataColumns: DataViewMetadataColumn[] = [];\r\n            let categorical: DataViewCategorical = {};\r\n\r\n            let categoryMetadata = this.categories;\r\n            let dynamicSeriesMetadata = this.dynamicSeriesMetadata;\r\n\r\n            // --- Build metadata columns and value groups ---\r\n            for (let columnMetadata of categoryMetadata) {\r\n                pushIfNotExists(metadataColumns, columnMetadata.source);\r\n            }\r\n\r\n            if (this.hasDynamicSeries()) {\r\n                // Dynamic series, or Dyanmic & Static series.\r\n                pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\r\n\r\n                categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\r\n\r\n                // For each series value we will make one column per measure\r\n                let seriesValues = dynamicSeriesMetadata.values;\r\n                for (let seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\r\n                    let seriesValue = seriesValues[seriesIndex];\r\n                    let seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\r\n\r\n                    for (let measure of this.dynamicMeasureColumns) {\r\n                        let column = _.clone(measure);\r\n                        column.groupName = <string>seriesValue;\r\n\r\n                        pushIfNotExists(metadataColumns, column);\r\n                        categorical.values.push({\r\n                            source: column,\r\n                            values: [],\r\n                            identity: seriesIdentity,\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (this.hasStaticSeries()) {\r\n                    // IMPORTANT: In the Dyanmic & Static series case, the groups array shall not include any static group. This is to match the behavior of production code that creates query DataView objects.\r\n                    // Get the current return value of grouped() before adding static measure columns, an use that as the return value of this categorical.\r\n                    // Otherwise, the default behavior of DataViewValueColumns.grouped() from DataViewTransform.createValueColumns() is to create series groups from all measure columns.\r\n                    let dynamicSeriesGroups = categorical.values.grouped();\r\n                    categorical.values.grouped = () => dynamicSeriesGroups;\r\n\r\n                    this.appendStaticMeasureColumns(metadataColumns, categorical.values);\r\n                }\r\n            }\r\n            else {\r\n                // Static series only / no series\r\n                categorical.values = DataViewTransform.createValueColumns();\r\n                this.appendStaticMeasureColumns(metadataColumns, categorical.values);\r\n            }\r\n\r\n            let categories = this.categories;\r\n            if (!_.isEmpty(categories))\r\n                categorical.categories = categories;\r\n\r\n            // --- Fill in data point values ---\r\n            this.fillData(categorical.values);\r\n\r\n            let dataView: DataView = {\r\n                metadata: {\r\n                    columns: metadataColumns,\r\n                },\r\n                categorical: categorical,\r\n            };\r\n\r\n            if (this.isLegalDataView(dataView)) {\r\n                return dataView;\r\n            }\r\n        }\r\n\r\n        private appendStaticMeasureColumns(metadataColumns: DataViewMetadataColumn[], valueColumns: DataViewValueColumns): void {\r\n            debug.assertValue(metadataColumns, 'metadataColumns');\r\n            debug.assertValue(valueColumns, 'valueColumns');\r\n\r\n            if (!_.isEmpty(this.staticMeasureColumns)) {\r\n                for (let column of this.staticMeasureColumns) {\r\n                    pushIfNotExists(metadataColumns, column);\r\n                    valueColumns.push({\r\n                        source: column,\r\n                        values: [],\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        private isLegalDataView(dataView: DataView): boolean {\r\n            if (this.hasDynamicSeries() && this.hasStaticSeries() && CategoricalDataViewBuilder.isVisualDataView(dataView.metadata.columns)) {\r\n                // It is illegal to have both dynamic series and static series in a visual DataViewCategorical,\r\n                // because the DataViewValueColumns interface today cannot express that 100% (see its 'source' property and return value of its 'grouped()' function).\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * This function infers that if any metadata column has 'queryName', \r\n         * then the user of this builder is building a visual DataView (as opposed to query DataView).\r\n         *\r\n         * @param metadataColumns The complete collection of metadata columns in the categorical.\r\n         */\r\n        private static isVisualDataView(metadataColumns: DataViewMetadataColumn[]): boolean {\r\n            return !_.isEmpty(metadataColumns) &&\r\n                _.any(metadataColumns, (metadataColumn) => !!metadataColumn.queryName);\r\n        }\r\n\r\n        private hasDynamicSeries(): boolean {\r\n            return !!this.dynamicSeriesMetadata; // In Map visual scenarios, you can have dynamic series without measure columns\r\n        }\r\n\r\n        private hasStaticSeries(): boolean {\r\n            return !!this.staticSeriesValues;\r\n        }\r\n    }\r\n\r\n    function getScopeIdentity(\r\n        source: DataViewBuilderColumnIdentitySource,\r\n        index: number,\r\n        value: PrimitiveValue,\r\n        valueType: ValueTypeDescriptor): DataViewScopeIdentity {\r\n        let identities = source.identities;\r\n        if (identities) {\r\n            return identities[index];\r\n        }\r\n\r\n        debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\r\n\r\n        return createDataViewScopeIdentity(\r\n            SQExprBuilder.equal(\r\n                source.fields[0],\r\n                SQExprBuilder.typedConstant(value, valueType)));\r\n    }\r\n\r\n    function pushIfNotExists(items: DataViewMetadataColumn[], itemToAdd: DataViewMetadataColumn): void {\r\n        if (_.contains(items, itemToAdd))\r\n            return;\r\n\r\n        items.push(itemToAdd);\r\n    }\r\n\r\n    function applySeriesData(target: DataViewValueColumn, source: DataViewBuilderSeriesData, categoryLength: number): void {\r\n        debug.assertValue(target, 'target');\r\n        debug.assertValue(source, 'source');\r\n        debug.assertValue(categoryLength, 'categoryLength');\r\n\r\n        let values = source.values;\r\n        debug.assert(categoryLength === values.length || categoryLength === 0, 'categoryLength === values.length || categoryLength === 0');\r\n\r\n        target.values = values;\r\n\r\n        let highlights = source.highlights;\r\n        if (highlights) {\r\n            debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\r\n\r\n            target.highlights = highlights;\r\n        }\r\n\r\n        let aggregates: DataViewColumnAggregates;\r\n        if (source.minLocal !== undefined) {\r\n            if (!aggregates)\r\n                aggregates = {};\r\n\r\n            aggregates.minLocal = source.minLocal;\r\n        }\r\n\r\n        if (source.maxLocal !== undefined) {\r\n            if (!aggregates)\r\n                aggregates = {};\r\n\r\n            aggregates.maxLocal = source.maxLocal;\r\n        }\r\n\r\n        if (aggregates) {\r\n            target.source.aggregates = aggregates;\r\n            _.extend(target, aggregates);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export function createStaticEvalContext(colorAllocatorCache?: IColorAllocatorCache): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView?: DataView, selectTransforms?: DataViewSelectTransform[]): IEvalContext {\r\n        return new StaticEvalContext(\r\n            colorAllocatorCache || createColorAllocatorCache(),\r\n            dataView || { metadata: { columns: [] } },\r\n            selectTransforms);\r\n    }\r\n\r\n    /**\r\n     * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\r\n     * are supported.\r\n     */\r\n    class StaticEvalContext implements IEvalContext {\r\n        private colorAllocatorCache: IColorAllocatorCache;\r\n        private dataView: DataView;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorCache = colorAllocatorCache;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorCache.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            let dataView = this.dataView,\r\n                selectTransforms = this.selectTransforms;\r\n\r\n            if (!dataView || !selectTransforms)\r\n                return;\r\n\r\n            if (SQExpr.isAggregation(expr)) {\r\n                let columnAggregate = findAggregateValue(expr, selectTransforms, dataView.metadata.columns);\r\n                if (columnAggregate !== undefined) {\r\n                    return columnAggregate;\r\n                }\r\n            }\r\n\r\n            if (dataView.table)\r\n                return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n    }\r\n\r\n    export function getExprValueFromTable(expr: SQExpr, selectTransforms: DataViewSelectTransform[], table: DataViewTable, rowIdx: number): PrimitiveValue {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n        debug.assertValue(table, 'table');\r\n        debug.assertValue(rowIdx, 'rowIdx');\r\n\r\n        let rows = table.rows;\r\n        if (_.isEmpty(rows) || rows.length <= rowIdx)\r\n            return;\r\n\r\n        let cols = table.columns;\r\n\r\n        let selectIdx = findSelectIndex(expr, selectTransforms);\r\n        if (selectIdx < 0)\r\n            return;\r\n\r\n        for (let colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\r\n            if (selectIdx !== cols[colIdx].index)\r\n                continue;\r\n\r\n            return rows[rowIdx][colIdx];\r\n        }\r\n    }\r\n\r\n    function findAggregateValue(expr: SQAggregationExpr, selectTransforms: DataViewSelectTransform[], columns: DataViewMetadataColumn[]): PrimitiveValue {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n        debug.assertValue(columns, 'columns');\r\n\r\n        let selectIdx = findSelectIndex(expr.arg, selectTransforms);\r\n        if (selectIdx < 0)\r\n            return;\r\n\r\n        for (let colIdx = 0, colLen = columns.length; colIdx < colLen; colIdx++) {\r\n            let column = columns[colIdx],\r\n                columnAggr = column.aggregates;\r\n\r\n            if (selectIdx !== column.index || !columnAggr)\r\n                continue;\r\n\r\n            let aggregateValue = findAggregates(columnAggr, expr.func);\r\n            if (aggregateValue !== undefined)\r\n                return aggregateValue;\r\n        }\r\n    }\r\n\r\n    function findSelectIndex(expr: SQExpr, selectTransforms: DataViewSelectTransform[]): number {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n        let queryName: string;\r\n        if (SQExpr.isSelectRef(expr))\r\n            queryName = expr.expressionName;\r\n\r\n        for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n            let selectTransform = selectTransforms[selectIdx];\r\n\r\n            if (!selectTransform || !selectTransform.queryName)\r\n                continue;\r\n\r\n            if (queryName) {\r\n                if (selectTransform.queryName === queryName)\r\n                    return selectIdx;\r\n            }\r\n            else {\r\n                if (SQExpr.equals(selectTransform.expr, expr))\r\n                    return selectIdx;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function findAggregates(aggregates: DataViewColumnAggregates, func: QueryAggregateFunction): PrimitiveValue {\r\n        debug.assertValue(aggregates, 'aggregates');\r\n        debug.assertValue(func, 'func');\r\n\r\n        switch (func) {\r\n            case QueryAggregateFunction.Min:\r\n                return getOptional(aggregates.min, aggregates.minLocal);\r\n            case QueryAggregateFunction.Max:\r\n                return getOptional(aggregates.max, aggregates.maxLocal);\r\n        }\r\n    }\r\n\r\n    function getOptional(value1: PrimitiveValue, value2: PrimitiveValue): PrimitiveValue {\r\n        debug.assertAnyValue(value1, 'value1');\r\n        debug.assertAnyValue(value2, 'value2');\r\n\r\n        if (value1 !== undefined)\r\n            return value1;\r\n\r\n        return value2;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export function createMatrixEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewMatrix: DataViewMatrix): IEvalContext {\r\n        // NOTE: Matrix context-sensitive evaluation is not yet implemented.\r\n        return createStaticEvalContext(colorAllocatorProvider);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import Formatting = jsCommon.Formatting;\r\n    import RegExpExtensions = jsCommon.RegExpExtensions;\r\n\r\n    /** Culture interfaces. These match the Globalize library interfaces intentionally. */\r\n    export interface Culture {\r\n        name: string;\r\n        calendar: Calendar;\r\n        calendars: CalendarDictionary;\r\n        numberFormat: NumberFormatInfo;\r\n    }\r\n\r\n    export interface Calendar {\r\n        patterns: any;\r\n        firstDay: number;\r\n    }\r\n\r\n    export interface CalendarDictionary {\r\n        [key: string]: Calendar;\r\n    }\r\n\r\n    export interface NumberFormatInfo {\r\n        decimals: number;\r\n        groupSizes: number[];\r\n        negativeInfinity: string;\r\n        positiveInfinity: string;\r\n    }\r\n\r\n    /**\r\n     *  Creating a dummy module to declare cultureInfo string, so we could do a strongly typed usage in Visuals\r\n     */\r\n    declare module powerbi.common {\r\n        let cultureInfo: string;\r\n    }\r\n\r\n    /** Formatting Encoder */\r\n    module FormattingEncoder {\r\n        export function preserveEscaped(format: string, specialChars: string): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = \"\\\\\" + specialChars[i];\r\n                let newText = String.fromCharCode(0xE000 + i);\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreEscaped(format: string, specialChars: string): string {\r\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = String.fromCharCode(0xE000 + i);\r\n                let newText = specialChars[i];\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\r\n        }\r\n\r\n        export function preserveLiterals(format: string, literals: string[]): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            for (let i = 0; ; i++) {\r\n                let fromIndex = format.indexOf(\"'\");\r\n                if (fromIndex < 0) {\r\n                    break;\r\n                }\r\n                let toIndex = format.indexOf(\"'\", fromIndex + 1);\r\n                if (toIndex < 0) {\r\n                    break;\r\n                }\r\n                let literal = format.substring(fromIndex, toIndex + 1);\r\n                literals.push(literal.substring(1, toIndex - fromIndex));\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                format = format.replace(literal, token);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreLiterals(format: string, literals: string[]): string {\r\n            let count = literals.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                let literal = literals[i];\r\n                format = format.replace(token, literal);\r\n            }\r\n            return format;\r\n        }\r\n    }\r\n\r\n    const IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\r\n    const ZeroPlaceholder = '0';\r\n    const DigitPlaceholder = '#';\r\n    const ExponentialFormatChar = 'E';\r\n    const NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\r\n    const NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\r\n\r\n    /** Formatting Service */\r\n    class FormattingService implements IFormattingService {\r\n\r\n        _currentCultureSelector: string;\r\n        _currentCulture: Culture;\r\n        _dateTimeScaleFormatInfo: DateTimeScaleFormatInfo;\r\n\r\n        public formatValue(value: any, format?: string, culture?: string): string {\r\n            // Handle special cases\r\n            if (value === undefined || value === null) {\r\n                return '';\r\n            }\r\n            let gculture = this.getCulture(culture);\r\n\r\n            if (DateTimeFormat.canFormat(value)) {\r\n                // Dates\r\n                return DateTimeFormat.format(value, format, gculture);\r\n            } else if (NumberFormat.canFormat(value)) {\r\n                // Numbers\r\n                return NumberFormat.format(value, format, gculture);\r\n            } else {\r\n                // Other data types - return as string\r\n                return value.toString();\r\n            }\r\n        }\r\n\r\n        public format(formatWithIndexedTokens: string, args: any[], culture?: string): string {\r\n            if (!formatWithIndexedTokens) {\r\n                return \"\";\r\n            }\r\n            let result = formatWithIndexedTokens.replace(IndexedTokensRegex, (match: string, left: string, right: string, argToken: string) => {\r\n                if (left) {\r\n                    return \"{\";\r\n                } else if (right) {\r\n                    return \"}\";\r\n                } else {\r\n                    let parts = argToken.split(\":\");\r\n                    let argIndex = parseInt(parts[0], 10);\r\n                    let argFormat = parts[1];\r\n                    return this.formatValue(args[argIndex], argFormat, culture);\r\n                }\r\n            });\r\n\r\n            return result;\r\n        }\r\n\r\n        public isStandardNumberFormat(format: string): boolean {\r\n            return NumberFormat.isStandardFormat(format);\r\n        }\r\n\r\n        public formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string, culture?: string): string {\r\n            let gculture = this.getCulture(culture);\r\n\r\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\r\n        }\r\n\r\n        public dateFormatString(unit: DateTimeUnit): string {\r\n            if (!this._dateTimeScaleFormatInfo)\r\n                this.initialize();\r\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\r\n        }\r\n\r\n        /**\r\n         * Sets the current localization culture\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         */\r\n        private setCurrentCulture(cultureSelector: string): void {\r\n            if (this._currentCultureSelector !== cultureSelector) {\r\n                this._currentCulture = this.getCulture(cultureSelector);\r\n                this._currentCultureSelector = cultureSelector;\r\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         * Exposing this function for testability of unsupported cultures\r\n         */\r\n        public getCulture(cultureSelector?: string): Culture {\r\n            if (cultureSelector == null) {\r\n                if (this._currentCulture == null) {\r\n                    this.initialize();\r\n                }\r\n                return this._currentCulture;\r\n            } else {\r\n                let culture = Globalize.findClosestCulture(cultureSelector);\r\n                if (!culture)\r\n                    culture = Globalize.culture(\"en-US\");\r\n                return culture;\r\n            }\r\n        }\r\n\r\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\r\n        private initialize() {\r\n            let cultureName = this.getCurrentCulture();\r\n            this.setCurrentCulture(cultureName);\r\n            let calendarName = this.getUrlParam(\"calendar\");\r\n            if (calendarName) {\r\n                let culture = this._currentCulture;\r\n                let c = culture.calendars[calendarName];\r\n                if (c) {\r\n                    culture.calendar = c;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability \r\n         */\r\n        public getCurrentCulture(): string {\r\n            let urlParam = this.getUrlParam(\"language\");\r\n\r\n            if (urlParam) {\r\n                return urlParam;\r\n            }\r\n\r\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\r\n                // Get cultureInfo set in powerbi\r\n                return powerbi.common.cultureInfo;\r\n            }\r\n\r\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability\r\n         *  @param name: queryString name\r\n         */\r\n        public getUrlParam(name: string): string {\r\n            let param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\r\n            return param ? param[1] : undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for dates.\r\n     */\r\n    module DateTimeFormat {\r\n\r\n        let _currentCachedFormat: string;\r\n        let _currentCachedProcessedFormat: string;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = value instanceof Date;\r\n            return result;\r\n        }\r\n\r\n        /** Formats the date using provided format and culture */\r\n        export function format(value: Date, format: string, culture: Culture): string {\r\n            format = format || \"G\";\r\n            let isStandard = format.length === 1;\r\n            try {\r\n                if (isStandard) {\r\n                    return formatDateStandard(value, format, culture);\r\n                } else {\r\n                    return formatDateCustom(value, format, culture);\r\n                }\r\n            } catch (e) {\r\n                return formatDateStandard(value, \"G\", culture);\r\n            }\r\n        }\r\n\r\n        /** Formats the date using standard format expression */\r\n        function formatDateStandard(value: Date, format: string, culture: Culture) {\r\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\r\n            let patterns = culture.calendar.patterns;\r\n            // Extend supported set of patterns\r\n            ensurePatterns(culture.calendar);\r\n            // Handle extended set of formats\r\n            let output = Formatting.findDateFormat(value, format, culture.name);\r\n            if (output.format.length === 1)\r\n                format = patterns[output.format];\r\n            else\r\n                format = output.format;\r\n            //need to revisit when globalization is enabled\r\n            culture = Globalize.culture(\"en-US\");\r\n            return Globalize.format(output.value, format, culture);\r\n        }\r\n\r\n        /** Formats the date using custom format expression */\r\n        function formatDateCustom(value: Date, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let literals: string[] = [];\r\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            format = FormattingEncoder.preserveLiterals(format, literals);\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            if (format.indexOf(\"F\") > -1) {\r\n                // F is not supported so we need to replace the F with f based on the milliseconds\r\n                // Replace all sequences of F longer than 3 with \"FFF\"\r\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\r\n                // Based on milliseconds update the format to use fff\r\n                let milliseconds = value.getMilliseconds();\r\n                if (milliseconds % 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\r\n                if ((milliseconds % 100) / 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\r\n                if ((milliseconds % 1000) / 100 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\r\n                if (format === \"\" || format === \"%\")\r\n                    return \"\";\r\n            }\r\n            format = processCustomDateTimeFormat(format);\r\n            result = Globalize.format(value, format, culture);\r\n            result = localize(result, culture.calendar);\r\n            result = FormattingEncoder.restoreLiterals(result, literals);\r\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            return result;\r\n        }\r\n\r\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\r\n        function processCustomDateTimeFormat(format: string): string {\r\n            if (format === _currentCachedFormat) {\r\n                return _currentCachedProcessedFormat;\r\n            }\r\n            _currentCachedFormat = format;\r\n            format = Formatting.fixDateTimeFormat(format);\r\n            _currentCachedProcessedFormat = format;\r\n            return format;\r\n        }\r\n\r\n        /** Localizes the time separator symbol */\r\n        function localize(value: string, dictionary: any): string {\r\n            let timeSeparator = dictionary[\":\"];\r\n            if (timeSeparator === \":\") {\r\n                return value;\r\n            }\r\n            let result = \"\";\r\n            let count = value.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \":\":\r\n                        result += timeSeparator;\r\n                        break;\r\n                    default:\r\n                        result += char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function ensurePatterns(calendar: GlobalizeCalendar) {\r\n            let patterns = calendar.patterns;\r\n            if (patterns[\"g\"] === undefined) {\r\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, short time\r\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, long time\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * NumberFormat module contains the static methods for formatting the numbers.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for numeric types including custom formats.\r\n     */\r\n    export module NumberFormat {\r\n\r\n        const NonScientificFormatRegex = /^\\{.+\\}.*/;\r\n        const NumericalPlaceHolderRegex = /\\{.+\\}/;\r\n        const ScientificFormatRegex = /e[+-]*[0#]+/i;\r\n        const StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\r\n        const TrailingZerosRegex = /0+$/;\r\n        const DecimalFormatRegex = /\\.([0#]*)/g;\r\n        const NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\r\n        const LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\r\n        const DecimalFormatCharacter = '.';\r\n\r\n        export const NumberFormatComponentsDelimeter = ';';\r\n\r\n        export interface NumericFormatMetadata {\r\n            format: string;\r\n            hasEscapes: boolean;\r\n            hasQuotes: boolean;\r\n            hasE: boolean;\r\n            hasCommas: boolean;\r\n            hasDots: boolean;\r\n            hasPercent: boolean;\r\n            hasPermile: boolean;\r\n            precision: number;\r\n            scale: number;\r\n        }\r\n\r\n        export interface NumberFormatComponents {\r\n            hasNegative: boolean;\r\n            positive: string;\r\n            negative: string;\r\n            zero: string;\r\n        }\r\n\r\n        function getNonScientificFormatWithPrecision(baseFormat: string, numericFormat: string): string {\r\n            if (!numericFormat || baseFormat === undefined)\r\n                return baseFormat;\r\n\r\n            let newFormat = \"{0:\" + numericFormat + \"}\";\r\n\r\n            return baseFormat.replace(\"{0}\", newFormat);\r\n        }\r\n\r\n        export function getNumericFormat(value: number, baseFormat: string): string {\r\n            if (baseFormat == null)\r\n                return baseFormat;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n\r\n                if (value > 0)\r\n                    return getNumericFormatFromComponent(value, positive);\r\n                else if (value === 0)\r\n                    return getNumericFormatFromComponent(value, zero);\r\n\r\n                return getNumericFormatFromComponent(value, negative);\r\n            }\r\n\r\n            return getNumericFormatFromComponent(value, baseFormat);\r\n        }\r\n\r\n        function getNumericFormatFromComponent(value: number, format: string): string {\r\n            let match = RegExpExtensions.run(NumericFormatRegex, format);\r\n            if (match)\r\n                return match[0];\r\n\r\n            return format;\r\n        }\r\n\r\n        export function addDecimalsToFormat(baseFormat: string, decimals: number, trailingZeros: boolean): string {\r\n            if (decimals == null)\r\n                return baseFormat;\r\n\r\n            // Default format string\r\n            if (baseFormat == null)\r\n                baseFormat = ZeroPlaceholder;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n                let formats = [positive, negative, zero];\r\n                for (let i = 0; i < formats.length; i++) {\r\n                    // Update format in formats array\r\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\r\n                }\r\n\r\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\r\n            }\r\n\r\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\r\n        }\r\n\r\n        function addDecimalsToFormatComponent(format: string, decimals: number, trailingZeros: boolean): string {\r\n            decimals = Math.abs(decimals);\r\n\r\n            if (decimals >= 0) {\r\n                let placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\r\n                let decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\r\n\r\n                let match = RegExpExtensions.run(DecimalFormatRegex, format);\r\n                if (match) {\r\n                    let beforeDecimal = format.substr(0, match.index);\r\n                    let formatDecimal = format.substr(match.index + 1, match[1].length);\r\n                    let afterDecimal = format.substr(match.index + match[0].length);\r\n\r\n                    if (trailingZeros)\r\n                        // Use explicit decimals argument as placeholders\r\n                        formatDecimal = decimalPlaceholders;\r\n                    else {\r\n                        let decimalChange = decimalPlaceholders.length - formatDecimal.length;\r\n                        if (decimalChange > 0)\r\n                            // Append decimalPlaceholders to existing decimal portion of format string\r\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\r\n                        else if (decimalChange < 0)\r\n                            // Remove decimals from formatDecimal\r\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\r\n                    }\r\n\r\n                    if (formatDecimal.length > 0)\r\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\r\n\r\n                    return beforeDecimal + formatDecimal + afterDecimal;\r\n                }\r\n                else if (decimalPlaceholders.length > 0)\r\n                    // Replace last numeric placeholder with decimal portion\r\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\r\n            }\r\n\r\n            return format;\r\n        }\r\n\r\n        export function hasFormatComponents(format: string): boolean {\r\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\r\n        }\r\n\r\n        export function getComponents(format: string): NumberFormatComponents {\r\n            let signFormat: NumberFormatComponents = {\r\n                hasNegative: false,\r\n                positive: format,\r\n                negative: format,\r\n                zero: format,\r\n            };\r\n\r\n            let signSpecificFormats = format.split(NumberFormatComponentsDelimeter);\r\n            let formatCount = signSpecificFormats.length;\r\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\r\n\r\n            if (formatCount > 1) {\r\n                signFormat.hasNegative = true;\r\n\r\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\r\n                signFormat.negative = signSpecificFormats[1];\r\n\r\n                if (formatCount > 2)\r\n                    signFormat.zero = signSpecificFormats[2];\r\n            }\r\n\r\n            return signFormat;\r\n        }\r\n\r\n        let _lastCustomFormatMeta: NumericFormatMetadata;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = typeof (value) === \"number\";\r\n            return result;\r\n        }\r\n\r\n        export function isStandardFormat(format: string): boolean {\r\n            debug.assertValue(format, 'format');\r\n            return StandardFormatRegex.test(format);\r\n        }\r\n\r\n        /** Formats the number using specified format expression and culture */\r\n        export function format(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture): string {\r\n            format = format || \"G\";\r\n            try {\r\n                if (isStandardFormat(format))\r\n                    return formatNumberStandard(value, format, culture);\r\n\r\n                return formatNumberCustom(value, format, culture);\r\n            } catch (e) {\r\n                return Globalize.format(value, undefined, culture);\r\n            }\r\n        }\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        export function formatWithCustomOverride(\r\n            value: number,\r\n            format: string,\r\n            nonScientificOverrideFormat: string,\r\n            culture: Culture): string {\r\n            debug.assertValue(value, 'value');\r\n            debug.assertValue(format, 'format');\r\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\r\n            debug.assertValue(culture, 'culture');\r\n            debug.assert(!isStandardFormat(format), 'Standard format');\r\n\r\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\r\n        }\r\n\r\n        /** Formats the number using standard format expression */\r\n        function formatNumberStandard(value: number, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let precision = <number>(format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\r\n            let numberFormatInfo = culture.numberFormat;\r\n            let formatChar = format.charAt(0);\r\n            switch (formatChar) {\r\n                case \"e\":\r\n                case \"E\":\r\n                    if (precision === undefined) {\r\n                        precision = 6;\r\n                    }\r\n                    let mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\r\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\r\n                    result = formatNumberCustom(value, format, culture);\r\n                    break;\r\n                case \"f\":\r\n                case \"F\":\r\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    let abs = Math.abs(value);\r\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\r\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\r\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\r\n                    } else {\r\n                        // Otherwise use exponential\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\r\n                        result = result.replace(\"e\", \"E\");\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"r\":\r\n                case \"R\":\r\n                    result = value.toString();\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"x\":\r\n                case \"X\":\r\n                    result = value.toString(16);\r\n                    if (formatChar === \"X\") {\r\n                        result = result.toUpperCase();\r\n                    }\r\n                    if (precision !== undefined) {\r\n                        let actualPrecision = result.length;\r\n                        let isNegative = value < 0;\r\n                        if (isNegative) {\r\n                            actualPrecision--;\r\n                        }\r\n                        let paddingZerosCount = precision - actualPrecision;\r\n                        let paddingZeros = undefined;\r\n                        if (paddingZerosCount > 0) {\r\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\r\n                        }\r\n                        if (isNegative) {\r\n                            result = \"-\" + paddingZeros + result.substr(1);\r\n                        } else {\r\n                            result = paddingZeros + result;\r\n                        }\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                default:\r\n                    result = Globalize.format(value, format, culture);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Formats the number using custom format expression */\r\n        function formatNumberCustom(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture,\r\n            nonScientificOverrideFormat?: string): string {\r\n            let result: string;\r\n            let numberFormatInfo = culture.numberFormat;\r\n            if (isFinite(value)) {\r\n                // Split format by positive[;negative;zero] pattern\r\n                let formatComponents = getComponents(format);\r\n\r\n                // Pick a format based on the sign of value\r\n                if (value > 0) {\r\n                    format = formatComponents.positive;\r\n                } else if (value === 0) {\r\n                    format = formatComponents.zero;\r\n                } else {\r\n                    format = formatComponents.negative;\r\n                }\r\n\r\n                // Normalize value if we have an explicit negative format\r\n                if (formatComponents.hasNegative)\r\n                    value = Math.abs(value);\r\n\r\n                // Get format metadata\r\n                let formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\r\n\r\n                // Preserve literals and escaped chars\r\n                if (formatMeta.hasEscapes) {\r\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%‰\");\r\n                }\r\n                let literals: string[] = [];\r\n                if (formatMeta.hasQuotes) {\r\n                    format = FormattingEncoder.preserveLiterals(format, literals);\r\n                }\r\n\r\n                // Scientific format\r\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\r\n                    let scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\r\n                    if (scientificMatch) {\r\n                        // Case 2.1. Scientific custom format\r\n                        let formatM = format.substr(0, scientificMatch.index);\r\n                        let formatE = format.substr(scientificMatch.index + 2); // E(+|-)\r\n                        let precision = getCustomFormatPrecision(formatM, formatMeta);\r\n                        let scale = getCustomFormatScale(formatM, formatMeta);\r\n                        if (scale !== 1) {\r\n                            value = value * scale;\r\n                        }\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        let s = value.toExponential(precision);\r\n                        let indexOfE = s.indexOf(\"e\");\r\n                        let mantissa = s.substr(0, indexOfE);\r\n                        let exp = s.substr(indexOfE + 1);\r\n                        let resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\r\n                        let resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\r\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\r\n                            resultE = resultE.substr(1);\r\n                        }\r\n                        let e = scientificMatch[0].charAt(0);\r\n                        result = resultM + e + resultE;\r\n                    }\r\n                }\r\n\r\n                // Non scientific format\r\n                if (result === undefined) {\r\n                    let valueFormatted: string;\r\n                    let isValueGlobalized: boolean = false;\r\n                    let precision = getCustomFormatPrecision(format, formatMeta);\r\n                    let scale = getCustomFormatScale(format, formatMeta);\r\n\r\n                    if (scale !== 1)\r\n                        value = value * scale;\r\n\r\n                    // Rounding\r\n                    value = parseFloat(toNonScientific(value, precision));\r\n\r\n                    if (nonScientificOverrideFormat) {\r\n                        // Get numeric format from format string\r\n                        let numericFormat = NumberFormat.getNumericFormat(value, format);\r\n\r\n                        // Add separators and decimalFormat to nonScientificFormat\r\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\r\n\r\n                        // Format the value\r\n                        valueFormatted = formattingService.format(nonScientificOverrideFormat, [value], culture.name);\r\n                        isValueGlobalized = true;\r\n                    }\r\n                    else\r\n                        valueFormatted = toNonScientific(value, precision);\r\n\r\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\r\n                }\r\n                if (formatMeta.hasQuotes) {\r\n                    result = FormattingEncoder.restoreLiterals(result, literals);\r\n                }\r\n                if (formatMeta.hasEscapes) {\r\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%‰\");\r\n                }\r\n\r\n                _lastCustomFormatMeta = formatMeta;\r\n            } else {\r\n                return Globalize.format(value, undefined);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Returns string with the fixed point respresentation of the number */\r\n        function toNonScientific(value: number, precision: number): string {\r\n            let result = \"\";\r\n            let precisionZeros = 0;\r\n            // Double precision numbers support actual 15-16 decimal digits of precision.\r\n            if (precision > 16) {\r\n                precisionZeros = precision - 16;\r\n                precision = 16;\r\n            }\r\n            let digitsBeforeDecimalPoint = Double.log10(Math.abs(value));\r\n            if (digitsBeforeDecimalPoint < 16) {\r\n                if (digitsBeforeDecimalPoint > 0) {\r\n                    let maxPrecision = 16 - digitsBeforeDecimalPoint;\r\n                    if (precision > maxPrecision) {\r\n                        precisionZeros += precision - maxPrecision;\r\n                        precision = maxPrecision;\r\n                    }\r\n                }\r\n                result = value.toFixed(precision);\r\n            } else if (digitsBeforeDecimalPoint === 16) {\r\n                result = value.toFixed(0);\r\n                precisionZeros += precision;\r\n                if (precisionZeros > 0) {\r\n                    result += \".\";\r\n                }\r\n            } else { // digitsBeforeDecimalPoint > 16\r\n                // Different browsers have different implementations of the toFixed().\r\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\r\n                // So we need to check for range and convert the to exponential with the max precision.\r\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\r\n                // Assert that value is a number and fall back on returning value if it is not\r\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                if (typeof (value) !== \"number\")\r\n                    return String(value);\r\n                result = value.toExponential(15);\r\n                let indexOfE = result.indexOf(\"e\");\r\n                if (indexOfE > 0) {\r\n                    let indexOfDot = result.indexOf(\".\");\r\n                    let mantissa = result.substr(0, indexOfE);\r\n                    let exp = result.substr(indexOfE + 1);\r\n                    let powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\r\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\r\n                    if (precision > 0) {\r\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\r\n                    }\r\n                }\r\n            }\r\n            if (precisionZeros > 0) {\r\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the formatMetadata of the format\r\n         * When calculating precision and scale, if format string of\r\n         * positive[;negative;zero] => positive format will be used\r\n         * @param (required) format - format string\r\n         * @param (optional) calculatePrecision - calculate precision of positive format\r\n         * @param (optional) calculateScale - calculate scale of positive format\r\n         */\r\n        export function getCustomFormatMetadata(format: string, calculatePrecision?: boolean, calculateScale?: boolean): NumericFormatMetadata {\r\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\r\n                return _lastCustomFormatMeta;\r\n            }\r\n\r\n            let result = {\r\n                format: format,\r\n                hasEscapes: false,\r\n                hasQuotes: false,\r\n                hasE: false,\r\n                hasCommas: false,\r\n                hasDots: false,\r\n                hasPercent: false,\r\n                hasPermile: false,\r\n                precision: undefined,\r\n                scale: undefined,\r\n            };\r\n\r\n            for (let i = 0, length = format.length; i < length; i++) {\r\n                let c = format.charAt(i);\r\n                switch (c) {\r\n                    case \"\\\\\":\r\n                        result.hasEscapes = true;\r\n                        break;\r\n                    case \"'\":\r\n                    case \"\\\"\":\r\n                        result.hasQuotes = true;\r\n                        break;\r\n                    case \"e\":\r\n                    case \"E\":\r\n                        result.hasE = true;\r\n                        break;\r\n                    case \",\":\r\n                        result.hasCommas = true;\r\n                        break;\r\n                    case \".\":\r\n                        result.hasDots = true;\r\n                        break;\r\n                    case \"%\":\r\n                        result.hasPercent = true;\r\n                        break;\r\n                    case \"‰\":\r\n                        result.hasPermile = true;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Use positive format for calculating these values\r\n            let formatComponents = getComponents(format);\r\n\r\n            if (calculatePrecision)\r\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\r\n            if (calculateScale)\r\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\r\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\r\n        function getCustomFormatPrecision(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.precision > -1) {\r\n                return formatMeta.precision;\r\n            }\r\n            let result = 0;\r\n            if (formatMeta.hasDots) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex > -1) {\r\n                    let count = format.length;\r\n                    for (let i = dotIndex; i < count; i++) {\r\n                        let char = format.charAt(i);\r\n                        if (char.match(NumericPlaceholderRegex))\r\n                            result++;\r\n                        // 0.00E+0 :: Break before counting 0 in\r\n                        // exponential portion of format string\r\n                        if (char === ExponentialFormatChar)\r\n                            break;\r\n                    }\r\n                    result = Math.min(19, result);\r\n                }\r\n            }\r\n\r\n            formatMeta.precision = result;\r\n            return result;\r\n        }\r\n\r\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\r\n        function getCustomFormatScale(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.scale > -1) {\r\n                return formatMeta.scale;\r\n            }\r\n            let result = 1;\r\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\r\n                result = result * 100;\r\n            }\r\n            if (formatMeta.hasPermile && format.indexOf(\"‰\") > -1) {\r\n                result = result * 1000;\r\n            }\r\n            if (formatMeta.hasCommas) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex === -1) {\r\n                    dotIndex = format.length;\r\n                }\r\n                for (let i = dotIndex - 1; i > -1; i--) {\r\n                    let char = format.charAt(i);\r\n                    if (char === \",\") {\r\n                        result = result / 1000;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            formatMeta.scale = result;\r\n            return result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormat(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, nonScientificOverrideFormat?: string, isValueGlobalized?: boolean): string {\r\n            let suppressModifyValue = !!nonScientificOverrideFormat;\r\n            let formatParts = format.split(\".\", 2);\r\n            if (formatParts.length === 2) {\r\n                let wholeFormat = formatParts[0];\r\n                let fractionFormat = formatParts[1];\r\n                let displayUnit = \"\";\r\n\r\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\r\n                if (nonScientificOverrideFormat) {\r\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\r\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\r\n                    value = value.replace(displayUnit, \"\");\r\n                }\r\n\r\n                let globalizedDecimalSeparator = numberFormatInfo[\".\"];\r\n                let decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\r\n                let valueParts = value.split(decimalSeparator, 2);\r\n                let wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\r\n                let fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\r\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\r\n\r\n                let wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\r\n                let fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\r\n\r\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\r\n                    return wholeFormattedValue + fractionFormattedValue.value;\r\n\r\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\r\n            }\r\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatLeft(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, suppressModifyValue?: boolean): string {\r\n            let groupSymbolIndex = format.indexOf(\",\");\r\n            let enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\r\n            let groupDigitCount = 0;\r\n            let groupIndex = 0;\r\n            let groupSizes = numberFormatInfo.groupSizes || [3];\r\n            let groupSize = groupSizes[0];\r\n            let groupSeparator = numberFormatInfo[\",\"];\r\n            let sign = \"\";\r\n            let firstChar = value.charAt(0);\r\n            if (firstChar === \"+\" || firstChar === \"-\") {\r\n                sign = numberFormatInfo[firstChar];\r\n                value = value.substr(1);\r\n            }\r\n            let isZero = value === \"0\";\r\n            let result = \"\";\r\n            let leftBuffer = \"\";\r\n            let vi = value.length - 1;\r\n            let fmtOnly = true;\r\n            // Iterate through format chars and replace 0 and # with the digits from the value string\r\n            for (let fi = format.length - 1; fi > -1; fi--) {\r\n                let formatChar = format.charAt(fi);\r\n                switch (formatChar) {\r\n                    case ZeroPlaceholder:\r\n                    case DigitPlaceholder:\r\n                        fmtOnly = false;\r\n                        if (leftBuffer !== \"\") {\r\n                            result = leftBuffer + result;\r\n                            leftBuffer = \"\";\r\n                        }\r\n                        if (!suppressModifyValue) {\r\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\r\n                                if (enableGroups) {\r\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\r\n                                    if (groupDigitCount === groupSize) {\r\n                                        result = groupSeparator + result;\r\n                                        groupIndex++;\r\n                                        if (groupIndex < groupSizes.length) {\r\n                                            groupSize = groupSizes[groupIndex];\r\n                                        }\r\n                                        groupDigitCount = 1;\r\n                                    } else {\r\n                                        groupDigitCount++;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (vi > -1) {\r\n                                if (isZero && formatChar === DigitPlaceholder) {\r\n                                    // Special case - if we need to format a zero value and the # symbol is used - we don't copy it into the result)\r\n                                } else {\r\n                                    result = value.charAt(vi) + result;\r\n                                }\r\n                                vi--;\r\n                            } else if (formatChar !== DigitPlaceholder) {\r\n                                result = formatChar + result;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \",\":\r\n                        // We should skip all the , chars\r\n                        break;\r\n                    default:\r\n                        leftBuffer = formatChar + leftBuffer;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\r\n            if (!suppressModifyValue) {\r\n                if (vi > -1 && result !== \"\") {\r\n                    if (enableGroups) {\r\n                        while (vi > -1) {\r\n                            if (groupDigitCount === groupSize) {\r\n                                result = groupSeparator + result;\r\n                                groupIndex++;\r\n                                if (groupIndex < groupSizes.length) {\r\n                                    groupSize = groupSizes[groupIndex];\r\n                                }\r\n                                groupDigitCount = 1;\r\n                            } else {\r\n                                groupDigitCount++;\r\n                            }\r\n                            result = value.charAt(vi) + result;\r\n                            vi--;\r\n                        }\r\n                    } else {\r\n                        result = value.substr(0, vi + 1) + result;\r\n                    }\r\n                }\r\n                // Insert sign in front of the leftBuffer and result\r\n                return sign + leftBuffer + result;\r\n            }\r\n\r\n            if (fmtOnly)\r\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\r\n                return sign + leftBuffer + result;\r\n\r\n            return sign + leftBuffer + value + result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatRight(value: string, format: string, suppressModifyValue?: boolean): { value: string; fmtOnly?: boolean } {\r\n            let vi = 0;\r\n            let fCount = format.length;\r\n            let vCount = value.length;\r\n\r\n            if (suppressModifyValue) {\r\n                debug.assert(fCount > 0, \"Empty formatting string\");\r\n\r\n                let lastChar = format.charAt(fCount - 1);\r\n                if (!lastChar.match(NumericPlaceholderRegex))\r\n                    return {\r\n                        value: value + lastChar,\r\n                        fmtOnly: value === \"\",\r\n                    };\r\n\r\n                return {\r\n                    value: value,\r\n                    fmtOnly: value === \"\",\r\n                };\r\n            }\r\n\r\n            let result = \"\",\r\n                fmtOnly: boolean = true;\r\n            for (let fi = 0; fi < fCount; fi++) {\r\n                let formatChar = format.charAt(fi);\r\n                if (vi < vCount) {\r\n                    switch (formatChar) {\r\n                        case ZeroPlaceholder:\r\n                        case DigitPlaceholder:\r\n                            result += value[vi++];\r\n                            fmtOnly = false;\r\n                            break;\r\n                        default:\r\n                            result += formatChar;\r\n                    }\r\n                } else {\r\n                    if (formatChar !== DigitPlaceholder) {\r\n                        result += formatChar;\r\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                value: result,\r\n                fmtOnly: fmtOnly,\r\n            };\r\n        }\r\n\r\n        function localize(value: string, dictionary: any): string {\r\n            let plus = dictionary[\"+\"];\r\n            let minus = dictionary[\"-\"];\r\n            let dot = dictionary[\".\"];\r\n            let comma = dictionary[\",\"];\r\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\r\n                return value;\r\n            }\r\n            let count = value.length;\r\n            let result = \"\";\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \"+\":\r\n                        result = result + plus;\r\n                        break;\r\n                    case \"-\":\r\n                        result = result + minus;\r\n                        break;\r\n                    case \".\":\r\n                        result = result + dot;\r\n                        break;\r\n                    case \",\":\r\n                        result = result + comma;\r\n                        break;\r\n                    default:\r\n                        result = result + char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n    }\r\n\r\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\r\n    class DateTimeScaleFormatInfo {\r\n\r\n        // Fields\r\n        public YearPattern: string;\r\n        public MonthPattern: string;\r\n        public DayPattern: string;\r\n        public HourPattern: string;\r\n        public MinutePattern: string;\r\n        public SecondPattern: string;\r\n        public MillisecondPattern: string;\r\n\r\n        // Constructor\r\n        /**\r\n         * Creates new instance of the DateTimeScaleFormatInfo class.\r\n         * @param culture - culture which calendar info is going to be used to derive the formats.\r\n         */\r\n        constructor(culture: Culture) {\r\n            let calendar: Calendar = culture.calendar;\r\n            let patterns: any = calendar.patterns;\r\n            let monthAbbreviations: any = calendar[\"months\"][\"namesAbbr\"];\r\n            let cultureHasMonthAbbr: boolean = monthAbbreviations && monthAbbreviations[0];\r\n            let yearMonthPattern: string = patterns[\"Y\"];\r\n            let monthDayPattern: string = patterns[\"M\"];\r\n            let fullPattern: string = patterns[\"f\"];\r\n            let longTimePattern: string = patterns[\"T\"];\r\n            let shortTimePattern: string = patterns[\"t\"];\r\n            let separator: string = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\r\n\r\n            let hasYearSymbol: boolean = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\r\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\r\n\r\n            let yearPos: number = fullPattern.indexOf(\"yy\");\r\n            let monthPos: number = fullPattern.indexOf(\"MMMM\");\r\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\r\n\r\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\r\n\r\n            let minutePos: number = fullPattern.indexOf(\"mm\");\r\n            let pmPos: number = fullPattern.indexOf(\"tt\");\r\n            let shortHourPattern: string = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\r\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\r\n\r\n            this.MinutePattern = shortTimePattern;\r\n\r\n            this.SecondPattern = longTimePattern;\r\n\r\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\r\n\r\n            // Special cases\r\n            switch (culture.name) {\r\n                case \"fi-FI\":\r\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\r\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Methods\r\n\r\n        /**\r\n         * Returns the format string of the provided DateTimeUnit.\r\n         * @param unit - date or time unit\r\n         */\r\n        public getFormatString(unit: DateTimeUnit): string {\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return this.YearPattern;\r\n                case DateTimeUnit.Month:\r\n                    return this.MonthPattern;\r\n                case DateTimeUnit.Week:\r\n                case DateTimeUnit.Day:\r\n                    return this.DayPattern;\r\n                case DateTimeUnit.Hour:\r\n                    return this.HourPattern;\r\n                case DateTimeUnit.Minute:\r\n                    return this.MinutePattern;\r\n                case DateTimeUnit.Second:\r\n                    return this.SecondPattern;\r\n                case DateTimeUnit.Millisecond:\r\n                    return this.MillisecondPattern;\r\n            }\r\n\r\n            debug.assertFail('Unexpected unit: ' + unit);\r\n        }\r\n    }\r\n\r\n    export var formattingService: IFormattingService = new FormattingService();\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\r\n    export module SQExprShortSerializer {\r\n        export function serialize(expr: SQExpr): string {\r\n            return JSON.stringify(expr.accept(SQExprSerializer.instance));\r\n        }\r\n\r\n        export function serializeArray(exprs: SQExpr[]): string {\r\n            let str = '[';\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                if (i > 0)\r\n                    str += ',';\r\n                str += SQExprShortSerializer.serialize(exprs[i]);\r\n            }\r\n            return str + ']';\r\n        }\r\n\r\n        /** Responsible for serializing an SQExpr into a comparable string. */\r\n        class SQExprSerializer extends DefaultSQExprVisitor<{}> {\r\n            public static instance: SQExprSerializer = new SQExprSerializer();\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): {} {\r\n                return {\r\n                    col: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): {} {\r\n                return {\r\n                    measure: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): {} {\r\n                return {\r\n                    agg: {\r\n                        a: expr.arg.accept(this),\r\n                        f: expr.func,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitEntity(expr: SQEntityExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n                debug.assertValue(expr.entity, 'expr.entity');\r\n\r\n                return {\r\n                    e: expr.entity\r\n                };\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): {} {\r\n                return {\r\n                    h: expr.arg.accept(this),\r\n                    l: expr.level,\r\n                };\r\n            }\r\n\r\n            public visitHierarchy(expr: SQHierarchyExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    h: expr.hierarchy,\r\n                };\r\n            }\r\n\r\n            public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    n: expr.name,\r\n                    p: expr.property,\r\n                };\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    and: {\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    comp: {\r\n                        k: expr.comparison,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    const: {\r\n                        t: expr.type.primitiveType,\r\n                        v: expr.value,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    arithmetic: {\r\n                        o: expr.operator,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitScopedEval(expr: SQScopedEvalExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    scopedEval: {\r\n                        e: expr.expression.accept(this),\r\n                        s: serializeArray(expr.scope)\r\n                    }\r\n                };\r\n            }\r\n            \r\n            public visitWithRef(expr: SQWithRefExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n                \r\n                return {\r\n                    withRef: {\r\n                        e: expr.expressionName\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): {} {\r\n                debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n    import Selector = powerbi.data.Selector;\r\n    import SelectorsByColumn = powerbi.SelectorsByColumn;\r\n    import SelectorForColumn = powerbi.SelectorForColumn;\r\n\r\n    /**\r\n     * A combination of identifiers used to uniquely identify\r\n     * data points and their bound geometry.\r\n     */\r\n    export class SelectionId implements ISelectionId {\r\n        private selector: Selector;\r\n        // This is a new data structure to support drilling -- in the long term it should replace the 'selector' field\r\n        private selectorsByColumn: SelectorsByColumn;\r\n        private key: string;\r\n        private keyWithoutHighlight: string;\r\n\r\n        public highlight: boolean;\r\n\r\n        constructor(selector: Selector, highlight: boolean) {\r\n            this.selector = selector;\r\n            this.highlight = highlight;\r\n            this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\r\n            this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\r\n        }\r\n\r\n        public equals(other: SelectionId): boolean {\r\n            if (!this.selector || !other.selector) {\r\n                return (!this.selector === !other.selector) && this.highlight === other.highlight;\r\n            }\r\n            return this.highlight === other.highlight &&  Selector.equals(this.selector, other.selector);\r\n        }\r\n        \r\n        /**\r\n         * Checks equality against other for all identifiers existing in this.\r\n         */\r\n        public includes(other: SelectionId, ignoreHighlight: boolean = false): boolean {\r\n            let thisSelector = this.selector;\r\n            let otherSelector = other.selector;\r\n            if (!thisSelector || !otherSelector) {\r\n                return false;\r\n            }\r\n            let thisData = thisSelector.data;\r\n            let otherData = otherSelector.data;\r\n            if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\r\n                return false;\r\n            if (!ignoreHighlight && this.highlight !== other.highlight)\r\n                return false;\r\n            if (thisData) {\r\n                if (!otherData)\r\n                    return false;\r\n                if (thisData.length > 0) {\r\n                    for (let i = 0, ilen = thisData.length; i < ilen; i++) {\r\n                        var thisValue = <DataViewScopeIdentity>thisData[i];\r\n                        if (!otherData.some((otherValue: DataViewScopeIdentity) => DataViewScopeIdentity.equals(thisValue, otherValue)))\r\n                            return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public getKey(): string {\r\n            return this.key;\r\n        }\r\n\r\n        public getKeyWithoutHighlight(): string {\r\n            return this.keyWithoutHighlight;\r\n        }\r\n        \r\n        public hasIdentity(): boolean {\r\n            return (this.selector && !!this.selector.data);\r\n        }\r\n\r\n        public getSelector(): Selector {\r\n            return this.selector;\r\n        }\r\n\r\n        public getSelectorsByColumn(): Selector {\r\n            return this.selectorsByColumn;\r\n        }\r\n\r\n        public static createNull(highlight: boolean = false): SelectionId {\r\n            return new SelectionId(null, highlight);\r\n        }\r\n\r\n        public static createWithId(id: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            if (id) {\r\n                selector = {\r\n                    data: [id]\r\n                };\r\n            }\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithMeasure(measureId: string, highlight: boolean = false): SelectionId {\r\n            debug.assertValue(measureId, 'measureId');\r\n\r\n            let selector: Selector = {\r\n                metadata: measureId\r\n            };\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n            selectionId.selectorsByColumn = { metadata: measureId };\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasure(id: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: powerbi.data.Selector = {};\r\n            if (id) {\r\n                selector.data = [id];\r\n            }\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id && !measureId)\r\n                selector = null;\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasureAndCategory(id: DataViewScopeIdentity, measureId: string, queryName: string, highlight: boolean = false): SelectionId {\r\n            let selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\r\n\r\n            if (selectionId.selector) {\r\n                selectionId.selectorsByColumn = {};\r\n                if (id && queryName) {\r\n                    selectionId.selectorsByColumn.dataMap = {};\r\n                    selectionId.selectorsByColumn.dataMap[queryName] = id;\r\n                }\r\n                if (measureId)\r\n                    selectionId.selectorsByColumn.metadata = measureId;\r\n            }\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIds(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector = { data: selectorData };\r\n            \r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithIdsAndMeasure(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = {};\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector.data = selectorData;\r\n\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id1 && !id2 && !measureId)\r\n                selector = null;\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithSelectorForColumnAndMeasure(dataMap: SelectorForColumn, measureId: string, highlight: boolean = false): SelectionId {\r\n\r\n            let selectionId: visuals.SelectionId;\r\n            let keys = Object.keys(dataMap);\r\n            if (keys.length === 2) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], <DataViewScopeIdentity>dataMap[keys[1]], measureId, highlight);\r\n            } else if (keys.length === 1) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], null, measureId, highlight);\r\n            } else {\r\n                selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\r\n            }\r\n\r\n            let selectorsByColumn: SelectorsByColumn = {};\r\n            if (!_.isEmpty(dataMap))\r\n                selectorsByColumn.dataMap = dataMap;\r\n            if (measureId)\r\n                selectorsByColumn.metadata = measureId;\r\n            if (!dataMap && !measureId)\r\n                selectorsByColumn = null;\r\n\r\n            selectionId.selectorsByColumn = selectorsByColumn;\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithHighlight(original: SelectionId): SelectionId {\r\n            debug.assertValue(original, 'original');\r\n            debug.assert(!original.highlight, '!original.highlight');\r\n\r\n            let newId = new SelectionId(original.getSelector(), /*highlight*/ true);\r\n            newId.selectorsByColumn = original.selectorsByColumn;\r\n\r\n            return newId;\r\n        }\r\n\r\n        private static idArray(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity): DataViewScopeIdentity[] {\r\n            if (id1 || id2) {\r\n                let data = [];\r\n                if (id1)\r\n                    data.push(id1);\r\n                if (id2 && id2 !== id1)\r\n                    data.push(id2);\r\n                return data;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class is designed to simplify the creation of SelectionId objects\r\n     * It allows chaining to build up an object before calling 'create' to build a SelectionId\r\n     */\r\n    export class SelectionIdBuilder implements ISelectionIdBuilder {\r\n        private dataMap: SelectorForColumn;\r\n        private measure: string;\r\n\r\n        public static builder(): SelectionIdBuilder {\r\n            return new SelectionIdBuilder();\r\n        }\r\n\r\n        public withCategory(categoryColumn: DataViewCategoryColumn, index: number): this{\r\n            if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\r\n                this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\r\n            \r\n            return this;\r\n        }\r\n\r\n        public withSeries(seriesColumn: DataViewValueColumns, valueColumn: DataViewValueColumn | DataViewValueColumnGroup): this {\r\n            if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\r\n                this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\r\n\r\n            return this;\r\n        }\r\n\r\n        public withMeasure(measureId: string): this {\r\n            this.measure = measureId;\r\n\r\n            return this;\r\n        }\r\n\r\n        public createSelectionId(): SelectionId {\r\n            return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\r\n        }\r\n\r\n        private ensureDataMap(): SelectorForColumn {\r\n            if (!this.dataMap)\r\n                this.dataMap = {};\r\n\r\n            return this.dataMap;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}